import { expect } from "chai"
import { TestScheduler } from "rxjs/testing"
import { of, interval, EMPTY, Observable } from "rxjs"
import { audit, take, mergeMap } from "rxjs/operators"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {audit} */
describe("audit operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should emit the last value in each time window", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a-xy-----b--x--cxyz-|")
        const e1subs = "  ^--------------------!"
        const e2 = cold("  ----i                ")
        //                          ----i
        //                                ----i
        const e2subs = [
          "               -^---!                ",
          "               ----------^---!       ",
          "               ----------------^---! ",
        ]
        const expected = "-----y--------x-----z|"
        const result = e1.pipe(audit(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should delay the source if values are not emitted often enough", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a--------b-----c----|")
        const e1subs = "  ^--------------------!"
        const e2 = cold("  ----x                ")
        const e2subs = [
          "               -^---!                ",
          "               ----------^---!       ",
          "               ----------------^---! ",
        ]
        const expected = "-----a--------b-----c|"
        const result = e1.pipe(audit(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should audit with duration Observable using next to close the duration", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("   -a-xy-----b--x--cxxx-|")
        const e1subs = "   ^--------------------!"
        const e2 = cold("   ----x-y-z            ")
        const e2subs = [
          "                -^---!                ",
          "                ----------^---!       ",
          "                ----------------^---! ",
        ]
        const expected = " -----y--------x-----x|"
        const result = e1.pipe(audit(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should interrupt source and duration when result is unsubscribed early", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a-x-y-z-xyz-x-y-z----b--x-x-|")
        const unsub = "   --------------!               "
        const e1subs = "  ^-------------!               "
        const e2 = cold("  -----x------------|          ")
        const e2subs = [
          "               -^----!                       ",
          "               -------^----!                 ",
          "               -------------^!               ",
        ]
        const expected = "------y-----z--               "
        const result = e1.pipe(audit(() => e2))
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a-x-y-z-xyz-x-y-z----b--x-x-|")
        const e1subs = "  ^-------------!               "
        const e2 = cold("  -----x------------|          ")
        const e2subs = [
          "               -^----!                       ",
          "               -------^----!                 ",
          "               -------------^!               ",
        ]
        const expected = "------y-----z--               "
        const unsub = "   --------------!               "
        const result = e1.pipe(
          mergeMap((x: string) => of(x)),
          audit(() => e2),
          mergeMap((x: string) => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should handle a busy producer emitting a regular repeating sequence", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  abcdefabcdefabcdefabcdefa|    ")
        const e1subs = "  ^------------------------!    "
        const e2 = cold(" -----x                        ")
        const e2subs = [
          "               ^----!                        ",
          "               ------^----!                  ",
          "               ------------^----!            ",
          "               ------------------^----!      ",
          "               ------------------------^----!",
        ]
        const expected = "-----f-----f-----f-----f-----(a|)"
        const result = e1.pipe(audit(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should mirror source if durations are immediate", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  abcdefabcdefabcdefabcdefa|")
        const e1subs = "  ^------------------------!"
        const e2 = cold(" x")
        const expected = "abcdefabcdefabcdefabcdefa|"
        const result = e1.pipe(audit(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should emit no values if durations are EMPTY", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  abcdefabcdefabcdefabcdefa|")
      const e1subs = "  ^------------------------!"
      const e2 = EMPTY
      const expected = "-------------------------|"
      const result = e1.pipe(audit(() => e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit no values and never complete if duration is a never", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ----abcdefabcdefabcdefabcdefa|")
        const e1subs = "  ^----------------------------!"
        const e2 = cold(" -")
        const e2subs = "  ----^-------------------------"
        const expected = "------------------------------"
        const result = e1.pipe(audit(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should unsubscribe duration Observable when source raise error", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ----abcdefabcdefabcdefabcdefa#")
        const e1subs = "  ^----------------------------!"
        const e2 = cold(" -")
        const e2subs = "  ----^------------------------!"
        const expected = "-----------------------------#"
        const result = e1.pipe(audit(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should mirror source if durations are synchronous observables", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  abcdefabcdefabcdefabcdefa|")
      const e1subs = "  ^------------------------!"
      const e2 = of("one single value")
      const expected = "abcdefabcdefabcdefabcdefa|"
      const result = e1.pipe(audit(() => e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error as soon as just-throw duration is used", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ----abcdefabcdefabcdefabcdefa|")
        const e1subs = "  ^---!                         "
        const e2 = cold(" #")
        const e2subs = "  ----(^!)                      "
        const expected = "----(-#)                      "
        const result = e1.pipe(audit(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should audit using durations of varying lengths", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  abcdefabcdabcdefghabca|     ")
        const e1subs = "  ^---------------------!     "
        const e2 = [
          cold("          -----x                      "),
          cold("              ---x                    "),
          cold("                  -------x            "),
          cold("                        --x           "),
          cold("                           ----x      "),
        ]
        const e2subs = [
          "               ^----!                      ",
          "               ------^--!                  ",
          "               ----------^------!          ",
          "               ------------------^-!       ",
          "               ---------------------^---!  ",
        ]
        const expected = "-----f---d-------h--c----(a|)"
        let i = 0
        const result = e1.pipe(audit(() => e2[i++]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        for (let j = 0; j < e2.length; j++) {
          expectSubscriptions(e2[j].subscriptions).toBe(e2subs[j])
        }
      }
    )
  })
  it("should propagate error from duration Observable", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  abcdefabcdabcdefghabca|")
        const e1subs = "  ^----------------!     "
        const e2 = [
          cold("          -----x                 "),
          cold("              ---x               "),
          cold("                  -------#       "),
        ]
        const e2subs = [
          "               ^----!                 ",
          "               ------^--!             ",
          "               ----------^------!     ",
        ]
        const expected = "-----f---d-------#     "
        let i = 0
        const result = e1.pipe(audit(() => e2[i++]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        for (let j = 0; j < e2.length; j++) {
          expectSubscriptions(e2[j].subscriptions).toBe(e2subs[j])
        }
      }
    )
  })
  it("should propagate error thrown from durationSelector function", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  abcdefabcdabcdefghabca|   ")
        const e1subs = "  ^---------!               "
        const e2 = [
          cold("          -----x                    "),
          cold("              ---x                  "),
          cold("                  -------x          "),
        ]
        // prettier-ignore
        const e2subs = [
        '               ^----!                     ',
        '               ------^--!                 ',
      ];
        const expected = "-----f---d#                "
        let i = 0
        const result = e1.pipe(
          audit(() => {
            if (i === 2) {
              throw "error"
            }
            return e2[i++]
          })
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        for (let j = 0; j < e2subs.length; j++) {
          expectSubscriptions(e2[j].subscriptions).toBe(e2subs[j])
        }
      }
    )
  })
  it("should complete when source does not emit", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -----|")
        const subs = "    ^----!"
        const expected = "-----|"
        function durationSelector() {
          return cold("-----|")
        }
        expectObservable(e1.pipe(audit(durationSelector))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      }
    )
  })
  it("should raise error when source does not emit and raises error", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -----#")
        const subs = "    ^----!"
        const expected = "-----#"
        function durationSelector() {
          return cold("   -----|")
        }
        expectObservable(e1.pipe(audit(durationSelector))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      }
    )
  })
  it("should handle an empty source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |")
      const subs = "    (^!)"
      const expected = "|"
      function durationSelector() {
        return cold("   -----|")
      }
      expectObservable(e1.pipe(audit(durationSelector))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should handle a never source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const subs = "    ^"
      const expected = "-"
      function durationSelector() {
        return cold("   -----|")
      }
      expectObservable(e1.pipe(audit(durationSelector))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should handle a throw source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #")
      const subs = "    (^!)"
      const expected = "#"
      function durationSelector() {
        return cold("   -----|")
      }
      expectObservable(e1.pipe(audit(durationSelector))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should audit by promise resolves", done => {
    const e1 = interval(10).pipe(take(5))
    const expected = [0, 1, 2, 3, 4]
    e1.pipe(audit(() => Promise.resolve(42))).subscribe({
      next: (x: number) => {
        expect(x).to.equal(expected.shift())
      },
      error: () => {
        done(new Error("should not be called"))
      },
      complete: () => {
        expect(expected.length).to.equal(0)
        done()
      },
    })
  })
  it("should raise error when promise rejects", done => {
    const e1 = interval(10).pipe(take(10))
    const expected = [0, 1, 2]
    const error = new Error("error")
    e1.pipe(
      audit((x: number) => {
        if (x === 3) {
          return new Promise((resolve: any, reject: any) => {
            reject(error)
          })
        } else {
          return new Promise((resolve: any) => {
            resolve(42)
          })
        }
      })
    ).subscribe({
      next: (x: number) => {
        expect(x).to.equal(expected.shift())
      },
      error: (err: any) => {
        expect(err).to.be.an("error", "error")
        expect(expected.length).to.equal(0)
        done()
      },
      complete: () => {
        done(new Error("should not be called"))
      },
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        audit(() => of(0)),
        take(3)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
  it("should emit last value after duration completes if source completes first", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a--------xy|  ")
        const e1subs = "  ^-----------!  "
        const e2 = cold("  ----x         ")
        // prettier-ignore
        const e2subs = [
        '               -^---!         ',
        '               ----------^---!',
      ];
        const expected = "-----a--------(y|)"
        const result = e1.pipe(audit(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
})
import { expect } from "chai"
import { of } from "rxjs"
import { auditTime, mergeMap } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {auditTime} */
describe("auditTime", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should emit the last value in each time window", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a-x-y----b---x-cx---|")
        const e1subs = "  ^--------------------!"
        const t = time("   -----|               ")
        //                          -----|
        //                                -----|
        const expected = "------y--------x-----(x|)"
        const result = e1.pipe(auditTime(t))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should auditTime events by 5 time units", done => {
    const expected = 3
    of(1, 2, 3)
      .pipe(auditTime(5))
      .subscribe((x: number) => {
        expect(x).to.equal(expected)
        done()
      })
  })
  it("should auditTime events multiple times", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -012-----01234---|")
        const e1subs = "  ^----------------!"
        const t = time("   -----|           ")
        //                         -----|
        const expected = "------2-------4--|"
        expectObservable(e1.pipe(auditTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should delay the source if values are not emitted often enough", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a--------b-----c----|")
        const e1subs = "  ^--------------------!"
        const t = time("   -----|               ")
        //                          -----|
        //                                -----|
        const expected = "------a--------b-----(c|)"
        expectObservable(e1.pipe(auditTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should handle a busy producer emitting a regular repeating sequence", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  abcdefabcdefabcdefabcdefa|")
        const e1subs = "  ^------------------------!"
        const t = time("  -----|                    ")
        //                      -----|
        //                            -----|
        //                                  -----|
        //                                        -----|
        const expected = "-----f-----f-----f-----f-----(a|)"
        expectObservable(e1.pipe(auditTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should complete when source does not emit", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -----|")
        const e1subs = "  ^----!"
        const t = time("  --|   ")
        const expected = "-----|"
        expectObservable(e1.pipe(auditTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should raise error when source does not emit and raises error", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -----#")
        const e1subs = "  ^----!"
        const t = time("  --|   ")
        const expected = "-----#"
        expectObservable(e1.pipe(auditTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should handle an empty source", () => {
    testScheduler.run(
      ({ cold, time, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" |   ")
        const e1subs = "  (^!)"
        const t = time("  ---|")
        const expected = "|   "
        expectObservable(e1.pipe(auditTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should handle a never source", () => {
    testScheduler.run(
      ({ cold, time, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" -  ")
        const e1subs = "  ^  "
        const t = time("  --|")
        const expected = "-  "
        expectObservable(e1.pipe(auditTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should handle a throw source", () => {
    testScheduler.run(
      ({ cold, time, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" #   ")
        const e1subs = "  (^!)"
        const t = time("  ---|")
        const expected = "#   "
        expectObservable(e1.pipe(auditTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not complete when source does not complete", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a--(bc)-------d----------------")
        const e1subs = "  ^------------------------------!"
        const t = time("   -----|                         ")
        //                               -----|
        const expected = "------c-------------d-----------"
        const unsub = "   -------------------------------!"
        expectObservable(e1.pipe(auditTime(t)), unsub).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a--(bc)-------d----------------")
        const e1subs = "  ^------------------------------!"
        const t = time("   -----|                         ")
        //                               -----|
        const expected = "------c-------------d-----------"
        const unsub = "   -------------------------------!"
        const result = e1.pipe(
          mergeMap((x: string) => of(x)),
          auditTime(t),
          mergeMap((x: string) => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should auditTime values until source raises error", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a--(bc)-------d---------------#")
        const e1subs = "  ^------------------------------!"
        const t = time("   -----|                         ")
        //                               -----|
        const expected = "------c-------------d----------#"
        expectObservable(e1.pipe(auditTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
})
import { buffer, mergeMap, take, window, toArray } from "rxjs/operators"
import { EMPTY, NEVER, throwError, of, Subject } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
import { expect } from "chai"
/** @test {buffer} */
describe("Observable.prototype.buffer", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should emit buffers that close and reopen", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const a = hot("   -a-b-c-d-e-f-g-h-i-|")
      const b = hot("   -----B-----B-----B-|")
      const expected = "-----x-----y-----z-(F|)"
      const expectedValues = {
        x: ["a", "b", "c"],
        y: ["d", "e", "f"],
        z: ["g", "h", "i"],
        F: [],
      }
      expectObservable(a.pipe(buffer(b))).toBe(expected, expectedValues)
    })
  })
  it("should emit a final buffer if the closingNotifier is already complete", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const a = hot("   -a-b-c-d-e-f-g-h-i-|")
      const b = hot("   -----B-----B--|")
      const expected = "-----x-----y-------(F|)"
      const expectedValues = {
        x: ["a", "b", "c"],
        y: ["d", "e", "f"],
        F: ["g", "h", "i"],
      }
      expectObservable(a.pipe(buffer(b))).toBe(expected, expectedValues)
    })
  })
  it("should emit all buffered values if the source completes before the closingNotifier does", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("---^---a---b---c---d---e--f----|")
      const sourceSubs = "   ^---------------------------!"
      const closer = hot("---^-------------B----------------")
      const closerSubs = "   ^---------------------------!"
      const expected = "     --------------x-------------(F|)"
      const result = source.pipe(buffer(closer))
      const expectedValues = {
        x: ["a", "b", "c"],
        F: ["d", "e", "f"],
      }
      expectObservable(result).toBe(expected, expectedValues)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      expectSubscriptions(closer.subscriptions).toBe(closerSubs)
    })
  })
  it("should work with empty and empty selector", () => {
    testScheduler.run(({ expectObservable }) => {
      const a = EMPTY
      const b = EMPTY
      const expected = "(F|)"
      expectObservable(a.pipe(buffer(b))).toBe(expected, { F: [] })
    })
  })
  it("should work with empty and non-empty selector", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const a = EMPTY
      const b = hot("-----a-----")
      const expected = "(F|)"
      expectObservable(a.pipe(buffer(b))).toBe(expected, { F: [] })
    })
  })
  it("should work with non-empty and empty selector", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const a = hot("--1--2--^--3--4--5---6----7--8--9---0---|")
      const b = EMPTY
      const expected = "     --------------------------------(F|)"
      expectObservable(a.pipe(buffer(b))).toBe(expected, {
        F: ["3", "4", "5", "6", "7", "8", "9", "0"],
      })
    })
  })
  it("should work with never and never selector", () => {
    testScheduler.run(({ expectObservable }) => {
      const a = NEVER
      const b = NEVER
      const expected = "-"
      expectObservable(a.pipe(buffer(b))).toBe(expected)
    })
  })
  it("should work with never and empty selector", () => {
    testScheduler.run(({ expectObservable }) => {
      const a = NEVER
      const b = EMPTY
      const expected = "-"
      expectObservable(a.pipe(buffer(b))).toBe(expected)
    })
  })
  it("should work with empty and never selector", () => {
    testScheduler.run(({ expectObservable }) => {
      const a = EMPTY
      const b = NEVER
      const expected = "(F|)"
      expectObservable(a.pipe(buffer(b))).toBe(expected, { F: [] })
    })
  })
  it("should work with non-empty and throw selector", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const a = hot("---^--a--")
      const b = throwError(() => new Error("too bad"))
      const expected = "#"
      expectObservable(a.pipe(buffer(b))).toBe(
        expected,
        null,
        new Error("too bad")
      )
    })
  })
  it("should work with throw and non-empty selector", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const a = throwError(() => new Error("too bad"))
      const b = hot("---^--a--")
      const expected = "#"
      expectObservable(a.pipe(buffer(b))).toBe(
        expected,
        null,
        new Error("too bad")
      )
    })
  })
  it("should work with error", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const a = hot("---^-------#", undefined, new Error("too bad"))
      const b = hot("---^--------")
      const expected = "--------#"
      expectObservable(a.pipe(buffer(b))).toBe(
        expected,
        null,
        new Error("too bad")
      )
    })
  })
  it("should work with error and non-empty selector", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const a = hot("---^-------#", undefined, new Error("too bad"))
      const b = hot("---^---a----")
      const expected = "----a---#"
      expectObservable(a.pipe(buffer(b))).toBe(
        expected,
        { a: [] },
        new Error("too bad")
      )
    })
  })
  it("should work with selector", () => {
    // Buffer Boundaries Simple (RxJS 4)
    testScheduler.run(({ hot, expectObservable }) => {
      const a = hot("--1--2--^--3--4--5---6----7--8--9---0---|")
      const b = hot("--------^--a-------b---cd---------e---f---|")
      const expected = "     ---a-------b---cd---------e---f-(F|)"
      const expectedValues = {
        a: ["3"],
        b: ["4", "5"],
        c: ["6"],
        d: [] as string[],
        e: ["7", "8", "9"],
        f: ["0"],
        F: [],
      }
      expectObservable(a.pipe(buffer(b))).toBe(expected, expectedValues)
    })
  })
  it("should work with selector completed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("--1--2--^--3--4--5---6----7--8--9---0---|")
      const subs = "         ^-------------------------------!"
      const b = hot("--------^--a-------b---cd|               ")
      const expected = "     ---a-------b---cd---------------(F|)"
      const expectedValues = {
        a: ["3"],
        b: ["4", "5"],
        c: ["6"],
        d: [] as string[],
        F: ["7", "8", "9", "0"],
      }
      expectObservable(a.pipe(buffer(b))).toBe(expected, expectedValues)
      expectSubscriptions(a.subscriptions).toBe(subs)
    })
  })
  it("should allow unsubscribing the result Observable early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("--1--2--^--3--4--5---6----7--8--9---0---|")
      const unsub = "        --------------!                  "
      const subs = "         ^-------------!                  "
      const b = hot("--------^--a-------b---cd|               ")
      const expected = "     ---a-------b---                  "
      const expectedValues = {
        a: ["3"],
        b: ["4", "5"],
      }
      expectObservable(a.pipe(buffer(b)), unsub).toBe(expected, expectedValues)
      expectSubscriptions(a.subscriptions).toBe(subs)
    })
  })
  it("should not break unsubscription chains when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("--1--2--^--3--4--5---6----7--8--9---0---|")
      const subs = "         ^-------------!                  "
      const b = hot("--------^--a-------b---cd|               ")
      const expected = "     ---a-------b---                  "
      const unsub = "        --------------!                  "
      const expectedValues = {
        a: ["3"],
        b: ["4", "5"],
      }
      const result = a.pipe(
        mergeMap((x: any) => of(x)),
        buffer(b),
        mergeMap((x: any) => of(x))
      )
      expectObservable(result, unsub).toBe(expected, expectedValues)
      expectSubscriptions(a.subscriptions).toBe(subs)
    })
  })
  it("should work with non-empty and selector error", () => {
    // Buffer Boundaries onErrorSource (RxJS 4)
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("--1--2--^--3-----#", { "3": 3 }, new Error("too bad"))
      const subs = "         ^--------!"
      const b = hot("--------^--a--b---")
      const expected = "     ---a--b--#"
      const expectedValues = {
        a: [3],
        b: [] as string[],
      }
      expectObservable(a.pipe(buffer(b))).toBe(
        expected,
        expectedValues,
        new Error("too bad")
      )
      expectSubscriptions(a.subscriptions).toBe(subs)
    })
  })
  it("should work with non-empty and empty selector error", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const a = hot("--1--2--^--3--4--5---6----7--8--9---0---|")
      const b = hot(
        "--------^----------------#",
        undefined,
        new Error("too bad")
      )
      const expected = "     -----------------#"
      expectObservable(a.pipe(buffer(b))).toBe(
        expected,
        null,
        new Error("too bad")
      )
    })
  })
  it("should work with non-empty and selector error", () => {
    // Buffer Boundaries onErrorBoundaries (RxJS 4)
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const obj = { a: true, b: true, c: true }
      const a = hot("--1--2--^--3--4--5---6----7--8--9---0---|")
      const subs = "         ^----------------!"
      const b = hot("--------^--a-------b---c-#", obj, new Error("too bad"))
      const expected = "     ---a-------b---c-#"
      const expectedValues = {
        a: ["3"],
        b: ["4", "5"],
        c: ["6"],
      }
      expectObservable(a.pipe(buffer(b))).toBe(
        expected,
        expectedValues,
        new Error("too bad")
      )
      expectSubscriptions(a.subscriptions).toBe(subs)
    })
  })
  it("should unsubscribe notifier when source unsubscribed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("--1--2--^--3--4--5---6----7--8--9---0---|")
      const unsub = "        --------------!                  "
      const subs = "         ^-------------!                  "
      const b = hot("--------^--a-------b---cd|               ")
      const bsubs = "        ^-------------!                  "
      const expected = "     ---a-------b---                  "
      const expectedValues = {
        a: ["3"],
        b: ["4", "5"],
      }
      expectObservable(a.pipe(buffer(b)), unsub).toBe(expected, expectedValues)
      expectSubscriptions(a.subscriptions).toBe(subs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should unsubscribe notifier when source unsubscribed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("   -a-b-c-d-e-f-g-h-i-|")
      const b = hot("   -----1-----2-----3-|")
      const bsubs = "   ^----!"
      const expected = "-----(x|)"
      const expectedValues = {
        x: ["a", "b", "c"],
      }
      expectObservable(a.pipe(buffer(b), take(1))).toBe(
        expected,
        expectedValues
      )
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should emit properly with an observable using itself as a notifier", () => {
    const results: any[] = []
    const subject = new Subject<number>()
    subject.pipe(buffer(subject)).subscribe({
      next: value => results.push(value),
      complete: () => results.push("complete"),
    })
    subject.next(1)
    expect(results).to.deep.equal([[1]])
    subject.next(2)
    expect(results).to.deep.equal([[1], [2]])
    subject.complete()
    expect(results).to.deep.equal([[1], [2], [], "complete"])
  })
  describe("equivalence with the window operator", () => {
    const cases = [
      {
        source: "   -a-b-c-d-e-f-g-h-i-|",
        notifier: " -----B-----B-----B-|",
      },
      {
        source: "   -a-b-c-d-e-f-g-h-i-|",
        notifier: " -----B-----B--|     ",
      },
      {
        source: "   -a-b-c-d-e---------|",
        notifier: " -----B-----B-----B-|",
      },
      {
        source: "   -a-b-c-d-e-f-g-h-i-|",
        notifier: " -------------------|",
      },
    ]
    cases.forEach(({ source, notifier }, index) => {
      it(`should be equivalent for case ${index}`, () => {
        testScheduler.run(({ hot, expectObservable }) => {
          const a = hot(source)
          const b = hot(notifier)
          expectObservable(a.pipe(buffer(b))).toEqual(
            a.pipe(
              window(b),
              mergeMap(w => w.pipe(toArray()))
            )
          )
        })
      })
    })
  })
})
import { expect } from "chai"
import { Subject, of, Observable } from "rxjs"
import { bufferCount, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {bufferCount} */
describe("bufferCount operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should emit buffers at intervals", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const values = {
        v: ["a", "b", "c"],
        w: ["c", "d", "e"],
        x: ["e", "f", "g"],
        y: ["g", "h", "i"],
        z: ["i"],
      }
      const e1 = hot("  --a--b--c--d--e--f--g--h--i--|")
      const expected = "--------v-----w-----x-----y--(z|)"
      expectObservable(e1.pipe(bufferCount(3, 2))).toBe(expected, values)
    })
  })
  it("should emit buffers at buffersize of intervals if not specified", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const values = {
        x: ["a", "b"],
        y: ["c", "d"],
        z: ["e", "f"],
      }
      const e1 = hot("  --a--b--c--d--e--f--|")
      const expected = "-----x-----y-----z--|"
      expectObservable(e1.pipe(bufferCount(2))).toBe(expected, values)
    })
  })
  it("should buffer properly (issue #2062)", () => {
    const item$ = new Subject<number>()
    const results: any[] = []
    item$.pipe(bufferCount(3, 1)).subscribe(value => {
      results.push(value)
      if (value.join() === "1,2,3") {
        item$.next(4)
      }
    })
    item$.next(1)
    item$.next(2)
    item$.next(3)
    expect(results).to.deep.equal([
      [1, 2, 3],
      [2, 3, 4],
    ])
  })
  it("should emit partial buffers if source completes before reaching specified buffer count", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const e1 = hot("  --a--b--c--d--|")
      const expected = "--------------(x|)"
      expectObservable(e1.pipe(bufferCount(5))).toBe(expected, {
        x: ["a", "b", "c", "d"],
      })
    })
  })
  it("should emit full buffer then last partial buffer if source completes", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a^-b--c--d--e--|")
      const e1subs = "     ^-------------!"
      const expected = "   --------y-----(z|)"
      expectObservable(e1.pipe(bufferCount(3))).toBe(expected, {
        y: ["b", "c", "d"],
        z: ["e"],
      })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit buffers at intervals, but stop when result is unsubscribed early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        v: ["a", "b", "c"],
        w: ["c", "d", "e"],
      }
      const e1 = hot("  --a--b--c--d--e--f--g--h--i--|")
      const unsub = "   ------------------!           "
      const subs = "    ^-----------------!           "
      const expected = "--------v-----w----           "
      expectObservable(e1.pipe(bufferCount(3, 2)), unsub).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        v: ["a", "b", "c"],
        w: ["c", "d", "e"],
      }
      const e1 = hot("  --a--b--c--d--e--f--g--h--i--|")
      const subs = "    ^-----------------!           "
      const expected = "--------v-----w----           "
      const unsub = "   ------------------!           "
      const result = e1.pipe(
        mergeMap((x: any) => of(x)),
        bufferCount(3, 2),
        mergeMap((x: any) => of(x))
      )
      expectObservable(result, unsub).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should raise error if source raise error before reaching specified buffer count", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--#")
      const e1subs = "  ^-------------!"
      const expected = "--------------#"
      expectObservable(e1.pipe(bufferCount(5))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit buffers with specified skip count when skip count is less than window count", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        v: ["a", "b", "c"],
        w: ["b", "c", "d"],
        x: ["c", "d", "e"],
        y: ["d", "e"],
        z: ["e"],
      }
      const e1 = hot("  --a--b--c--d--e--|")
      const e1subs = "  ^----------------!"
      const expected = "--------v--w--x--(yz|)"
      expectObservable(e1.pipe(bufferCount(3, 1))).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit buffers with specified skip count when skip count is more than window count", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--b--c--d--e--|")
      const e1subs = "  ^----------------!"
      const expected = "-----y--------z--|"
      const values = {
        y: ["a", "b"],
        z: ["d", "e"],
      }
      expectObservable(e1.pipe(bufferCount(2, 3))).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(bufferCount(1), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import {
  of,
  throwError,
  interval,
  scheduled,
  asapScheduler,
  Subject,
} from "rxjs"
import { bufferTime, mergeMap, take, tap } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
import { expect } from "chai"
/** @test {bufferTime} */
describe("bufferTime operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should emit buffers at intervals", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ---a---b---c---d---e---f---g-----|   ")
        const subs = "    ^--------------------------------!   "
        const t = time("  ----------|                          ")
        const expected = "----------w---------x---------y--(z|)"
        const values = {
          w: ["a", "b"],
          x: ["c", "d", "e"],
          y: ["f", "g"],
          z: [] as string[],
        }
        const result = e1.pipe(bufferTime(t, null, Infinity, testScheduler))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      }
    )
  })
  it("should emit buffers at intervals test 2", () => {
    testScheduler.run(({ hot, time, expectObservable }) => {
      const e1 = hot(
        "  ---------a---------b---------c---------d---------e---------g--------|   "
      )
      const t = time(
        "  --------------------------------|                                       "
      )
      const expected =
        "--------------------------------x-------------------------------y---(z|)"
      const values = {
        x: ["a", "b", "c"],
        y: ["d", "e", "g"],
        z: [] as string[],
      }
      const result = e1.pipe(bufferTime(t, null, Infinity, testScheduler))
      expectObservable(result).toBe(expected, values)
    })
  })
  it("should emit buffers at intervals or when the buffer is full", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ---a---b---c---d---e---f---g-----|   ")
        const subs = "    ^--------------------------------!   "
        const t = time("  ----------|                          ")
        //                       ----------|
        //                               ----------|
        //                                       ----------|
        const expected = "-------w-------x-------y---------(z|)"
        const values = {
          w: ["a", "b"],
          x: ["c", "d"],
          y: ["e", "f"],
          z: ["g"],
        }
        const result = e1.pipe(bufferTime(t, null, 2, testScheduler))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      }
    )
  })
  it("should handle situations with a creation interval of zero", done => {
    // This is an odd scenario, and I can't imagine who is weird enough to want this, but here
    // it is. Someone scheduling buffers to open and close on microtasks, with values emitted on microtasks
    // NOTE: Trying this with a completely synchronous scheduler (like queueScheduler, which is
    // async relative to what it is scheduling, but synchronous relative to its container) will
    // cause your thread to lock up. Don't be weird. This test is just to prove behavior.
    const source = scheduled([0, 1, 2, 3, 4], asapScheduler)
    const results: any[] = []
    source.pipe(bufferTime(0, 0, asapScheduler)).subscribe({
      next: value => results.push(value),
      complete: () => {
        expect(results).to.deep.equal([
          // It opens one on 0 and closes it on 0
          [],
          // It opens one on 0, emits on 0, and closes on 0 (x 5)
          [0],
          [1],
          [2],
          [3],
          [4],
          // It opens one on 0, and then completes on 0, leaving us with an empty array.
          [],
        ])
        done()
      },
    })
  })
  it("should emit buffers at intervals or when the buffer is full test 2", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ---a---b---c---d---e---f---g-----|   ")
        const subs = "    ^--------------------------------!   "
        const t = time("  ----------|                          ")
        //                          ---------|---------|---------|
        const expected = "----------w--------x---------y---(z|)"
        const values = {
          w: ["a", "b"],
          x: ["c", "d", "e"],
          y: ["f", "g"],
          z: [] as string[],
        }
        const result = e1.pipe(bufferTime(t, null, 3, testScheduler))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      }
    )
  })
  it("should emit buffers that have been created at intervals and close after the specified delay", () => {
    testScheduler.run(({ hot, time, expectObservable }) => {
      const e1 = hot(
        "       ---a---b---c----d----e----f----g----h----i----(k|)"
      )
      //                     --------------------*--------------------*----  start interval
      //                     ---------------------|                          timespans
      //                                         ---------------------|
      //                                                              -----|
      const t = time(
        "       ---------------------|                            "
      )
      const interval = time(
        "--------------------|                             "
      )
      const expected = "     ---------------------x-------------------y----(z|)"
      const values = {
        x: ["a", "b", "c", "d", "e"],
        y: ["e", "f", "g", "h", "i"],
        z: ["i", "k"],
      }
      const result = e1.pipe(bufferTime(t, interval, Infinity, testScheduler))
      expectObservable(result).toBe(expected, values)
    })
  })
  it("should emit buffers that have been created at intervals and close after the specified delay or when the buffer is full", () => {
    testScheduler.run(({ hot, time, expectObservable }) => {
      const e1 = hot("  ---a---b---c----d----e----f----g----h----i----(k|)")
      //                --------------------*--------------------*----  start interval
      //                ---------------------|                          timespans
      //                                    ---------------------|
      //                                                         -----|
      const t = time("  ---------------------|                            ")
      const interval = time("                --------------------|        ")
      const expected = "----------------x-------------------y---------(z|)"
      const values = {
        x: ["a", "b", "c", "d"],
        y: ["e", "f", "g", "h"],
        z: ["i", "k"],
      }
      const result = e1.pipe(bufferTime(t, interval, 4, testScheduler))
      expectObservable(result).toBe(expected, values)
    })
  })
  it("should emit buffers with timeSpan 10 and creationInterval 7", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--1--^2--3---4---5--6--7---8----9------------|   ")
        //                   -------*------*------*------*------*----- creation interval
        //                   ----------|                               timespans
        //                          ----------|
        //                                 ----------|
        //                                        ----------|
        //                                               ----------|
        //                                                      ----------|
        const e1subs = "     ^---------------------------------------!   "
        const t = time("     ----------|")
        const interval = time("        -------|")
        const expected = "   ----------a------b------c------d------e-(f|)"
        const values = {
          a: ["2", "3", "4"],
          b: ["4", "5", "6"],
          c: ["6", "7", "8"],
          d: ["8", "9"],
          e: [] as string[],
          f: [] as string[],
        }
        const result = e1.pipe(bufferTime(t, interval, Infinity, testScheduler))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should emit buffers but handle source ending with an error", () => {
    testScheduler.run(({ hot, time, expectObservable }) => {
      const e1 = hot("--1--^2--3---4---5--6--7---8----9------------#")
      //                   -------*------*------*------*------*----- creation interval
      //                   ----------|                               timespans
      //                          ----------|
      //                                 ----------|
      //                                        ----------|
      //                                               ----------|
      //                                                      ----------|
      const t = time("     ----------|")
      const interval = time("        -------|")
      const expected = "   ----------a------b------c------d------e-#"
      const values = {
        a: ["2", "3", "4"],
        b: ["4", "5", "6"],
        c: ["6", "7", "8"],
        d: ["8", "9"],
        e: [] as string[],
      }
      const result = e1.pipe(bufferTime(t, interval, Infinity, testScheduler))
      expectObservable(result).toBe(expected, values)
    })
  })
  it("should emit buffers and allow result to unsubscribed early", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--1--^2--3---4---5--6--7---8----9------------|")
        const unsub = "      -----------------!                       "
        const subs = "       ^----------------!                       "
        //                   -------*------*------*------*------*----- creation interval
        //                   ----------|                               timespans
        //                          ----------|
        //                                 ----------|
        const t = time("     ----------|                              ")
        const interval = time("        -------|                       ")
        const expected = "   ----------a------                        "
        const values = {
          a: ["2", "3", "4"],
        }
        const result = e1.pipe(bufferTime(t, interval, Infinity, testScheduler))
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--1--^2--3---4---5--6--7---8----9------------|")
        const subs = "       ^---------------!                        "
        //                   -------*------*------*------*------*----- creation interval
        //                   ----------|                               timespans
        //                          ----------|
        //                                 ----------|
        const t = time("     ----------|")
        const interval = time("        -------|")
        const expected = "   ----------a------                        "
        const unsub = "      ----------------!                        "
        const values = {
          a: ["2", "3", "4"],
        }
        const result = e1.pipe(
          mergeMap((x: any) => of(x)),
          bufferTime(t, interval, Infinity, testScheduler),
          mergeMap((x: any) => of(x))
        )
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      }
    )
  })
  it("should handle empty", () => {
    testScheduler.run(
      ({ cold, time, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" |")
        const e1subs = "  (^!)"
        const expected = "(b|)"
        const values = { b: [] as string[] }
        const t = time("----------|")
        const result = e1.pipe(bufferTime(t, null, Infinity, testScheduler))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should handle never", () => {
    testScheduler.run(({ cold, time, expectObservable }) => {
      const e1 = cold("-")
      const unsub = "   --------------------------------------------!"
      const t = time("  ----------|                                  ")
      const expected = "----------a---------a---------a---------a----"
      const result = e1.pipe(bufferTime(t, null, Infinity, testScheduler))
      expectObservable(result, unsub).toBe(expected, { a: [] })
    })
  })
  it("should handle throw", () => {
    testScheduler.run(({ time, expectObservable }) => {
      const e1 = throwError(() => new Error("haha"))
      const expected = "#"
      const t = time("----------|")
      const result = e1.pipe(bufferTime(t, null, Infinity, testScheduler))
      expectObservable(result).toBe(expected, undefined, new Error("haha"))
    })
  })
  it("should handle errors", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ---a---b---c---#")
        const e1subs = "  ^--------------!"
        const t = time("  ----------|")
        const expected = "----------w----#"
        const values = {
          w: ["a", "b"],
        }
        const result = e1.pipe(bufferTime(t, null, Infinity, testScheduler))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should emit buffers that have been created at intervals and close after the specified delay with errors", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("       ---a---b---c----d----e----f----g----h----i--#")
        //                     --------------------|-------------------|-------------------| interval
        //                     ---------------------|
        //                                         ---------------------|
        //                                                             ---------------------| timespan
        const e1subs = "       ^-------------------------------------------!"
        const t = time("       ---------------------|                       ")
        const interval = time("                --------------------|   ")
        const expected = "     ---------------------x-------------------y--#"
        const values = {
          x: ["a", "b", "c", "d", "e"],
          y: ["e", "f", "g", "h", "i"],
        }
        const result = e1.pipe(bufferTime(t, interval, Infinity, testScheduler))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not throw when subscription synchronously unsubscribed after emit", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ---a---b---c---d---e---f---g-----|")
        const subs = "    ^-------------------!             "
        const t = time("  ----------|                       ")
        const expected = "----------w---------(x|)          "
        const values = {
          w: ["a", "b"],
          x: ["c", "d", "e"],
        }
        const result = e1.pipe(
          bufferTime(t, null, Infinity, testScheduler),
          take(2)
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      }
    )
  })
  it("should not have errors when take follows and maxBufferSize is provided", () => {
    testScheduler.run(({ expectObservable }) => {
      const tick = 1
      const buffTime = 5
      const expected = "-----a----b----c----d----(e|)"
      const values = {
        a: [0, 1, 2, 3],
        b: [4, 5, 6, 7, 8],
        c: [9, 10, 11, 12, 13],
        d: [14, 15, 16, 17, 18],
        e: [19, 20, 21, 22, 23],
      }
      const source = interval(tick, testScheduler).pipe(
        bufferTime(buffTime, null, 10, testScheduler),
        take(5)
      )
      expectObservable(source).toBe(expected, values)
    })
  })
  it("should not mutate the buffer on reentrant next", () => {
    testScheduler.run(({ expectObservable, time }) => {
      const subject = new Subject<number>()
      const t1 = time(" -|")
      const t2 = time(" --|")
      const expected = "--(a|)"
      const result = subject.pipe(
        bufferTime(t2),
        tap(() => subject.next(2)),
        take(1)
      )
      testScheduler.schedule(() => subject.next(1), t1)
      expectObservable(result).toBe(expected, { a: [1] })
    })
  })
})
import { expect } from "chai"
import { of, concat, timer, EMPTY } from "rxjs"
import { bufferToggle, mergeMap, mapTo } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {bufferToggle} */
describe("bufferToggle operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should emit buffers using hot openings and hot closings", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const e1 = hot("  ---a---b---c---d---e---f---g---|")
      const e2 = hot("  --o------------------o---------|")
      const e3 = hot("  ---------c---------------c-----|")
      const expected = "---------x---------------y-----|"
      const values = {
        x: ["a", "b"],
        y: ["f"],
      }
      const result = e1.pipe(bufferToggle(e2, (x: any) => e3))
      expectObservable(result).toBe(expected, values)
    })
  })
  it("should emit buffers that are opened by an observable from the first argument and closed by an observable returned by the function in the second argument", () => {
    testScheduler.run(({ hot, cold, expectObservable }) => {
      const e1 = hot("  -----a----b----c----d----e----f----g----h----i----|")
      const e2 = cold(" -------------x-------------y--------------z-------|")
      const e3 = cold("              ---------------(j|)")
      //                                           ---------------(j|)
      //                                                          ---------------(j|)
      const expected = "----------------------------q-------------r-------(s|)"
      const values = {
        q: ["c", "d", "e"],
        r: ["f", "g", "h"],
        s: ["i"],
      }
      const innerVals = ["x", "y", "z"]
      expectObservable(
        e1.pipe(
          bufferToggle(e2, (x: string) => {
            expect(x).to.equal(innerVals.shift())
            return e3
          })
        )
      ).toBe(expected, values)
    })
  })
  it("should emit buffers using varying cold closings", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|      ")
        const e2 = cold("    --x-----------y--------z---|              ")
        const subs = "       ^----------------------------------!      "
        const closings = [
          cold("               ---------------s--|                     "),
          cold("                           ----(s|)                    "),
          cold("                                    ---------------(s|)"),
        ]
        const closeSubs = [
          "                 --^--------------!                         ",
          "                 --------------^---!                        ",
          "                 -----------------------^-----------!       ",
        ]
        const expected = "  -----------------ij----------------(k|)    "
        const values = {
          i: ["b", "c", "d", "e"],
          j: ["e"],
          k: ["g", "h"],
        }
        let i = 0
        const result = e1.pipe(bufferToggle(e2, () => closings[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1])
        expectSubscriptions(closings[2].subscriptions).toBe(closeSubs[2])
      }
    )
  })
  it("should emit buffers using varying hot closings", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|   ")
        const e2 = cold("    --x-----------y--------z---|           ")
        const subs = "       ^----------------------------------!   "
        const closings = [
          {
            obs: hot("   -1--^----------------s-|                   "),
            sub: "           --^--------------!                     ",
          },
          {
            obs: hot("       -----3----4-------(s|)                 "),
            sub: "           --------------^---!                    ",
          },
          {
            obs: hot("       -------3----4-------5----------------s|"),
            sub: "           -----------------------^-----------!   ",
          },
        ]
        const expected = "   -----------------ij----------------(k|)"
        const values = {
          i: ["b", "c", "d", "e"],
          j: ["e"],
          k: ["g", "h"],
        }
        let i = 0
        const result = e1.pipe(bufferToggle(e2, () => closings[i++].obs))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        for (let j = 0; j < closings.length; j++) {
          expectSubscriptions(closings[j].obs.subscriptions).toBe(
            closings[j].sub
          )
        }
      }
    )
  })
  it("should emit buffers using varying empty delayed closings", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|     ")
        const e2 = cold("    --x-----------y--------z---|             ")
        const subs = "       ^----------------------------------!     "
        const closings = [
          cold("               ---------------|                       "),
          cold("                           ----|                      "),
          cold("                                    ---------------|  "),
        ]
        const expected = "   -----------------------------------(ijk|)"
        const values = {
          i: ["b", "c", "d", "e", "f", "g", "h"],
          j: ["e", "f", "g", "h"],
          k: ["g", "h"],
        }
        let i = 0
        const result = e1.pipe(bufferToggle(e2, () => closings[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      }
    )
  })
  it("should emit buffers using varying cold closings, outer unsubscribed early", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|      ")
        const subs = "       ^---------!                               "
        const e2 = cold("    --x-----------y--------z---|              ")
        const closings = [
          cold("               ---------------s--|                     "),
          cold("                           ----(s|)                    "),
          cold("                                    ---------------(s|)"),
        ]
        const csub0 = "      --^-------!                               "
        const expected = "   -----------                               "
        const unsub = "      ----------!                               "
        const values = {
          i: ["b", "c", "d", "e"],
        }
        let i = 0
        const result = e1.pipe(bufferToggle(e2, () => closings[i++]))
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(closings[0].subscriptions).toBe(csub0)
        expectSubscriptions(closings[1].subscriptions).toBe([])
        expectSubscriptions(closings[2].subscriptions).toBe([])
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|      ")
        const subs = "       ^-----------------!                       "
        const e2 = cold("    --x-----------y--------z---|              ")
        const closings = [
          cold("               ---------------s--|                     "),
          cold("                           ----(s|)                    "),
          cold("                                    ---------------(s|)"),
        ]
        const expected = "   -----------------i-                       "
        const unsub = "      ------------------!                       "
        const values = {
          i: ["b", "c", "d", "e"],
        }
        let i = 0
        const result = e1.pipe(
          mergeMap((x: any) => of(x)),
          bufferToggle(e2, () => closings[i++]),
          mergeMap((x: any) => of(x))
        )
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      }
    )
  })
  it("should propagate error thrown from closingSelector", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|      ")
        const e2 = cold("    --x-----------y--------z---|              ")
        const subs = "       ^-------------!                           "
        const closings = [
          cold("               ---------------s--|                     "),
          cold("                           ----(s|)                    "),
          cold("                                    ---------------(s|)"),
        ]
        const closeSubs0 = " --^-----------!                           "
        const expected = "   --------------#                           "
        let i = 0
        const result = e1.pipe(
          bufferToggle(e2, () => {
            if (i === 1) {
              throw "error"
            }
            return closings[i++]
          })
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs0)
        expectSubscriptions(closings[1].subscriptions).toBe([])
        expectSubscriptions(closings[2].subscriptions).toBe([])
      }
    )
  })
  it("should propagate error emitted from a closing", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|")
        const e2 = cold("    --x-----------y--------z---|        ")
        const subs = "       ^-------------!                     "
        const closings = [
          cold("               ---------------s--|               "),
          cold("                           #                     "),
        ]
        const closeSubs = [
          "                  --^-----------!                     ",
          "                  --------------(^!)                  ",
        ]
        const expected = "   --------------#                     "
        let i = 0
        const result = e1.pipe(bufferToggle(e2, () => closings[i++]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1])
      }
    )
  })
  it("should propagate error emitted late from a closing", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|")
        const e2 = cold("    --x-----------y--------z---|        ")
        const subs = "       ^------------------!                "
        const closings = [
          cold("               ---------------s--|               "),
          cold("                           -----#                "),
        ]
        const closeSubs = [
          "                  --^--------------!                  ",
          "                  --------------^----!                ",
        ]
        const expected = "   -----------------i-#                "
        const values = {
          i: ["b", "c", "d", "e"],
        }
        let i = 0
        const result = e1.pipe(bufferToggle(e2, () => closings[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1])
      }
    )
  })
  it("should handle errors", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e--#        ")
        const e2 = cold("    --x-----------y--------z---|")
        const subs = "       ^------------------!        "
        // prettier-ignore
        const closings = [
        cold('               ---------------s--|       '),
        cold('                           -------s|     '),
      ];
        // prettier-ignore
        const closeSubs = [
        '                  --^--------------!          ',
        '                  --------------^----!        ',
      ];
        const expected = "   -----------------i-#        "
        const values = {
          i: ["b", "c", "d", "e"],
        }
        let i = 0
        const result = e1.pipe(bufferToggle(e2, () => closings[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1])
      }
    )
  })
  it("should handle empty source", () => {
    testScheduler.run(({ cold, expectObservable }) => {
      const e1 = cold(" |")
      const e2 = cold(" --o-----|")
      const e3 = cold("   -----c--|")
      const expected = "|"
      const values = { x: [] as string[] }
      const result = e1.pipe(bufferToggle(e2, () => e3))
      expectObservable(result).toBe(expected, values)
    })
  })
  it("should handle throw", () => {
    testScheduler.run(({ cold, expectObservable }) => {
      const e1 = cold(" #")
      const e2 = cold(" --o-----|")
      const e3 = cold("   -----c--|")
      const expected = "#"
      const values = { x: [] as string[] }
      const result = e1.pipe(bufferToggle(e2, () => e3))
      expectObservable(result).toBe(expected, values)
    })
  })
  it("should handle never", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -")
        const e2 = cold(" --o-----o------o-----o---o-----|")
        const e3 = cold("   --c-|")
        //                        --c-|
        //                               --c-|
        //                                     --c-|
        //                                         --c-|
        const unsub = "   --------------------------------------------!"
        const subs = "    ^-------------------------------------------!"
        const expected = "----x-----x------x-----x---x-----------------"
        const values = { x: [] as string[] }
        const result = e1.pipe(bufferToggle(e2, () => e3))
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      }
    )
  })
  it("should handle a never opening Observable", () => {
    testScheduler.run(({ hot, cold, expectObservable }) => {
      const e1 = hot("--a--^---b---c---d---e---f---g---h------|")
      const e2 = cold("    -")
      const e3 = cold("    --c-|")
      const expected = "   -----------------------------------|"
      const result = e1.pipe(bufferToggle(e2, () => e3))
      expectObservable(result).toBe(expected)
    })
  })
  it("should handle a never closing Observable", () => {
    testScheduler.run(({ hot, cold, expectObservable }) => {
      const e1 = hot("--a--^---b---c---d---e---f---g---h------|    ")
      const e2 = cold("    ---o---------------o-----------|        ")
      const e3 = cold("    -")
      const expected = "   -----------------------------------(xy|)"
      const values = {
        x: ["b", "c", "d", "e", "f", "g", "h"],
        y: ["f", "g", "h"],
      }
      const result = e1.pipe(bufferToggle(e2, () => e3))
      expectObservable(result).toBe(expected, values)
    })
  })
  it("should handle opening Observable that just throws", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|")
        const e1subs = "     (^!)"
        const e2 = cold("    #")
        const e2subs = "     (^!)"
        const e3 = cold("    --c-|")
        const expected = "   #"
        const result = e1.pipe(bufferToggle(e2, () => e3))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should accept openings resolved promise", done => {
    const e1 = concat(
      timer(10).pipe(mapTo(1)),
      timer(100).pipe(mapTo(2)),
      timer(150).pipe(mapTo(3)),
      timer(200).pipe(mapTo(4))
    )
    const expected = [[1]]
    e1.pipe(
      bufferToggle(
        new Promise((resolve: any) => {
          resolve(42)
        }),
        () => {
          return timer(50)
        }
      )
    ).subscribe({
      next: x => {
        expect(x).to.deep.equal(expected.shift())
      },
      error: x => {
        done(new Error("should not be called"))
      },
      complete: () => {
        expect(expected.length).to.be.equal(0)
        done()
      },
    })
  })
  it("should accept openings rejected promise", done => {
    const e1 = concat(
      of(1),
      timer(10).pipe(mapTo(2)),
      timer(10).pipe(mapTo(3)),
      timer(100).pipe(mapTo(4))
    )
    const expected = 42
    e1.pipe(
      bufferToggle(
        new Promise((resolve: any, reject: any) => {
          reject(expected)
        }),
        () => {
          return timer(50)
        }
      )
    ).subscribe({
      next: x => {
        done(new Error("should not be called"))
      },
      error: x => {
        expect(x).to.equal(expected)
        done()
      },
      complete: () => {
        done(new Error("should not be called"))
      },
    })
  })
  it("should accept closing selector that returns a resolved promise", done => {
    const e1 = concat(
      of(1),
      timer(10).pipe(mapTo(2)),
      timer(10).pipe(mapTo(3)),
      timer(100).pipe(mapTo(4))
    )
    const expected = [[1]]
    e1.pipe(
      bufferToggle(
        of(10),
        () =>
          new Promise((resolve: any) => {
            resolve(42)
          })
      )
    ).subscribe({
      next: x => {
        expect(x).to.deep.equal(expected.shift())
      },
      error: () => {
        done(new Error("should not be called"))
      },
      complete: () => {
        expect(expected.length).to.be.equal(0)
        done()
      },
    })
  })
  it("should accept closing selector that returns a rejected promise", done => {
    const e1 = concat(
      of(1),
      timer(10).pipe(mapTo(2)),
      timer(10).pipe(mapTo(3)),
      timer(100).pipe(mapTo(4))
    )
    const expected = 42
    e1.pipe(
      bufferToggle(
        of(10),
        () =>
          new Promise((resolve: any, reject: any) => {
            reject(expected)
          })
      )
    ).subscribe({
      next: x => {
        done(new Error("should not be called"))
      },
      error: x => {
        expect(x).to.equal(expected)
        done()
      },
      complete: () => {
        done(new Error("should not be called"))
      },
    })
  })
  it("should handle empty closing observable", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|     ")
        const subs = "       ^----------------------------------!     "
        const e2 = cold("    --x-----------y--------z---|             ")
        const expected = "   -----------------------------------(ijk|)"
        const values = {
          i: ["b", "c", "d", "e", "f", "g", "h"],
          j: ["e", "f", "g", "h"],
          k: ["g", "h"],
        }
        const result = e1.pipe(bufferToggle(e2, () => EMPTY))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      }
    )
  })
})
import { expect } from "chai"
import { of } from "rxjs"
import { bufferWhen, mergeMap, takeWhile } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {bufferWhen} */
describe("bufferWhen operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should emit buffers that close and reopen", () => {
    testScheduler.run(({ hot, cold, expectObservable }) => {
      const e1 = hot("--a--^---b---c---d---e---f---g---------|   ")
      const e2 = cold("    --------------(s|)                    ")
      //                                 --------------(s|)
      const expected = "   --------------x-------------y-----(z|)"
      const values = {
        x: ["b", "c", "d"],
        y: ["e", "f", "g"],
        z: [] as string[],
      }
      expectObservable(e1.pipe(bufferWhen(() => e2))).toBe(expected, values)
    })
  })
  it("should emit buffers using varying cold closings", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|      ")
        const subs = "       ^----------------------------------!      "
        const closings = [
          cold("             ---------------s--|                       "),
          cold("                            ----------(s|)             "),
          cold("                                      -------------(s|)"),
        ]
        const expected = "   ---------------x---------y---------(z|)   "
        const values = {
          x: ["b", "c", "d"],
          y: ["e", "f", "g"],
          z: ["h"],
        }
        let i = 0
        const result = e1.pipe(bufferWhen(() => closings[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      }
    )
  })
  it("should emit buffers using varying hot closings", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^---b---c---d---e---f---g---h------|   ")
      const subs = "       ^----------------------------------!   "
      const closings = [
        {
          obs: hot("   -1--^--------------s---|                   "),
          sub: "           ^--------------!                       ",
        },
        {
          obs: hot("   --1-^----3--------4----------s-|           "),
          sub: "           ---------------^---------!             ",
        },
        {
          obs: hot("   1-2-^------3----4-------5--6-----------s--|"),
          sub: "           -------------------------^---------!   ",
        },
      ]
      const expected = "   ---------------x---------y---------(z|)"
      const values = {
        x: ["b", "c", "d"],
        y: ["e", "f", "g"],
        z: ["h"],
      }
      let i = 0
      const result = e1.pipe(bufferWhen(() => closings[i++].obs))
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(subs)
      for (let j = 0; j < closings.length; j++) {
        expectSubscriptions(closings[j].obs.subscriptions).toBe(closings[j].sub)
      }
    })
  })
  it("should not emit buffers using varying empty delayed closings", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|   ")
        const subs = "       ^----------------------------------!   "
        const closings = [
          cold("             ---------------|                       "),
          cold("                            ----------|             "),
          cold("                                      -------------|"),
        ]
        const closeSubs = [
          "                  ^--------------!                       ",
          "                                                         ",
          "                                                         ",
        ]
        const expected = "   -----------------------------------(x|)"
        const values = {
          x: ["b", "c", "d", "e", "f", "g", "h"],
        }
        let i = 0
        const result = e1.pipe(bufferWhen(() => closings[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1])
        expectSubscriptions(closings[2].subscriptions).toBe(closeSubs[2])
      }
    )
  })
  it("should emit buffers using varying cold closings, outer unsubscribed early", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|      ")
        const unsub = "      ------------------!                       "
        const subs = "       ^-----------------!                       "
        const closings = [
          cold("             ---------------(s|)                       "),
          cold("                            ----------(s|)             "),
          cold("                                      -------------(s|)"),
        ]
        const closeSubs = [
          "                  ^--------------!                          ",
          "                  ---------------^--!                       ",
        ]
        const expected = "   ---------------x---                       "
        const values = {
          x: ["b", "c", "d"],
        }
        let i = 0
        const result = e1.pipe(bufferWhen(() => closings[i++]))
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1])
        expectSubscriptions(closings[2].subscriptions).toBe([])
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|      ")
        const subs = "       ^-----------------!                       "
        const closings = [
          cold("             ---------------(s|)                       "),
          cold("                            ----------(s|)             "),
          cold("                                      -------------(s|)"),
        ]
        const closeSubs = [
          "                  ^--------------!                          ",
          "                  ---------------^--!                       ",
        ]
        const expected = "   ---------------x---                       "
        const unsub = "      ------------------!                       "
        const values = {
          x: ["b", "c", "d"],
        }
        let i = 0
        const result = e1.pipe(
          mergeMap((x: any) => of(x)),
          bufferWhen(() => closings[i++]),
          mergeMap((x: any) => of(x))
        )
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1])
        expectSubscriptions(closings[2].subscriptions).toBe([])
      }
    )
  })
  it("should propagate error thrown from closingSelector", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|      ")
        const subs = "       ^--------------!                          "
        const closings = [
          cold("             ---------------s--|                       "),
          cold("                            ----------(s|)             "),
          cold("                                      -------------(s|)"),
        ]
        const closeSubs0 = " ^--------------!                          "
        const expected = "   ---------------(x#)                       "
        const values = { x: ["b", "c", "d"] }
        let i = 0
        const result = e1.pipe(
          bufferWhen(() => {
            if (i === 1) {
              throw "error"
            }
            return closings[i++]
          })
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs0)
      }
    )
  })
  it("should propagate error emitted from a closing", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|")
        const subs = "       ^--------------!                    "
        const closings = [
          cold("             ---------------s--|                 "),
          cold("                            #                    "),
        ]
        const closeSubs = [
          "                  ^--------------!                    ",
          "                  ---------------(^!)                 ",
        ]
        const expected = "   ---------------(x#)                 "
        const values = {
          x: ["b", "c", "d"],
        }
        let i = 0
        const result = e1.pipe(bufferWhen(() => closings[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1])
      }
    )
  })
  it("should propagate error emitted late from a closing", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|")
        const subs = "       ^--------------------!              "
        const closings = [
          cold("             ---------------s--|                 "),
          cold("                            ------#              "),
        ]
        const closeSubs = [
          "                  ^--------------!                    ",
          "                  ---------------^-----!              ",
        ]
        const expected = "   ---------------x-----#              "
        const values = { x: ["b", "c", "d"] }
        let i = 0
        const result = e1.pipe(bufferWhen(() => closings[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1])
      }
    )
  })
  it("should handle errors", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---#")
        const e2 = cold("    ---------------(s|)      ")
        //                                ---------------(s|)
        // prettier-ignore
        const e2subs = [
        '                  ^--------------!         ',
        '                  ---------------^--------!',
      ];
        const expected = "   ---------------x--------#"
        const values = {
          x: ["b", "c", "d"],
        }
        const result = e1.pipe(bufferWhen(() => e2))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should handle empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |")
      const e2 = cold(" --------(s|)")
      const e1subs = "  (^!)"
      const expected = "(x|)"
      const values = {
        x: [] as string[],
      }
      const result = e1.pipe(bufferWhen(() => e2))
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle throw", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #")
      const e2 = cold(" --------(s|)")
      const e1subs = "  (^!)"
      const expected = "#"
      const values = {
        x: [] as string[],
      }
      const result = e1.pipe(bufferWhen(() => e2))
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle never", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -")
        const unsub = "   --------------------------------------------!"
        const e1subs = "  ^-------------------------------------------!"
        const e2 = cold(" --------(s|)                                 ")
        const e2subs = [
          "               ^-------!                                    ",
          "               --------^-------!                            ",
          "               ----------------^-------!                    ",
          "               ------------------------^-------!            ",
          "               --------------------------------^-------!    ",
          "               ----------------------------------------^---!",
        ]
        const expected = "--------x-------x-------x-------x-------x----"
        const values = {
          x: [] as string[],
        }
        const source = e1.pipe(bufferWhen(() => e2))
        expectObservable(source, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should handle an inner never", () => {
    testScheduler.run(({ hot, cold, expectObservable }) => {
      const e1 = hot("--a--^---b---c---d---e---f---g---h------|")
      const e2 = cold("-")
      const expected = "   -----------------------------------(x|)"
      const values = {
        x: ["b", "c", "d", "e", "f", "g", "h"],
      }
      expectObservable(e1.pipe(bufferWhen(() => e2))).toBe(expected, values)
    })
  })
  // bufferWhen is not supposed to handle a factory that returns always sync
  // closing Observables, because doing such would constantly recreate a new
  // buffer in a synchronous infinite loop until the stack overflows. This also
  // happens with buffer in RxJS 4.
  it("should NOT handle synchronous inner", done => {
    const source = of(1, 2, 3, 4, 5, 6, 7, 8, 9)
    const closing = of(1)
    const TOO_MANY_INVOCATIONS = 30
    source
      .pipe(
        bufferWhen(() => closing),
        takeWhile((val: any, index: number) => index < TOO_MANY_INVOCATIONS)
      )
      .subscribe({
        next: (val: any) => {
          expect(Array.isArray(val)).to.be.true
          expect(val.length).to.equal(0)
        },
        error: (err: any) => {
          done(new Error("should not be called"))
        },
        complete: () => {
          done()
        },
      })
  })
  it("should handle inner throw", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|")
        const e1subs = "     (^!)"
        const e2 = cold("    #")
        const e2subs = "     (^!)"
        const expected = "   #"
        const values = {
          x: ["b", "c", "d", "e", "f", "g", "h"],
        }
        const result = e1.pipe(bufferWhen(() => e2))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should handle disposing of source", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|")
        const subs = "       ^-------------------!"
        const unsub = "      --------------------!"
        const e2 = cold("    ---------------(s|)")
        //                                  ---------------(s|)
        const expected = "   ---------------x-----"
        const values = {
          x: ["b", "c", "d"],
          y: ["e", "f", "g", "h"],
          z: [] as string[],
        }
        const source = e1.pipe(bufferWhen(() => e2))
        expectObservable(source, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      }
    )
  })
})
import { expect } from "chai"
import { concat, defer, Observable, of, throwError, EMPTY, from } from "rxjs"
import {
  catchError,
  map,
  mergeMap,
  takeWhile,
  delay,
  take,
} from "rxjs/operators"
import * as sinon from "sinon"
import { createObservableInputs } from "../helpers/test-helper"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
import { asInteropObservable } from "../helpers/interop-helper"
/** @test {catch} */
describe("catchError operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should catch error and replace with a cold Observable", () => {
    testScheduler.run(({ hot, cold, expectObservable }) => {
      const e1 = hot("  --a--b--#       ")
      const e2 = cold("         -1-2-3-|")
      const expected = "--a--b---1-2-3-|"
      const result = e1.pipe(catchError((err: any) => e2))
      expectObservable(result).toBe(expected)
    })
  })
  it("should catch error and replace it with Observable.of()", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--------|")
      const subs = "    ^-------!"
      const expected = "--a--b--(XYZ|)"
      const result = e1.pipe(
        map((n: string) => {
          if (n === "c") {
            throw "bad"
          }
          return n
        }),
        catchError((err: any) => {
          return of("X", "Y", "Z")
        })
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should catch error and replace it with a cold Observable", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--b--#          ")
        const e1subs = "  ^-------!          "
        const e2 = cold("         1-2-3-4-5-|")
        const e2subs = "  --------^---------!"
        const expected = "--a--b--1-2-3-4-5-|"
        const result = e1.pipe(catchError((err: any) => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --1-2-3-4-5-6---#")
      const e1subs = "  ^------!         "
      const expected = "--1-2-3-         "
      const unsub = "   -------!         "
      const result = e1.pipe(
        catchError(() => {
          return of("X", "Y", "Z")
        })
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chain when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --1-2-3-4-5-6---#")
      const e1subs = "  ^------!         "
      const expected = "--1-2-3-         "
      const unsub = "   -------!         "
      const result = e1.pipe(
        mergeMap((x: any) => of(x)),
        catchError(() => {
          return of("X", "Y", "Z")
        }),
        mergeMap((x: any) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should unsubscribe from a caught hot caught observable when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -1-2-3-#          ")
      const e1subs = "  ^------!          "
      const e2 = hot("  ---3-4-5-6-7-8-9-|")
      const e2subs = "  -------^----!     "
      const expected = "-1-2-3-5-6-7-     "
      const unsub = "   ------------!     "
      const result = e1.pipe(catchError(() => e2))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should unsubscribe from a caught cold caught observable when unsubscribed explicitly", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -1-2-3-#          ")
        const e1subs = "  ^------!          "
        const e2 = cold("        5-6-7-8-9-|")
        const e2subs = "  -------^----!     "
        const expected = "-1-2-3-5-6-7-     "
        const unsub = "   ------------!     "
        const result = e1.pipe(catchError(() => e2))
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should unsubscribe from a caught cold caught interop observable when unsubscribed explicitly", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -1-2-3-#          ")
        const e1subs = "  ^------!          "
        const e2 = cold("        5-6-7-8-9-|")
        const e2subs = "  -------^----!     "
        const expected = "-1-2-3-5-6-7-     "
        const unsub = "   ------------!     "
        // This test is the same as the previous test, but the observable is
        // manipulated to make it look like an interop observable - an observable
        // from a foreign library. Interop subscribers are treated differently:
        // they are wrapped in a safe subscriber. This test ensures that
        // unsubscriptions are chained all the way to the interop subscriber.
        const result = e1.pipe(catchError(() => asInteropObservable(e2)))
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = concat(
      defer(() => {
        sideEffects.push(1)
        return of(1)
      }),
      defer(() => {
        sideEffects.push(2)
        return of(2)
      }),
      defer(() => {
        sideEffects.push(3)
        return of(3)
      })
    )
    throwError(() => new Error("Some error"))
      .pipe(
        catchError(() => synchronousObservable),
        takeWhile(x => x != 2) // unsubscribe at the second side-effect
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([1, 2])
  })
  it("should catch error and replace it with a hot Observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--#          ")
      const e1subs = "  ^-------!          "
      const e2 = hot("  1-2-3-4-5-6-7-8-9-|")
      const e2subs = "  --------^---------!"
      const expected = "--a--b--5-6-7-8-9-|"
      const result = e1.pipe(catchError((err: any) => e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should catch and allow the cold observable to be repeated with the third (caught) argument", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("--a--b--c--------|       ")
      const subs = [
        "               ^-------!                ",
        "              --------^-------!         ",
        "              ----------------^-------! ",
      ]
      const expected = "--a--b----a--b----a--b--#"
      let retries = 0
      const result = e1.pipe(
        map((n: any) => {
          if (n === "c") {
            throw "bad"
          }
          return n
        }),
        catchError((err: any, caught: any) => {
          if (retries++ === 2) {
            throw "done"
          }
          return caught
        })
      )
      expectObservable(result).toBe(expected, undefined, "done")
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should catch and allow the hot observable to proceed with the third (caught) argument", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c----d---|")
      // prettier-ignore
      const subs = [
        '               ^-------!         ',
        '              --------^--------! ',
      ];
      const expected = "--a--b-------d---|"
      let retries = 0
      const result = e1.pipe(
        map((n: any) => {
          if (n === "c") {
            throw "bad"
          }
          return n
        }),
        catchError((err: any, caught: any) => {
          if (retries++ === 2) {
            throw "done"
          }
          return caught
        })
      )
      expectObservable(result).toBe(expected, undefined, "done")
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should catch and replace a Observable.throw() as the source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #")
      const subs = "    (^!)"
      const expected = "(abc|)"
      const result = e1.pipe(catchError((err: any) => of("a", "b", "c")))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should mirror the source if it does not raise errors", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a--b--c--|")
      const subs = "    ^----------!"
      const expected = "--a--b--c--|"
      const result = e1.pipe(catchError((err: any) => of("x", "y", "z")))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should complete if you return Observable.empty()", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--b--#")
        const e1subs = "  ^-------!"
        const e2 = cold("         |")
        const e2subs = "  --------(^!)"
        const expected = "--a--b--|"
        const result = e1.pipe(catchError(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should raise error if you return Observable.throw()", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--b--#")
        const e1subs = "  ^-------!"
        const e2 = cold("         #")
        const e2subs = "  --------(^!)"
        const expected = "--a--b--#"
        const result = e1.pipe(catchError(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should never terminate if you return NEVER", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--b--#")
        const e1subs = "  ^-------!"
        const e2 = cold("         -")
        const e2subs = "  --------^"
        const expected = "--a--b---"
        const result = e1.pipe(catchError(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should pass the error as the first argument", done => {
    throwError(() => "bad")
      .pipe(
        catchError((err: any) => {
          expect(err).to.equal("bad")
          return EMPTY
        })
      )
      .subscribe({
        next: () => {
          //noop
        },
        error: (err: any) => {
          done(new Error("should not be called"))
        },
        complete: () => {
          done()
        },
      })
  })
  it("should accept selector returns any ObservableInput", done => {
    const input$ = createObservableInputs(42)
    input$
      .pipe(
        mergeMap(input =>
          throwError(() => "bad").pipe(catchError(err => input))
        )
      )
      .subscribe({
        next: x => {
          expect(x).to.be.equal(42)
        },
        error: (err: any) => {
          done(new Error("should not be called"))
        },
        complete: () => {
          done()
        },
      })
  })
  it("should catch errors throw from within the constructor", () => {
    // See https://github.com/ReactiveX/rxjs/issues/3740
    testScheduler.run(({ expectObservable }) => {
      const source = concat(
        new Observable<string>(o => {
          o.next("a")
          throw "kaboom"
        }).pipe(catchError(_ => of("b"))),
        of("c")
      )
      const expected = "(abc|)"
      expectObservable(source).toBe(expected)
    })
  })
  context("fromPromise", () => {
    type SetTimeout = (
      callback: (...args: any[]) => void,
      ms: number,
      ...args: any[]
    ) => NodeJS.Timer
    let trueSetTimeout: SetTimeout
    let sandbox: sinon.SinonSandbox
    let timers: sinon.SinonFakeTimers
    beforeEach(() => {
      trueSetTimeout = global.setTimeout
      sandbox = sinon.createSandbox()
      timers = sandbox.useFakeTimers()
    })
    afterEach(() => {
      sandbox.restore()
    })
    it("should chain a throw from a promise using Observable.throw", done => {
      const subscribeSpy = sinon.spy()
      const errorSpy = sinon.spy()
      const thrownError = new Error("BROKEN THROW")
      const testError = new Error("BROKEN PROMISE")
      from(Promise.reject(testError))
        .pipe(catchError(err => throwError(() => thrownError)))
        .subscribe({ next: subscribeSpy, error: errorSpy })
      trueSetTimeout(() => {
        try {
          timers.tick(1)
        } catch (e) {
          return done(new Error("This should not have thrown an error"))
        }
        expect(subscribeSpy).not.to.be.called
        expect(errorSpy).to.have.been.called
        expect(errorSpy).to.have.been.calledWith(thrownError)
        done()
      }, 0)
    })
  })
  // TODO(v8): see https://github.com/ReactiveX/rxjs/issues/5115
  // The re-implementation in version 8 should fix the problem in the
  // referenced issue. Closed subscribers should remain closed.
  it("Properly handle async handled result if source is synchronous", done => {
    const source = new Observable<string>(observer => {
      observer.error(new Error("kaboom!"))
      observer.complete()
    })
    const sourceWithDelay = new Observable<string>(observer => {
      observer.next("delayed")
      observer.complete()
    }).pipe(delay(0))
    const values: string[] = []
    source.pipe(catchError(err => sourceWithDelay)).subscribe({
      next: value => values.push(value),
      error: err => done(err),
      complete: () => {
        expect(values).to.deep.equal(["delayed"])
        done()
      },
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        catchError(() => EMPTY),
        take(3)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { of } from "rxjs"
import { combineLatest, mergeMap, distinct, count } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {combineLatest} */
describe("combineLatest", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should combine events from two cold observables", () => {
    testScheduler.run(({ cold, expectObservable }) => {
      const e1 = cold(" -a--b-----c-d-e-|")
      const e2 = cold(" --1--2-3-4---|   ")
      const expected = "--A-BC-D-EF-G-H-|"
      const result = e1.pipe(combineLatest(e2, (a, b) => String(a) + String(b)))
      expectObservable(result).toBe(expected, {
        A: "a1",
        B: "b1",
        C: "b2",
        D: "b3",
        E: "b4",
        F: "c4",
        G: "d4",
        H: "e4",
      })
    })
  })
  it("should work with two nevers", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const e2 = cold(" -")
      const e2subs = "  ^"
      const expected = "-"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with never and empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const e2 = cold(" |")
      const e2subs = "  (^!)"
      const expected = "-"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with empty and never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |")
      const e1subs = "  (^!)"
      const e2 = cold(" -")
      const e2subs = "  ^"
      const expected = "-"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with empty and empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |")
      const e1subs = "  (^!)"
      const e2 = cold(" |")
      const e2subs = "  (^!)"
      const expected = "|"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with hot-empty and hot-single", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: 1,
        b: 2,
        c: 3,
        r: 1 + 3, //a + c
      }
      const e1 = hot("-a-^-|", values)
      const e1subs = "   ^-!"
      const e2 = hot("-b-^-c-|", values)
      const e2subs = "   ^---!"
      const expected = " ----|"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with hot-single and hot-empty", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: 1,
        b: 2,
        c: 3,
      }
      const e1 = hot("-a-^-|", values)
      const e1subs = "   ^-!"
      const e2 = hot("-b-^-c-|", values)
      const e2subs = "   ^---!"
      const expected = " ----|"
      const result = e2.pipe(combineLatest(e1, (x, y) => x + y))
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with hot-single and never", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: 1,
      }
      const e1 = hot("-a-^-|", values)
      const e1subs = "   ^-!"
      const e2 = hot("------", values) //never
      const e2subs = "   ^--"
      const expected = " ---" //never
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with never and hot-single", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: 1,
        b: 2,
      }
      const e1 = hot("--------", values) //never
      const e1subs = "   ^    "
      const e2 = hot("-a-^-b-|", values)
      const e2subs = "   ^---!"
      const expected = " -----" //never
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with hot and hot", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--|", { a: "a", b: "b", c: "c" })
      const e1subs = "     ^--------!"
      const e2 = hot("---e-^---f--g--|", { e: "e", f: "f", g: "g" })
      const e2subs = "     ^---------!"
      const expected = "   ----x-yz--|"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected, { x: "bf", y: "cf", z: "cg" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should accept array of observables", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--|")
      const e1subs = "     ^--------!"
      const e2 = hot("---e-^---f--g--|")
      const e2subs = "     ^---------!"
      const e3 = hot("---h-^----i--j-|")
      const e3subs = "     ^---------!"
      const expected = "   -----wxyz-|"
      const result = e1.pipe(
        combineLatest([e2, e3], (x: string, y: string, z: string) => x + y + z)
      )
      expectObservable(result).toBe(expected, {
        w: "bfi",
        x: "cfi",
        y: "cgi",
        z: "cgj",
      })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
      expectSubscriptions(e3.subscriptions).toBe(e3subs)
    })
  })
  it("should work with empty and error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----------|") //empty
      const e1subs = "  ^-----!"
      const e2 = hot("  ------#", undefined, "shazbot!") //error
      const e2subs = "  ^-----!"
      const expected = "------#"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected, null, "shazbot!")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with error and empty", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--^---#", undefined, "too bad, honk") //error
      const e1subs = "  ^---!"
      const e2 = hot("--^--------|") //empty
      const e2subs = "  ^---!"
      const expected = "----#"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected, null, "too bad, honk")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with hot and throw", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-a-^--b--c--|", { a: 1, b: 2, c: 3 })
      const e1subs = "   ^-!"
      const e2 = hot("---^-#", undefined, "bazinga")
      const e2subs = "   ^-!"
      const expected = " --#"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected, null, "bazinga")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with throw and hot", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^-#", undefined, "bazinga")
      const e1subs = "   ^-!"
      const e2 = hot("-a-^--b--c--|", { a: 1, b: 2, c: 3 })
      const e2subs = "   ^-!"
      const expected = " --#"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected, null, "bazinga")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with throw and throw", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^----#", undefined, "jenga")
      const e1subs = "   ^-!"
      const e2 = hot("---^-#", undefined, "bazinga")
      const e2subs = "   ^-!"
      const expected = " --#"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected, null, "bazinga")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with error and throw", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-a-^--b--#", { a: 1, b: 2 }, "wokka wokka")
      const e1subs = "   ^-!"
      const e2 = hot("---^-#", undefined, "flurp")
      const e2subs = "   ^-!"
      const expected = " --#"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected, null, "flurp")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with throw and error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^-#", undefined, "flurp")
      const e1subs = "   ^-!"
      const e2 = hot("-a-^--b--#", { a: 1, b: 2 }, "wokka wokka")
      const e2subs = "   ^-!"
      const expected = " --#"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected, null, "flurp")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with never and throw", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^-----------")
      const e1subs = "   ^-----!"
      const e2 = hot("---^-----#", undefined, "wokka wokka")
      const e2subs = "   ^-----!"
      const expected = " ------#"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected, null, "wokka wokka")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with throw and never", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^----#", undefined, "wokka wokka")
      const e1subs = "   ^----!"
      const e2 = hot("---^-----------")
      const e2subs = "   ^----!"
      const expected = " -----#"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected, null, "wokka wokka")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with some and throw", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("   ---^----a---b--|", { a: 1, b: 2 })
      const e1subs = "      ^--!"
      const e2 = hot("   ---^--#", undefined, "wokka wokka")
      const e2subs = "      ^--!"
      const expected = "    ---#"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected, { a: 1, b: 2 }, "wokka wokka")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with throw and some", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^--#", undefined, "wokka wokka")
      const e1subs = "   ^--!"
      const e2 = hot("---^----a---b--|", { a: 1, b: 2 })
      const e2subs = "   ^--!"
      const expected = " ---#"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected, { a: 1, b: 2 }, "wokka wokka")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should handle throw after complete left", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const left = hot(" --a--^--b---|", { a: 1, b: 2 })
      const leftSubs = "      ^------!"
      const right = hot("-----^--------#", undefined, "bad things")
      const rightSubs = "     ^--------!"
      const expected = "      ---------#"
      const result = left.pipe(combineLatest(right, (x, y) => x + y))
      expectObservable(result).toBe(expected, null, "bad things")
      expectSubscriptions(left.subscriptions).toBe(leftSubs)
      expectSubscriptions(right.subscriptions).toBe(rightSubs)
    })
  })
  it("should handle throw after complete right", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const left = hot("  -----^--------#", undefined, "bad things")
      const leftSubs = "       ^--------!"
      const right = hot(" --a--^--b---|", { a: 1, b: 2 })
      const rightSubs = "      ^------!"
      const expected = "       ---------#"
      const result = left.pipe(combineLatest(right, (x, y) => x + y))
      expectObservable(result).toBe(expected, null, "bad things")
      expectSubscriptions(left.subscriptions).toBe(leftSubs)
      expectSubscriptions(right.subscriptions).toBe(rightSubs)
    })
  })
  it("should handle interleaved with tail", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-a--^--b---c---|", { a: "a", b: "b", c: "c" })
      const e1subs = "    ^----------!"
      const e2 = hot("--d-^----e---f--|", { d: "d", e: "e", f: "f" })
      const e2subs = "    ^-----------!"
      const expected = "  -----x-y-z--|"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected, { x: "be", y: "ce", z: "cf" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should handle two consecutive hot observables", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--|", { a: "a", b: "b", c: "c" })
      const e1subs = "     ^--------!"
      const e2 = hot("-----^----------d--e--f--|", { d: "d", e: "e", f: "f" })
      const e2subs = "     ^-------------------!"
      const expected = "   -----------x--y--z--|"
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result).toBe(expected, { x: "cd", y: "ce", z: "cf" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should handle two consecutive hot observables with error left", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const left = hot(" --a--^--b--c--#", { a: "a", b: "b", c: "c" }, "jenga")
      const leftSubs = "      ^--------!"
      const right = hot("-----^----------d--e--f--|", {
        d: "d",
        e: "e",
        f: "f",
      })
      const rightSubs = "     ^--------!"
      const expected = "      ---------#"
      const result = left.pipe(combineLatest(right, (x, y) => x + y))
      expectObservable(result).toBe(expected, null, "jenga")
      expectSubscriptions(left.subscriptions).toBe(leftSubs)
      expectSubscriptions(right.subscriptions).toBe(rightSubs)
    })
  })
  it("should handle two consecutive hot observables with error right", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const left = hot(" --a--^--b--c--|", { a: "a", b: "b", c: "c" })
      const leftSubs = "      ^--------!"
      const right = hot(
        "-----^----------d--e--f--#",
        { d: "d", e: "e", f: "f" },
        "dun dun dun"
      )
      const rightSubs = "     ^-------------------!"
      const expected = "      -----------x--y--z--#"
      const result = left.pipe(combineLatest(right, (x, y) => x + y))
      expectObservable(result).toBe(
        expected,
        { x: "cd", y: "ce", z: "cf" },
        "dun dun dun"
      )
      expectSubscriptions(left.subscriptions).toBe(leftSubs)
      expectSubscriptions(right.subscriptions).toBe(rightSubs)
    })
  })
  it("should handle selector throwing", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--|", { a: 1, b: 2 })
      const e1subs = "     ^--!"
      const e2 = hot("--c--^--d--|", { c: 3, d: 4 })
      const e2subs = "     ^--!"
      const expected = "   ---#"
      const result = e1.pipe(
        combineLatest(e2, (x, y) => {
          throw "ha ha " + x + ", " + y
        })
      )
      expectObservable(result).toBe(expected, null, "ha ha 2, 4")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c---d-| ")
      const e1subs = "     ^--------!    "
      const e2 = hot("---e-^---f--g---h-|")
      const e2subs = "     ^--------!    "
      const expected = "   ----x-yz--    "
      const unsub = "      ---------!    "
      const values = { x: "bf", y: "cf", z: "cg" }
      const result = e1.pipe(combineLatest(e2, (x, y) => x + y))
      expectObservable(result, unsub).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not break unsubscription chains when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c---d-| ")
      const e1subs = "     ^--------!    "
      const e2 = hot("---e-^---f--g---h-|")
      const e2subs = "     ^--------!    "
      const expected = "   ----x-yz--    "
      const unsub = "      ---------!    "
      const values = { x: "bf", y: "cf", z: "cg" }
      const result = e1.pipe(
        mergeMap(x => of(x)),
        combineLatest(e2, (x, y) => x + y),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should emit unique array instances with the default projection", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const e1 = hot("  -a--b--|")
      const e2 = hot("  --1--2-|")
      const expected = "-------(c|)"
      const result = e1.pipe(combineLatest(e2), distinct(), count())
      expectObservable(result).toBe(expected, { c: 3 })
    })
  })
})
import { combineLatest } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {combineLatest} */
describe("combineLatest", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should accept array of observables", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--|")
      const e1subs = "     ^--------!"
      const e2 = hot("---e-^---f--g--|")
      const e2subs = "     ^---------!"
      const e3 = hot("---h-^----i--j-|")
      const e3subs = "     ^---------!"
      const expected = "   -----wxyz-|"
      const result = e1.pipe(
        combineLatest([e2, e3], (x: string, y: string, z: string) => x + y + z)
      )
      expectObservable(result).toBe(expected, {
        w: "bfi",
        x: "cfi",
        y: "cgi",
        z: "cgj",
      })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
      expectSubscriptions(e3.subscriptions).toBe(e3subs)
    })
  })
})
import { expect } from "chai"
import { queueScheduler, of } from "rxjs"
import { combineLatestAll, mergeMap } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {combineLatestAll} */
describe("combineLatestAll operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should combine events from two observables", () => {
    testScheduler.run(({ hot, cold, expectObservable }) => {
      const x = cold("                  -a-----b---|")
      const y = cold("                  --1-2-|     ")
      const outer = hot("-x----y--------|           ", { x: x, y: y })
      const expected = " -----------------A-B--C---|"
      const result = outer.pipe(
        combineLatestAll((a, b) => String(a) + String(b))
      )
      expectObservable(result).toBe(expected, { A: "a1", B: "a2", C: "b2" })
    })
  })
  it("should work with two nevers", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const e2 = cold(" -")
      const e2subs = "  ^"
      const expected = "-"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with never and empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const e2 = cold(" |")
      const e2subs = "  (^!)"
      const expected = "-"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with empty and never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |")
      const e1subs = "  (^!)"
      const e2 = cold(" -")
      const e2subs = "  ^"
      const expected = "-"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with empty and empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |")
      const e1subs = "  (^!)"
      const e2 = cold(" |")
      const e2subs = "  (^!)"
      const expected = "|"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with hot-empty and hot-single", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-a-^-|")
      const e1subs = "   ^-!"
      const e2 = hot("-b-^-c-|")
      const e2subs = "   ^---!"
      const expected = " ----|"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with hot-single and hot-empty", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-a-^-|")
      const e1subs = "   ^-!"
      const e2 = hot("-b-^-c-|")
      const e2subs = "   ^---!"
      const expected = " ----|"
      const result = of(e2, e1).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with hot-single and never", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-a-^-|")
      const e1subs = "   ^-!"
      const e2 = hot("------") //never
      const e2subs = "   ^--"
      const expected = " ---" //never
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with never and hot-single", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--------") //never
      const e1subs = "   ^----"
      const e2 = hot("-a-^-b-|")
      const e2subs = "   ^---!"
      const expected = " -----" //never
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with hot and hot", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--|")
      const e1subs = "     ^--------!"
      const e2 = hot("---e-^---f--g--|")
      const e2subs = "     ^---------!"
      const expected = "   ----x-yz--|"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected, { x: "bf", y: "cf", z: "cg" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c---d-| ")
      const e1subs = "     ^--------!    "
      const e2 = hot("---e-^---f--g---h-|")
      const e2subs = "     ^--------!    "
      const expected = "   ----x-yz--    "
      const unsub = "      ---------!    "
      const values = { x: "bf", y: "cf", z: "cg" }
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result, unsub).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not break unsubscription chains when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--^--b--c---d-| ")
      const e1subs = "       ^--------!    "
      const e2 = hot("  ---e-^---f--g---h-|")
      const e2subs = "       ^--------!    "
      const expected = "     ----x-yz--    "
      const unsub = "        ---------!    "
      const values = { x: "bf", y: "cf", z: "cg" }
      const result = of(e1, e2).pipe(
        mergeMap(x => of(x)),
        combineLatestAll((x, y) => x + y),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should combine 3 observables", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--|")
      const e1subs = "     ^--------!"
      const e2 = hot("---e-^---f--g--|")
      const e2subs = "     ^---------!"
      const e3 = hot("---h-^----i--j-|")
      const e3subs = "     ^---------!"
      const expected = "   -----wxyz-|"
      const result = of(e1, e2, e3).pipe(
        combineLatestAll((x, y, z) => x + y + z)
      )
      expectObservable(result).toBe(expected, {
        w: "bfi",
        x: "cfi",
        y: "cgi",
        z: "cgj",
      })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
      expectSubscriptions(e3.subscriptions).toBe(e3subs)
    })
  })
  it("should work with empty and error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----------|") //empty
      const e1subs = "  ^-----!"
      const e2 = hot("  ------#", undefined, "shazbot!") //error
      const e2subs = "  ^-----!"
      const expected = "------#"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected, null, "shazbot!")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with error and empty", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--^---#", undefined, "too bad, honk") //error
      const e1subs = "  ^---!"
      const e2 = hot("--^--------|") //empty
      const e2subs = "  ^---!"
      const expected = "----#"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected, null, "too bad, honk")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with hot and throw", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-a-^--b--c--|")
      const e1subs = "   ^-!"
      const e2 = hot("---^-#", undefined, "bazinga")
      const e2subs = "   ^-!"
      const expected = " --#"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected, null, "bazinga")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with throw and hot", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^-#", undefined, "bazinga")
      const e1subs = "   ^-!"
      const e2 = hot("-a-^--b--c--|")
      const e2subs = "   ^-!"
      const expected = " --#"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected, null, "bazinga")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with throw and throw", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^----#", undefined, "jenga")
      const e1subs = "   ^-!"
      const e2 = hot("---^-#", undefined, "bazinga")
      const e2subs = "   ^-!"
      const expected = " --#"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected, null, "bazinga")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with error and throw", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-a-^--b--#", undefined, "wokka wokka")
      const e1subs = "   ^-!"
      const e2 = hot("---^-#", undefined, "flurp")
      const e2subs = "   ^-!"
      const expected = " --#"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected, null, "flurp")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with throw and error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^-#", undefined, "flurp")
      const e1subs = "   ^-!"
      const e2 = hot("-a-^--b--#", undefined, "wokka wokka")
      const e2subs = "   ^-!"
      const expected = " --#"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected, null, "flurp")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with never and throw", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^-----------")
      const e1subs = "   ^-----!"
      const e2 = hot("---^-----#", undefined, "wokka wokka")
      const e2subs = "   ^-----!"
      const expected = " ------#"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected, null, "wokka wokka")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with throw and never", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("   ---^----#", undefined, "wokka wokka")
      const e1subs = "      ^----!"
      const e2 = hot("   ---^-----------")
      const e2subs = "      ^----!"
      const expected = "    -----#"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected, null, "wokka wokka")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with some and throw", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^----a---b--|")
      const e1subs = "   ^--!"
      const e2 = hot("---^--#", undefined, "wokka wokka")
      const e2subs = "   ^--!"
      const expected = " ---#"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected, { a: 1, b: 2 }, "wokka wokka")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with throw and some", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^--#", undefined, "wokka wokka")
      const e1subs = "   ^--!"
      const e2 = hot("---^----a---b--|")
      const e2subs = "   ^--!"
      const expected = " ---#"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected, null, "wokka wokka")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should handle throw after complete left", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const left = hot(" --a--^--b---|")
      const leftSubs = "      ^------!"
      const right = hot("-----^--------#", undefined, "bad things")
      const rightSubs = "     ^--------!"
      const expected = "      ---------#"
      const result = of(left, right).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected, null, "bad things")
      expectSubscriptions(left.subscriptions).toBe(leftSubs)
      expectSubscriptions(right.subscriptions).toBe(rightSubs)
    })
  })
  it("should handle throw after complete right", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const left = hot(" -----^--------#", undefined, "bad things")
      const leftSubs = "      ^--------!"
      const right = hot("--a--^--b---|")
      const rightSubs = "     ^------!"
      const expected = "      ---------#"
      const result = of(left, right).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected, null, "bad things")
      expectSubscriptions(left.subscriptions).toBe(leftSubs)
      expectSubscriptions(right.subscriptions).toBe(rightSubs)
    })
  })
  it("should handle interleaved with tail", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-a--^--b---c---|")
      const e1subs = "    ^----------!"
      const e2 = hot("--d-^----e---f--|")
      const e2subs = "    ^-----------!"
      const expected = "  -----x-y-z--|"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected, { x: "be", y: "ce", z: "cf" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should handle two consecutive hot observables", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--|")
      const e1subs = "     ^--------!"
      const e2 = hot("-----^----------d--e--f--|")
      const e2subs = "     ^-------------------!"
      const expected = "   -----------x--y--z--|"
      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected, { x: "cd", y: "ce", z: "cf" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should handle two consecutive hot observables with error left", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const left = hot(" --a--^--b--c--#", undefined, "jenga")
      const leftSubs = "      ^--------!"
      const right = hot("-----^----------d--e--f--|")
      const rightSubs = "     ^--------!"
      const expected = "      ---------#"
      const result = of(left, right).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(expected, null, "jenga")
      expectSubscriptions(left.subscriptions).toBe(leftSubs)
      expectSubscriptions(right.subscriptions).toBe(rightSubs)
    })
  })
  it("should handle two consecutive hot observables with error right", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const left = hot(" --a--^--b--c--|")
      const leftSubs = "      ^--------!"
      const right = hot("-----^----------d--e--f--#", undefined, "dun dun dun")
      const rightSubs = "     ^-------------------!"
      const expected = "      -----------x--y--z--#"
      const result = of(left, right).pipe(combineLatestAll((x, y) => x + y))
      expectObservable(result).toBe(
        expected,
        { x: "cd", y: "ce", z: "cf" },
        "dun dun dun"
      )
      expectSubscriptions(left.subscriptions).toBe(leftSubs)
      expectSubscriptions(right.subscriptions).toBe(rightSubs)
    })
  })
  it("should handle selector throwing", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--|")
      const e1subs = "     ^--!"
      const e2 = hot("--c--^--d--|")
      const e2subs = "     ^--!"
      const expected = "   ---#"
      const result = of(e1, e2).pipe(
        combineLatestAll((x, y) => {
          throw "ha ha " + x + ", " + y
        })
      )
      expectObservable(result).toBe(expected, null, "ha ha b, d")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should combine two observables", done => {
    const a = of(1, 2, 3)
    const b = of(4, 5, 6, 7, 8)
    const expected = [
      [3, 4],
      [3, 5],
      [3, 6],
      [3, 7],
      [3, 8],
    ]
    of(a, b)
      .pipe(combineLatestAll())
      .subscribe({
        next: vals => {
          expect(vals).to.deep.equal(expected.shift())
        },
        complete: () => {
          expect(expected.length).to.equal(0)
          done()
        },
      })
  })
  it("should combine two immediately-scheduled observables", done => {
    const a = of(1, 2, 3, queueScheduler)
    const b = of(4, 5, 6, 7, 8, queueScheduler)
    const r = [
      [1, 4],
      [2, 4],
      [2, 5],
      [3, 5],
      [3, 6],
      [3, 7],
      [3, 8],
    ]
    of(a, b, queueScheduler)
      .pipe(combineLatestAll())
      .subscribe({
        next: vals => {
          expect(vals).to.deep.equal(r.shift())
        },
        complete: () => {
          expect(r.length).to.equal(0)
          done()
        },
      })
  })
})
import { of } from "rxjs"
import {
  combineLatestWith,
  mergeMap,
  distinct,
  count,
  map,
} from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {combineLatestWith} */
describe("combineLatestWith", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should combine events from two cold observables", () => {
    testScheduler.run(({ cold, expectObservable }) => {
      const e1 = cold(" -a--b-----c-d-e-|")
      const e2 = cold(" --1--2-3-4---|   ")
      const expected = "--A-BC-D-EF-G-H-|"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([a, b]) => a + b)
      )
      expectObservable(result).toBe(expected, {
        A: "a1",
        B: "b1",
        C: "b2",
        D: "b3",
        E: "b4",
        F: "c4",
        G: "d4",
        H: "e4",
      })
    })
  })
  it("should work with two nevers", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const e2 = cold(" -")
      const e2subs = "  ^"
      const expected = "-"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with never and empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const e2 = cold(" |")
      const e2subs = "  (^!)"
      const expected = "-"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with empty and never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |")
      const e1subs = "  (^!)"
      const e2 = cold(" -")
      const e2subs = "  ^"
      const expected = "-"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with empty and empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |")
      const e1subs = "  (^!)"
      const e2 = cold(" |")
      const e2subs = "  (^!)"
      const expected = "|"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with hot-empty and hot-single", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: 1,
        b: 2,
        c: 3,
        r: 1 + 3, //a + c
      }
      const e1 = hot("-a-^-|", values)
      const e1subs = "   ^-!"
      const e2 = hot("-b-^-c-|", values)
      const e2subs = "   ^---!"
      const expected = " ----|"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with hot-single and hot-empty", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: 1,
        b: 2,
        c: 3,
      }
      const e1 = hot("-a-^-|", values)
      const e1subs = "   ^-!"
      const e2 = hot("-b-^-c-|", values)
      const e2subs = "   ^---!"
      const expected = " ----|"
      const result = e2.pipe(
        combineLatestWith(e1),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with hot-single and never", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: 1,
      }
      const e1 = hot("-a-^-|", values)
      const e1subs = "   ^-!"
      const e2 = hot("------", values) //never
      const e2subs = "   ^--"
      const expected = " ---" //never
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with never and hot-single", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: 1,
        b: 2,
      }
      const e1 = hot("--------", values) //never
      const e1subs = "   ^    "
      const e2 = hot("-a-^-b-|", values)
      const e2subs = "   ^---!"
      const expected = " -----" //never
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with hot and hot", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--|", { a: "a", b: "b", c: "c" })
      const e1subs = "     ^--------!"
      const e2 = hot("---e-^---f--g--|", { e: "e", f: "f", g: "g" })
      const e2subs = "     ^---------!"
      const expected = "   ----x-yz--|"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, { x: "bf", y: "cf", z: "cg" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with empty and error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----------|") //empty
      const e1subs = "  ^-----!"
      const e2 = hot("  ------#", undefined, "shazbot!") //error
      const e2subs = "  ^-----!"
      const expected = "------#"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, null, "shazbot!")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with error and empty", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--^---#", undefined, "too bad, honk") //error
      const e1subs = "  ^---!"
      const e2 = hot("--^--------|") //empty
      const e2subs = "  ^---!"
      const expected = "----#"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, null, "too bad, honk")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with hot and throw", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-a-^--b--c--|", { a: 1, b: 2, c: 3 })
      const e1subs = "   ^-!"
      const e2 = hot("---^-#", undefined, "bazinga")
      const e2subs = "   ^-!"
      const expected = " --#"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, null, "bazinga")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with throw and hot", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^-#", undefined, "bazinga")
      const e1subs = "   ^-!"
      const e2 = hot("-a-^--b--c--|", { a: 1, b: 2, c: 3 })
      const e2subs = "   ^-!"
      const expected = " --#"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, null, "bazinga")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with throw and throw", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^----#", undefined, "jenga")
      const e1subs = "   ^-!"
      const e2 = hot("---^-#", undefined, "bazinga")
      const e2subs = "   ^-!"
      const expected = " --#"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, null, "bazinga")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with error and throw", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-a-^--b--#", { a: 1, b: 2 }, "wokka wokka")
      const e1subs = "   ^-!"
      const e2 = hot("---^-#", undefined, "flurp")
      const e2subs = "   ^-!"
      const expected = " --#"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, null, "flurp")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with throw and error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^-#", undefined, "flurp")
      const e1subs = "   ^-!"
      const e2 = hot("-a-^--b--#", { a: 1, b: 2 }, "wokka wokka")
      const e2subs = "   ^-!"
      const expected = " --#"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, null, "flurp")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with never and throw", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^-----------")
      const e1subs = "   ^-----!"
      const e2 = hot("---^-----#", undefined, "wokka wokka")
      const e2subs = "   ^-----!"
      const expected = " ------#"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, null, "wokka wokka")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with throw and never", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^----#", undefined, "wokka wokka")
      const e1subs = "   ^----!"
      const e2 = hot("---^-----------")
      const e2subs = "   ^----!"
      const expected = " -----#"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, null, "wokka wokka")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with some and throw", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("   ---^----a---b--|", { a: 1, b: 2 })
      const e1subs = "      ^--!"
      const e2 = hot("   ---^--#", undefined, "wokka wokka")
      const e2subs = "      ^--!"
      const expected = "    ---#"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, { a: 1, b: 2 }, "wokka wokka")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should work with throw and some", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^--#", undefined, "wokka wokka")
      const e1subs = "   ^--!"
      const e2 = hot("---^----a---b--|", { a: 1, b: 2 })
      const e2subs = "   ^--!"
      const expected = " ---#"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, { a: 1, b: 2 }, "wokka wokka")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should handle throw after complete left", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const left = hot(" --a--^--b---|", { a: 1, b: 2 })
      const leftSubs = "      ^------!"
      const right = hot("-----^--------#", undefined, "bad things")
      const rightSubs = "     ^--------!"
      const expected = "      ---------#"
      const result = left.pipe(
        combineLatestWith(right),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, null, "bad things")
      expectSubscriptions(left.subscriptions).toBe(leftSubs)
      expectSubscriptions(right.subscriptions).toBe(rightSubs)
    })
  })
  it("should handle throw after complete right", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const left = hot("  -----^--------#", undefined, "bad things")
      const leftSubs = "       ^--------!"
      const right = hot(" --a--^--b---|", { a: 1, b: 2 })
      const rightSubs = "      ^------!"
      const expected = "       ---------#"
      const result = left.pipe(
        combineLatestWith(right),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, null, "bad things")
      expectSubscriptions(left.subscriptions).toBe(leftSubs)
      expectSubscriptions(right.subscriptions).toBe(rightSubs)
    })
  })
  it("should handle interleaved with tail", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-a--^--b---c---|", { a: "a", b: "b", c: "c" })
      const e1subs = "    ^----------!"
      const e2 = hot("--d-^----e---f--|", { d: "d", e: "e", f: "f" })
      const e2subs = "    ^-----------!"
      const expected = "  -----x-y-z--|"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, { x: "be", y: "ce", z: "cf" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should handle two consecutive hot observables", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--|", { a: "a", b: "b", c: "c" })
      const e1subs = "     ^--------!"
      const e2 = hot("-----^----------d--e--f--|", { d: "d", e: "e", f: "f" })
      const e2subs = "     ^-------------------!"
      const expected = "   -----------x--y--z--|"
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, { x: "cd", y: "ce", z: "cf" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should handle two consecutive hot observables with error left", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const left = hot(" --a--^--b--c--#", { a: "a", b: "b", c: "c" }, "jenga")
      const leftSubs = "      ^--------!"
      const right = hot("-----^----------d--e--f--|", {
        d: "d",
        e: "e",
        f: "f",
      })
      const rightSubs = "     ^--------!"
      const expected = "      ---------#"
      const result = left.pipe(
        combineLatestWith(right),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(expected, null, "jenga")
      expectSubscriptions(left.subscriptions).toBe(leftSubs)
      expectSubscriptions(right.subscriptions).toBe(rightSubs)
    })
  })
  it("should handle two consecutive hot observables with error right", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const left = hot(" --a--^--b--c--|", { a: "a", b: "b", c: "c" })
      const leftSubs = "      ^--------!"
      const right = hot(
        "-----^----------d--e--f--#",
        { d: "d", e: "e", f: "f" },
        "dun dun dun"
      )
      const rightSubs = "     ^-------------------!"
      const expected = "      -----------x--y--z--#"
      const result = left.pipe(
        combineLatestWith(right),
        map(([x, y]) => x + y)
      )
      expectObservable(result).toBe(
        expected,
        { x: "cd", y: "ce", z: "cf" },
        "dun dun dun"
      )
      expectSubscriptions(left.subscriptions).toBe(leftSubs)
      expectSubscriptions(right.subscriptions).toBe(rightSubs)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c---d-| ")
      const e1subs = "     ^--------!    "
      const e2 = hot("---e-^---f--g---h-|")
      const e2subs = "     ^--------!    "
      const expected = "   ----x-yz--    "
      const unsub = "      ---------!    "
      const values = { x: "bf", y: "cf", z: "cg" }
      const result = e1.pipe(
        combineLatestWith(e2),
        map(([x, y]) => x + y)
      )
      expectObservable(result, unsub).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not break unsubscription chains when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c---d-| ")
      const e1subs = "     ^--------!    "
      const e2 = hot("---e-^---f--g---h-|")
      const e2subs = "     ^--------!    "
      const expected = "   ----x-yz--    "
      const unsub = "      ---------!    "
      const values = { x: "bf", y: "cf", z: "cg" }
      const result = e1.pipe(
        mergeMap(x => of(x)),
        combineLatestWith(e2),
        map(([x, y]) => x + y),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should emit unique array instances with the default projection", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const e1 = hot("  -a--b--|")
      const e2 = hot("  --1--2-|")
      const expected = "-------(c|)"
      const result = e1.pipe(combineLatestWith(e2), distinct(), count())
      expectObservable(result).toBe(expected, { c: 3 })
    })
  })
})
import { expect } from "chai"
import { of, Observable } from "rxjs"
import { concat, mergeMap } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {concat} */
describe("concat operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should concatenate two cold observables", () => {
    testScheduler.run(({ cold, expectObservable }) => {
      const e1 = cold("  --a--b-|")
      const e2 = cold("         --x---y--|")
      const expected = " --a--b---x---y--|"
      expectObservable(e1.pipe(concat(e2, testScheduler))).toBe(expected)
    })
  })
  it("should work properly with scalar observables", done => {
    const results: string[] = []
    const s1 = new Observable<number>(observer => {
      setTimeout(() => {
        observer.next(1)
        observer.complete()
      })
    }).pipe(concat(of(2)))
    s1.subscribe({
      next: x => {
        results.push("Next: " + x)
      },
      error: x => {
        done(new Error("should not be called"))
      },
      complete: () => {
        results.push("Completed")
        expect(results).to.deep.equal(["Next: 1", "Next: 2", "Completed"])
        done()
      },
    })
  })
  it("should complete without emit if both sources are empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  --|")
      const e1subs = "   ^-!"
      const e2 = cold("    ----|")
      const e2subs = "   --^---!"
      const expected = " ------|"
      expectObservable(e1.pipe(concat(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not complete if first source does not complete", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  -")
      const e1subs = "   ^"
      const e2 = cold("  --|")
      const e2subs: string[] = []
      const expected = " -"
      expectObservable(e1.pipe(concat(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not complete if second source does not complete", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  --|")
      const e1subs = "   ^-!"
      const e2 = cold("  ---")
      const e2subs = "   --^"
      const expected = " ---"
      expectObservable(e1.pipe(concat(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not complete if both sources do not complete", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  -")
      const e1subs = "   ^"
      const e2 = cold("  -")
      const e2subs: string[] = []
      const expected = " -"
      expectObservable(e1.pipe(concat(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise error when first source is empty, second source raises error", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  --|")
      const e1subs = "   ^-!"
      const e2 = cold("    ----#")
      const e2subs = "   --^---!"
      const expected = " ------#"
      expectObservable(e1.pipe(concat(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise error when first source raises error, second source is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  ---#")
      const e1subs = "   ^--!"
      const e2 = cold("  ----|")
      const e2subs: string[] = []
      const expected = " ---#"
      expectObservable(e1.pipe(concat(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise first error when both source raise error", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  ---#")
      const e1subs = "   ^--!"
      const e2 = cold("  ------#")
      const e2subs: string[] = []
      const expected = " ---#"
      expectObservable(e1.pipe(concat(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should concat if first source emits once, second source is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  --a--|")
      const e1subs = "   ^----!"
      const e2 = cold("       --------|")
      const e2subs = "   -----^-------!"
      const expected = " --a----------|"
      expectObservable(e1.pipe(concat(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should concat if first source is empty, second source emits once", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  --|")
      const e1subs = "   ^-!"
      const e2 = cold("    --a--|")
      const e2subs = "   --^----!"
      const expected = " ----a--|"
      expectObservable(e1.pipe(concat(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should emit element from first source, and should not complete if second source does not complete", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  --a--|")
      const e1subs = "   ^----!"
      const e2 = cold("       -")
      const e2subs = "   -----^"
      const expected = " --a---"
      expectObservable(e1.pipe(concat(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not complete if first source does not complete", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  -")
      const e1subs = "   ^"
      const e2 = cold("  --a--|")
      const e2subs: string[] = []
      const expected = " -"
      expectObservable(e1.pipe(concat(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should emit elements from each source when source emit once", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  ---a|")
      const e1subs = "   ^---!"
      const e2 = cold("      -----b--|")
      const e2subs = "   ----^-------!"
      const expected = " ---a-----b--|"
      expectObservable(e1.pipe(concat(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should unsubscribe to inner source if outer is unsubscribed early", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  ---a-a--a|            ")
      const e1subs = "   ^--------!            "
      const e2 = cold("           -----b-b--b-|")
      const e2subs = "   ---------^-------!    "
      const unsub = "    -----------------!    "
      const expected = " ---a-a--a-----b-b     "
      expectObservable(e1.pipe(concat(e2)), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  ---a-a--a|            ")
      const e1subs = "   ^--------!            "
      const e2 = cold("           -----b-b--b-|")
      const e2subs = "   ---------^-------!    "
      const expected = " ---a-a--a-----b-b-    "
      const unsub = "    -----------------!    "
      const result = e1.pipe(
        mergeMap(x => of(x)),
        concat(e2),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise error from first source and does not emit from second source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  --#")
      const e1subs = "   ^-!"
      const e2 = cold("  ----a--|")
      const e2subs: string[] = []
      const expected = " --#"
      expectObservable(e1.pipe(concat(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should emit element from first source then raise error from second source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  --a--|")
      const e1subs = "   ^----!"
      const e2 = cold("       -------#")
      const e2subs = "   -----^------!"
      const expected = " --a---------#"
      expectObservable(e1.pipe(concat(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should emit all elements from both hot observable sources if first source completes before second source starts emit", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b-|")
      const e1subs = "  ^------!"
      const e2 = hot("  --------x--y--|")
      const e2subs = "  -------^------!"
      const expected = "--a--b--x--y--|"
      expectObservable(e1.pipe(concat(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should emit elements from second source regardless of completion time when second source is cold observable", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--b--c---|")
        const e1subs = "  ^-----------!"
        const e2 = cold(" -x-y-z-|")
        const e2subs = "  ------------^------!"
        const expected = "--a--b--c----x-y-z-|"
        expectObservable(e1.pipe(concat(e2))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should not emit collapsing element from second source", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^----------!"
      const e2 = hot("  --------x--y--z--|")
      const e2subs = "  -----------^-----!"
      const expected = "--a--b--c--y--z--|"
      expectObservable(e1.pipe(concat(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should accept scheduler with multiple observables", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  ---a|")
      const e1subs = "   ^---!"
      const e2 = cold("      ---b--|")
      const e2subs = "   ----^-----!"
      const e3 = cold("            ---c--|")
      const e3subs = "   ----------^-----!"
      const expected = " ---a---b-----c--|"
      expectObservable(e1.pipe(concat(e2, e3, testScheduler))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
      expectSubscriptions(e3.subscriptions).toBe(e3subs)
    })
  })
  it("should accept scheduler without observable parameters", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  ---a-|")
      const e1subs = "   ^----!"
      const expected = " ---a-|"
      expectObservable(e1.pipe(concat(testScheduler))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit self without parameters", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  ---a-|")
      const e1subs = "   ^----!"
      const expected = " ---a-|"
      expectObservable(e1.pipe(concat())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
})
import { expect } from "chai"
import { from, throwError, of, Observable, defer } from "rxjs"
import { concatAll, take, mergeMap, finalize, delay } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {concatAll} */
describe("concatAll operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should concat an observable of observables", () => {
    testScheduler.run(({ cold, hot, expectObservable }) => {
      const x = cold("    ----a------b------|                 ")
      const y = cold("                      ---c-d---|        ")
      const z = cold("                               ---e--f-|")
      const outer = hot("-x---y----z------|", { x: x, y: y, z: z })
      const expected = " -----a------b---------c-d------e--f-|"
      const result = outer.pipe(concatAll())
      expectObservable(result).toBe(expected)
    })
  })
  it("should concat sources from promise", function (done) {
    this.timeout(2000)
    const sources = from([
      new Promise<number>(res => {
        res(0)
      }),
      new Promise<number>(res => {
        res(1)
      }),
      new Promise<number>(res => {
        res(2)
      }),
      new Promise<number>(res => {
        res(3)
      }),
    ]).pipe(take(10))
    const res: number[] = []
    sources.pipe(concatAll()).subscribe({
      next: x => {
        res.push(x)
      },
      error: err => {
        done(new Error("should not be called"))
      },
      complete: () => {
        expect(res).to.deep.equal([0, 1, 2, 3])
        done()
      },
    })
  })
  it("should finalize before moving to the next observable", () => {
    const results: any[] = []
    const create = (n: number) =>
      defer(() => {
        results.push(`init ${n}`)
        return of(`next ${n}`).pipe(
          delay(100, testScheduler),
          finalize(() => {
            results.push(`finalized ${n}`)
          })
        )
      })
    of(create(1), create(2), create(3))
      .pipe(concatAll())
      .subscribe({
        next: value => results.push(value),
      })
    testScheduler.flush()
    expect(results).to.deep.equal([
      "init 1",
      "next 1",
      "finalized 1",
      "init 2",
      "next 2",
      "finalized 2",
      "init 3",
      "next 3",
      "finalized 3",
    ])
  })
  it("should concat and raise error from promise", function (done) {
    this.timeout(2000)
    const sources = from([
      new Promise<number>(res => {
        res(0)
      }),
      new Promise<number>((res, rej) => {
        rej(1)
      }),
      new Promise<number>(res => {
        res(2)
      }),
      new Promise<number>(res => {
        res(3)
      }),
    ]).pipe(take(10))
    const res: number[] = []
    sources.pipe(concatAll()).subscribe({
      next: x => {
        res.push(x)
      },
      error: err => {
        expect(res.length).to.equal(1)
        expect(err).to.equal(1)
        done()
      },
      complete: () => {
        done(new Error("should not be called"))
      },
    })
  })
  it("should concat all observables in an observable", () => {
    testScheduler.run(({ expectObservable }) => {
      const e1 = from([of("a"), of("b"), of("c")]).pipe(take(10))
      const expected = "(abc|)"
      expectObservable(e1.pipe(concatAll())).toBe(expected)
    })
  })
  it("should throw if any child observable throws", () => {
    testScheduler.run(({ expectObservable }) => {
      const e1 = from([of("a"), throwError(() => "error"), of("c")]).pipe(
        take(10)
      )
      const expected = "(a#)"
      expectObservable(e1.pipe(concatAll())).toBe(expected)
    })
  })
  it("should concat merging a hot observable of non-overlapped observables", () => {
    testScheduler.run(({ cold, hot, expectObservable }) => {
      const values = {
        x: cold("       a-b---------|"),
        y: cold("                 c-d-e-f-|"),
        z: cold("                          g-h-i-j-k-|"),
      }
      const e1 = hot("  --x---------y--------z--------|", values)
      const expected = "--a-b---------c-d-e-f-g-h-i-j-k-|"
      expectObservable(e1.pipe(concatAll())).toBe(expected)
    })
  })
  it("should raise error if inner observable raises error", () => {
    testScheduler.run(({ cold, hot, expectObservable }) => {
      const values = {
        x: cold("       a-b---------|"),
        y: cold("                 c-d-e-f-#"),
        z: cold("                         g-h-i-j-k-|"),
      }
      const e1 = hot("  --x---------y--------z--------|", values)
      const expected = "--a-b---------c-d-e-f-#"
      expectObservable(e1.pipe(concatAll())).toBe(expected)
    })
  })
  it("should raise error if outer observable raises error", () => {
    testScheduler.run(({ cold, hot, expectObservable }) => {
      const values = {
        y: cold("       a-b---------|"),
        z: cold("                 c-d-e-f-|"),
      }
      const e1 = hot("  --y---------z---#    ", values)
      const expected = "--a-b---------c-#"
      expectObservable(e1.pipe(concatAll())).toBe(expected)
    })
  })
  it("should complete without emit if both sources are empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  --|")
      const e1subs = "   ^-!"
      const e2 = cold("    ----|")
      const e2subs = "   --^---!"
      const expected = " ------|"
      const result = of(e1, e2).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not complete if first source does not completes", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  -")
      const e1subs = "   ^"
      const e2 = cold("  --|")
      const e2subs: string[] = []
      const expected = " -"
      const result = of(e1, e2).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not complete if second source does not completes", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  --|")
      const e1subs = "   ^-!"
      const e2 = cold("  ---")
      const e2subs = "   --^"
      const expected = " ---"
      const result = of(e1, e2).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not complete if both sources do not complete", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  -")
      const e1subs = "   ^"
      const e2 = cold("  -")
      const e2subs: string[] = []
      const expected = " -"
      const result = of(e1, e2).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise error when first source is empty, second source raises error", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  --|")
      const e1subs = "   ^-!"
      const e2 = cold("    ----#")
      const e2subs = "   --^---!"
      const expected = " ------#"
      const result = of(e1, e2).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise error when first source raises error, second source is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  ---#")
      const e1subs = "   ^--!"
      const e2 = cold("  ----|")
      const e2subs: string[] = []
      const expected = " ---#"
      const result = of(e1, e2).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise first error when both source raise error", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  ---#")
      const e1subs = "   ^--!"
      const e2 = cold("  ------#")
      const e2subs: string[] = []
      const expected = " ---#"
      const result = of(e1, e2).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should concat if first source emits once, second source is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  --a--|")
      const e1subs = "   ^----!"
      const e2 = cold("       --------|")
      const e2subs = "   -----^-------!"
      const expected = " --a----------|"
      const result = of(e1, e2).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should concat if first source is empty, second source emits once", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  --|")
      const e1subs = "   ^-!"
      const e2 = cold("    --a--|")
      const e2subs = "   --^----!"
      const expected = " ----a--|"
      const result = of(e1, e2).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should emit element from first source, and should not complete if second source does not completes", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  --a--|")
      const e1subs = "   ^----!"
      const e2 = cold("       -")
      const e2subs = "   -----^"
      const expected = " --a---"
      const result = of(e1, e2).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not complete if first source does not complete", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  -")
      const e1subs = "   ^"
      const e2 = cold("  --a--|")
      const e2subs: string[] = []
      const expected = " -"
      const result = of(e1, e2).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should emit elements from each source when source emit once", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  ---a|")
      const e1subs = "   ^---!"
      const e2 = cold("      -----b--|")
      const e2subs = "   ----^-------!"
      const expected = " ---a-----b--|"
      const result = of(e1, e2).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should unsubscribe to inner source if outer is unsubscribed early", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  ---a-a--a|            ")
      const e1subs = "   ^--------!            "
      const e2 = cold("           -----b-b--b-|")
      const e2subs = "   ---------^-------!    "
      const unsub = "    -----------------!    "
      const expected = " ---a-a--a-----b-b     "
      const result = of(e1, e2).pipe(concatAll())
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  ---a-a--a|            ")
      const e1subs = "   ^--------!            "
      const e2 = cold("           -----b-b--b-|")
      const e2subs = "   ---------^-------!    "
      const expected = " ---a-a--a-----b-b-    "
      const unsub = "    -----------------!    "
      const result = of(e1, e2).pipe(
        mergeMap(x => of(x)),
        concatAll(),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise error from first source and does not emit from second source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  --#")
      const e1subs = "   ^-!"
      const e2 = cold("  ----a--|")
      const e2subs: string[] = []
      const expected = " --#"
      const result = of(e1, e2).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should emit element from first source then raise error from second source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  --a--|")
      const e1subs = "   ^----!"
      const e2 = cold("       -------#")
      const e2subs = "   -----^------!"
      const expected = " --a---------#"
      const result = of(e1, e2).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should emit all elements from both hot observable sources if first source completes before second source starts emit", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b-|")
      const e1subs = "  ^------!"
      const e2 = hot("  --------x--y--|")
      const e2subs = "  -------^------!"
      const expected = "--a--b--x--y--|"
      const result = of(e1, e2).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should emit elements from second source regardless of completion time when second source is cold observable", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--b--c---|")
        const e1subs = "  ^-----------!"
        const e2 = cold(" -x-y-z-|")
        const e2subs = "  ------------^------!"
        const expected = "--a--b--c----x-y-z-|"
        const result = of(e1, e2).pipe(concatAll())
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should not emit collapsing element from second source", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^----------!"
      const e2 = hot("  --------x--y--z--|")
      const e2subs = "  -----------^-----!"
      const expected = "--a--b--c--y--z--|"
      const result = of(e1, e2).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should be able to work on a different scheduler", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  ---a|")
      const e1subs = "   ^---!"
      const e2 = cold("      ---b--|")
      const e2subs = "   ----^-----!"
      const e3 = cold("            ---c--|")
      const e3subs = "   ----------^-----!"
      const expected = " ---a---b-----c--|"
      const result = of(e1, e2, e3, testScheduler).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
      expectSubscriptions(e3.subscriptions).toBe(e3subs)
    })
  })
  it("should concatAll a nested observable with a single inner observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  ---a-|")
      const e1subs = "   ^----!"
      const expected = " ---a-|"
      const result = of(e1).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should concatAll a nested observable with a single inner observable, and a scheduler", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  ---a-|")
      const e1subs = "   ^----!"
      const expected = " ---a-|"
      const result = of(e1, testScheduler).pipe(concatAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    of(synchronousObservable)
      .pipe(concatAll(), take(3))
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { of, from, Observable, defer } from "rxjs"
import { concatMap, mergeMap, map, take, finalize, delay } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {concatMap} */
describe("Observable.prototype.concatMap", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should map-and-flatten each item to an Observable", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("   --1-----3--5-------|")
        const e1subs = "   ^------------------!"
        const e2 = cold("  x-x-x|              ", { x: 10 })
        const expected = " --x-x-x-y-y-yz-z-z-|"
        const values = { x: 10, y: 30, z: 50 }
        const result = e1.pipe(
          concatMap(x => e2.pipe(map(i => i * parseInt(x))))
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should support the deprecated resultSelector", () => {
    const results: Array<number[]> = []
    of(1, 2, 3)
      .pipe(
        concatMap(
          x => of(x, x + 1, x + 2),
          (a, b, i, ii) => [a, b, i, ii]
        )
      )
      .subscribe({
        next(value) {
          results.push(value)
        },
        error(err) {
          throw err
        },
        complete() {
          expect(results).to.deep.equal([
            [1, 1, 0, 0],
            [1, 2, 0, 1],
            [1, 3, 0, 2],
            [2, 2, 1, 0],
            [2, 3, 1, 1],
            [2, 4, 1, 2],
            [3, 3, 2, 0],
            [3, 4, 2, 1],
            [3, 5, 2, 2],
          ])
        },
      })
  })
  it("should support a void resultSelector (still deprecated)", () => {
    const results: number[] = []
    of(1, 2, 3)
      .pipe(concatMap(x => of(x, x + 1, x + 2), void 0))
      .subscribe({
        next(value) {
          results.push(value)
        },
        error(err) {
          throw err
        },
        complete() {
          expect(results).to.deep.equal([1, 2, 3, 2, 3, 4, 3, 4, 5])
        },
      })
  })
  it("should concatenate many regular interval inners", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const a = cold("  --a-a-a-(a|)                            ")
        const asubs = "   ^-------!                               "
        const b = cold("          ----b--b--(b|)                  ")
        const bsubs = "   --------^---------!                     "
        const c = cold("                           -c-c-(c|)      ")
        const csubs = "   -------------------------^----!         "
        const d = cold("                                ------(d|)")
        const dsubs = "   ------------------------------^-----!   "
        const e1 = hot("  a---b--------------------c-d----|       ")
        const e1subs = "  ^-------------------------------!       "
        const expected = "--a-a-a-a---b--b--b-------c-c-c-----(d|)"
        const observableLookup = { a: a, b: b, c: c, d: d }
        const source = e1.pipe(
          concatMap(
            value => observableLookup[value as keyof typeof observableLookup]
          )
        )
        expectObservable(source).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
        expectSubscriptions(c.subscriptions).toBe(csubs)
        expectSubscriptions(d.subscriptions).toBe(dsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should concatMap many outer values to many inner values", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const values = { i: "foo", j: "bar", k: "baz", l: "qux" }
        const e1 = hot("    -a---b---c---d---|                        ")
        const e1subs = "    ^----------------!                        "
        const inner = cold(" --i-j-k-l-|                              ", values)
        const innersubs = [
          "                 -^---------!                              ",
          "                 -----------^---------!                    ",
          "                 ---------------------^---------!          ",
          "                 -------------------------------^---------!",
        ]
        const expected = "  ---i-j-k-l---i-j-k-l---i-j-k-l---i-j-k-l-|"
        const result = e1.pipe(concatMap(value => inner))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(inner.subscriptions).toBe(innersubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should handle an empty source", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = cold("   |")
        const e1subs = "    (^!)"
        const inner = cold("-1-2-3|")
        const innersubs: string[] = []
        const expected = "  |"
        const result = e1.pipe(concatMap(() => inner))
        expectObservable(result).toBe(expected)
        expectSubscriptions(inner.subscriptions).toBe(innersubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should handle a never source", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = cold("   -")
        const e1subs = "    ^"
        const inner = cold("-1-2-3|")
        const innersubs: string[] = []
        const expected = "  -"
        const result = e1.pipe(
          concatMap(() => {
            return inner
          })
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(inner.subscriptions).toBe(innersubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should error immediately if given a just-throw source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("   #")
      const e1subs = "    (^!)"
      const inner = cold("-1-2-3|")
      const innersubs: string[] = []
      const expected = "  #"
      const result = e1.pipe(
        concatMap(() => {
          return inner
        })
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(inner.subscriptions).toBe(innersubs)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return a silenced version of the source if the mapped inner is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("   --a-b--c-| ")
      const e1subs = "    ^--------! "
      const inner = cold("  |")
      // prettier-ignore
      const innersubs = [
        '                 --(^!)     ',
        '                 ----(^!)   ',
        '                 -------(^!)',
      ];
      const expected = "  ---------| "
      const result = e1.pipe(
        concatMap(() => {
          return inner
        })
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(inner.subscriptions).toBe(innersubs)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return a never if the mapped inner is never", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = cold("  --a-b--c-|")
        const e1subs = "   ^--------!"
        const inner = cold(" -")
        const innersubs = "--^-------"
        const expected = " ----------"
        const result = e1.pipe(
          concatMap(() => {
            return inner
          })
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(inner.subscriptions).toBe(innersubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should propagate errors if the mapped inner is a just-throw Observable", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = cold("  --a-b--c-|")
        const e1subs = "   ^-!       "
        const inner = cold(" #")
        const innersubs = "--(^!)    "
        const expected = " --#       "
        const result = e1.pipe(
          concatMap(() => {
            return inner
          })
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(inner.subscriptions).toBe(innersubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should concatMap many outer to many inner, complete late", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const values = { i: "foo", j: "bar", k: "baz", l: "qux" }
        const e1 = hot("    -a---b---c---d----------------------------------|")
        const e1subs = "    ^-----------------------------------------------!"
        const inner = cold(
          " --i-j-k-l-|                                     ",
          values
        )
        const innersubs = [
          "                 -^---------!                                     ",
          "                 -----------^---------!                           ",
          "                 ---------------------^---------!                 ",
          "                 -------------------------------^---------!       ",
        ]
        const expected = "  ---i-j-k-l---i-j-k-l---i-j-k-l---i-j-k-l--------|"
        const result = e1.pipe(concatMap(value => inner))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(inner.subscriptions).toBe(innersubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should concatMap many outer to many inner, outer never completes", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const values = { i: "foo", j: "bar", k: "baz", l: "qux" }
        const e1 = hot("    -a---b---c---d-----------------------------------")
        const e1subs = "    ^------------------------------------------------"
        const inner = cold(
          " --i-j-k-l-|                                     ",
          values
        )
        const innersubs = [
          "                 -^---------!                                     ",
          "                 -----------^---------!                           ",
          "                 ---------------------^---------!                 ",
          "                 -------------------------------^---------!       ",
        ]
        const expected = "  ---i-j-k-l---i-j-k-l---i-j-k-l---i-j-k-l---------"
        const result = e1.pipe(concatMap(value => inner))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(inner.subscriptions).toBe(innersubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should concatMap many outer to many inner, inner never completes", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const values = { i: "foo", j: "bar", k: "baz", l: "qux" }
        const e1 = hot("    -a---b---c---d---|")
        const e1subs = "    ^----------------!"
        const inner = cold(" --i-j-k-l-       ", values)
        const innersubs = " -^----------------"
        const expected = "  ---i-j-k-l--------"
        const result = e1.pipe(concatMap(value => inner))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(inner.subscriptions).toBe(innersubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should concatMap many outer to many inner, and inner throws", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const values = { i: "foo", j: "bar", k: "baz", l: "qux" }
        const e1 = hot("    -a---b---c---d---|")
        const e1subs = "    ^----------!      "
        const inner = cold(" --i-j-k-l-#      ", values)
        const innersubs = " -^---------!      "
        const expected = "  ---i-j-k-l-#      "
        const result = e1.pipe(concatMap(() => inner))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(inner.subscriptions).toBe(innersubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should concatMap many outer to many inner, and outer throws", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const values = { i: "foo", j: "bar", k: "baz", l: "qux" }
        const e1 = hot("    -a---b---c---d---#")
        const e1subs = "    ^----------------!"
        const inner = cold(" --i-j-k-l-|      ", values)
        // prettier-ignore
        const innersubs = [
        '                 -^---------!      ',
        '                 -----------^-----!',
      ];
        const expected = "  ---i-j-k-l---i-j-#"
        const result = e1.pipe(concatMap(value => inner))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(inner.subscriptions).toBe(innersubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should concatMap many outer to many inner, both inner and outer throw", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const values = { i: "foo", j: "bar", k: "baz", l: "qux" }
        const e1 = hot("    -a---b---c---d---#")
        const e1subs = "    ^----------!      "
        const inner = cold(" --i-j-k-l-#      ", values)
        const innersubs = " -^---------!      "
        const expected = "  ---i-j-k-l-#      "
        const result = e1.pipe(concatMap(value => inner))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(inner.subscriptions).toBe(innersubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should concatMap many complex, where all inners are finite", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const a = cold(
          "   -#                                                          "
        )
        const asubs: string[] = []
        const b = cold(
          "     -#                                                        "
        )
        const bsubs: string[] = []
        const c = cold(
          "          -2--3--4--5----6-|                                   "
        )
        const csubs =
          "         --^----------------!                                   "
        const d = cold(
          "                           ----2--3|                           "
        )
        const dsubs =
          "         -------------------^-------!                           "
        const e = cold(
          "                                   -1------2--3-4-5---|        "
        )
        const esubs =
          "         ---------------------------^------------------!        "
        const f = cold(
          "                                                      --|      "
        )
        const fsubs =
          "         ----------------------------------------------^-!      "
        const g = cold(
          "                                                        ---1-2|"
        )
        const gsubs =
          "         ------------------------------------------------^-----!"
        const e1 = hot(
          "  -a-b--^-c-----d------e----------------f-----g|               "
        )
        const e1subs =
          "        ^--------------------------------------!               "
        const expected =
          "      ---2--3--4--5----6-----2--3-1------2--3-4-5--------1-2|"
        const observableLookup = { a: a, b: b, c: c, d: d, e: e, f: f, g: g }
        const result = e1.pipe(
          concatMap(
            value => observableLookup[value as keyof typeof observableLookup]
          )
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
        expectSubscriptions(c.subscriptions).toBe(csubs)
        expectSubscriptions(d.subscriptions).toBe(dsubs)
        expectSubscriptions(e.subscriptions).toBe(esubs)
        expectSubscriptions(f.subscriptions).toBe(fsubs)
        expectSubscriptions(g.subscriptions).toBe(gsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should concatMap many complex, all inners finite except one", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const a = cold(
          "   -#                                                          "
        )
        const asubs: string[] = []
        const b = cold(
          "     -#                                                        "
        )
        const bsubs: string[] = []
        const c = cold(
          "          -2--3--4--5----6-|                                   "
        )
        const csubs =
          "         --^----------------!                                   "
        const d = cold(
          "                           ----2--3-                           "
        )
        const dsubs =
          "         -------------------^-----------------------------------"
        const e = cold(
          "                                   -1------2--3-4-5---|        "
        )
        const esubs: string[] = []
        const f = cold(
          "                                                      --|      "
        )
        const fsubs: string[] = []
        const g = cold(
          "                                                        ---1-2|"
        )
        const gsubs: string[] = []
        const e1 = hot(
          "  -a-b--^-c-----d------e----------------f-----g|               "
        )
        const e1subs =
          "        ^--------------------------------------!               "
        const expected =
          "      ---2--3--4--5----6-----2--3----------------------------"
        const observableLookup = { a: a, b: b, c: c, d: d, e: e, f: f, g: g }
        const result = e1.pipe(
          concatMap(
            value => observableLookup[value as keyof typeof observableLookup]
          )
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
        expectSubscriptions(c.subscriptions).toBe(csubs)
        expectSubscriptions(d.subscriptions).toBe(dsubs)
        expectSubscriptions(e.subscriptions).toBe(esubs)
        expectSubscriptions(f.subscriptions).toBe(fsubs)
        expectSubscriptions(g.subscriptions).toBe(gsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should concatMap many complex, inners finite, outer does not complete", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const a = cold(
          "   -#                                                          "
        )
        const asubs: string[] = []
        const b = cold(
          "     -#                                                        "
        )
        const bsubs: string[] = []
        const c = cold(
          "          -2--3--4--5----6-|                                   "
        )
        const csubs =
          "         --^----------------!                                   "
        const d = cold(
          "                           ----2--3|                           "
        )
        const dsubs =
          "         -------------------^-------!                           "
        const e = cold(
          "                                   -1------2--3-4-5---|        "
        )
        const esubs =
          "         ---------------------------^------------------!        "
        const f = cold(
          "                                                      --|      "
        )
        const fsubs =
          "         ----------------------------------------------^-!      "
        const g = cold(
          "                                                        ---1-2|"
        )
        const gsubs =
          "         ------------------------------------------------^-----!"
        const e1 = hot(
          "  -a-b--^-c-----d------e----------------f-----g---             "
        )
        const e1subs =
          "        ^                                                      "
        const expected =
          "      ---2--3--4--5----6-----2--3-1------2--3-4-5--------1-2-"
        const observableLookup = { a: a, b: b, c: c, d: d, e: e, f: f, g: g }
        const result = e1.pipe(
          concatMap(
            value => observableLookup[value as keyof typeof observableLookup]
          )
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
        expectSubscriptions(c.subscriptions).toBe(csubs)
        expectSubscriptions(d.subscriptions).toBe(dsubs)
        expectSubscriptions(e.subscriptions).toBe(esubs)
        expectSubscriptions(f.subscriptions).toBe(fsubs)
        expectSubscriptions(g.subscriptions).toBe(gsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should concatMap many complex, all inners finite, and outer throws", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const a = cold(
          "   -#                                                          "
        )
        const asubs: string[] = []
        const b = cold(
          "     -#                                                        "
        )
        const bsubs: string[] = []
        const c = cold(
          "          -2--3--4--5----6-|                                   "
        )
        const csubs =
          "         --^----------------!                                   "
        const d = cold(
          "                           ----2--3|                           "
        )
        const dsubs =
          "         -------------------^-------!                           "
        const e = cold(
          "                                   -1------2--3-4-5---|        "
        )
        const esubs =
          "         ---------------------------^-----------!               "
        const f = cold(
          "                                                      --|      "
        )
        const fsubs: string[] = []
        const g = cold(
          "                                                        ---1-2|"
        )
        const gsubs: string[] = []
        const e1 = hot(
          "  -a-b--^-c-----d------e----------------f-----g#               "
        )
        const e1subs =
          "        ^--------------------------------------!               "
        const expected =
          "      ---2--3--4--5----6-----2--3-1------2--3#               "
        const observableLookup = { a: a, b: b, c: c, d: d, e: e, f: f, g: g }
        const result = e1.pipe(
          concatMap(
            value => observableLookup[value as keyof typeof observableLookup]
          )
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
        expectSubscriptions(c.subscriptions).toBe(csubs)
        expectSubscriptions(d.subscriptions).toBe(dsubs)
        expectSubscriptions(e.subscriptions).toBe(esubs)
        expectSubscriptions(f.subscriptions).toBe(fsubs)
        expectSubscriptions(g.subscriptions).toBe(gsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should concatMap many complex, all inners complete except one throws", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const a = cold(
          "   -#                                                          "
        )
        const asubs: string[] = []
        const b = cold(
          "     -#                                                        "
        )
        const bsubs: string[] = []
        const c = cold(
          "          -2--3--4--5----6-#                                   "
        )
        const csubs =
          "         --^----------------!                                   "
        const d = cold(
          "                           ----2--3|                           "
        )
        const dsubs: string[] = []
        const e = cold(
          "                                   -1------2--3-4-5---|        "
        )
        const esubs: string[] = []
        const f = cold(
          "                                                      --|      "
        )
        const fsubs: string[] = []
        const g = cold(
          "                                                        ---1-2|"
        )
        const gsubs: string[] = []
        const e1 = hot(
          "  -a-b--^-c-----d------e----------------f-----g|               "
        )
        const e1subs =
          "        ^------------------!                                   "
        const expected =
          "      ---2--3--4--5----6-#                                   "
        const observableLookup = { a: a, b: b, c: c, d: d, e: e, f: f, g: g }
        const result = e1.pipe(
          concatMap(
            value => observableLookup[value as keyof typeof observableLookup]
          )
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
        expectSubscriptions(c.subscriptions).toBe(csubs)
        expectSubscriptions(d.subscriptions).toBe(dsubs)
        expectSubscriptions(e.subscriptions).toBe(esubs)
        expectSubscriptions(f.subscriptions).toBe(fsubs)
        expectSubscriptions(g.subscriptions).toBe(gsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should concatMap many complex, all inners finite, outer is unsubscribed early", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const a = cold(
          "   -#                                                          "
        )
        const asubs: string[] = []
        const b = cold(
          "     -#                                                        "
        )
        const bsubs: string[] = []
        const c = cold(
          "          -2--3--4--5----6-|                                   "
        )
        const csubs =
          "         --^----------------!                                   "
        const d = cold(
          "                           ----2--3|                           "
        )
        const dsubs =
          "         -------------------^-------!                           "
        const e = cold(
          "                                   -1------2--3-4-5---|        "
        )
        const esubs =
          "         ---------------------------^--!                        "
        const f = cold(
          "                                                      --|      "
        )
        const fsubs: string[] = []
        const g = cold(
          "                                                        ---1-2|"
        )
        const gsubs: string[] = []
        const e1 = hot(
          "  -a-b--^-c-----d------e----------------f-----g|               "
        )
        const e1subs =
          "        ^-----------------------------!                        "
        const unsub =
          "         ^-----------------------------!                        "
        const expected =
          "      ---2--3--4--5----6-----2--3-1--                        "
        const observableLookup: Record<string, Observable<string>> = {
          a: a,
          b: b,
          c: c,
          d: d,
          e: e,
          f: f,
          g: g,
        }
        const result = e1.pipe(concatMap(value => observableLookup[value]))
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
        expectSubscriptions(c.subscriptions).toBe(csubs)
        expectSubscriptions(d.subscriptions).toBe(dsubs)
        expectSubscriptions(e.subscriptions).toBe(esubs)
        expectSubscriptions(f.subscriptions).toBe(fsubs)
        expectSubscriptions(g.subscriptions).toBe(gsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const a = cold(
          "   -#                                                          "
        )
        const asubs: string[] = []
        const b = cold(
          "   -#                                                          "
        )
        const bsubs: string[] = []
        const c = cold(
          "          -2--3--4--5----6-|                                   "
        )
        const csubs =
          "         --^----------------!                                   "
        const d = cold(
          "                           ----2--3|                           "
        )
        const dsubs =
          "         -------------------^-------!                           "
        const e = cold(
          "                                   -1------2--3-4-5---|        "
        )
        const esubs =
          "         ---------------------------^--!                        "
        const f = cold(
          "                                                      --|      "
        )
        const fsubs: string[] = []
        const g = cold(
          "                                                        ---1-2|"
        )
        const gsubs: string[] = []
        const e1 = hot(
          "  -a-b--^-c-----d------e----------------f-----g|               "
        )
        const e1subs =
          "        ^-----------------------------!                        "
        const unsub =
          "         ^-----------------------------!                        "
        const expected =
          "      ---2--3--4--5----6-----2--3-1--                        "
        const observableLookup: Record<string, Observable<string>> = {
          a: a,
          b: b,
          c: c,
          d: d,
          e: e,
          f: f,
          g: g,
        }
        const result = e1.pipe(
          mergeMap(x => of(x)),
          concatMap(value => observableLookup[value]),
          mergeMap(x => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
        expectSubscriptions(c.subscriptions).toBe(csubs)
        expectSubscriptions(d.subscriptions).toBe(dsubs)
        expectSubscriptions(e.subscriptions).toBe(esubs)
        expectSubscriptions(f.subscriptions).toBe(fsubs)
        expectSubscriptions(g.subscriptions).toBe(gsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should concatMap many complex, all inners finite, project throws", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const a = cold(
          "   -#                                                          "
        )
        const asubs: string[] = []
        const b = cold(
          "     -#                                                        "
        )
        const bsubs: string[] = []
        const c = cold(
          "          -2--3--4--5----6-|                                   "
        )
        const csubs =
          "         --^----------------!                                   "
        const d = cold(
          "                           ----2--3|                           "
        )
        const dsubs =
          "         -------------------^-------!                           "
        const e = cold(
          "                                   -1------2--3-4-5---|        "
        )
        const esubs: string[] = []
        const f = cold(
          "                                                      --|      "
        )
        const fsubs: string[] = []
        const g = cold(
          "                                                        ---1-2|"
        )
        const gsubs: string[] = []
        const e1 = hot(
          "  -a-b--^-c-----d------e----------------f-----g|               "
        )
        const e1subs =
          "        ^--------------------------!                           "
        const expected =
          "      ---2--3--4--5----6-----2--3#                           "
        const observableLookup: Record<string, Observable<string>> = {
          a: a,
          b: b,
          c: c,
          d: d,
          e: e,
          f: f,
          g: g,
        }
        const result = e1.pipe(
          concatMap(value => {
            if (value === "e") {
              throw "error"
            }
            return observableLookup[value]
          })
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
        expectSubscriptions(c.subscriptions).toBe(csubs)
        expectSubscriptions(d.subscriptions).toBe(dsubs)
        expectSubscriptions(e.subscriptions).toBe(esubs)
        expectSubscriptions(f.subscriptions).toBe(fsubs)
        expectSubscriptions(g.subscriptions).toBe(gsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should finalize before moving to the next observable", () => {
    const results: any[] = []
    const create = (n: number) =>
      defer(() => {
        results.push(`init ${n}`)
        return of(`next ${n}`).pipe(
          delay(100, testScheduler),
          finalize(() => {
            results.push(`finalized ${n}`)
          })
        )
      })
    of(1, 2, 3)
      .pipe(concatMap(n => create(n)))
      .subscribe({
        next: value => results.push(value),
      })
    testScheduler.flush()
    expect(results).to.deep.equal([
      "init 1",
      "next 1",
      "finalized 1",
      "init 2",
      "next 2",
      "finalized 2",
      "init 3",
      "next 3",
      "finalized 3",
    ])
  })
  function arrayRepeat(value: string, times: number) {
    let results = []
    for (let i = 0; i < times; i++) {
      results.push(value)
    }
    return results
  }
  it("should concatMap many outer to an array for each value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  2-----4--------3--------2-------|")
      const e1subs = "  ^-------------------------------!"
      const expected = "(22)--(4444)---(333)----(22)----|"
      const result = e1.pipe(concatMap(value => arrayRepeat(value, +value)))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should concatMap many outer to inner arrays, outer unsubscribed early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  2-----4--------3--------2-------|")
      const e1subs = "  ^------------!                   "
      const unsub = "   ^------------!                   "
      const expected = "(22)--(4444)--                   "
      const result = e1.pipe(concatMap(value => arrayRepeat(value, +value)))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should concatMap many outer to inner arrays, project throws", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  2-----4--------3--------2-------|")
        const e1subs = "  ^--------------!                 "
        const expected = "(22)--(4444)---#                 "
        let invoked = 0
        const result = e1.pipe(
          concatMap(value => {
            invoked++
            if (invoked === 3) {
              throw "error"
            }
            return arrayRepeat(value, +value)
          })
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should map values to constant resolved promises and concatenate", done => {
    const source = from([4, 3, 2, 1])
    const project = (value: number) => from(Promise.resolve(42))
    const results: number[] = []
    source.pipe(concatMap(project)).subscribe({
      next: x => {
        results.push(x)
      },
      error: err => {
        done(new Error("Subscriber error handler not supposed to be called."))
      },
      complete: () => {
        expect(results).to.deep.equal([42, 42, 42, 42])
        done()
      },
    })
  })
  it("should map values to constant rejected promises and concatenate", done => {
    const source = from([4, 3, 2, 1])
    const project = (value: any) => from(Promise.reject(42))
    source.pipe(concatMap(project)).subscribe({
      next: x => {
        done(new Error("Subscriber next handler not supposed to be called."))
      },
      error: err => {
        expect(err).to.deep.equal(42)
        done()
      },
      complete: () => {
        done(
          new Error("Subscriber complete handler not supposed to be called.")
        )
      },
    })
  })
  it("should map values to resolved promises and concatenate", done => {
    const source = from([4, 3, 2, 1])
    const project = (value: number, index: number) =>
      from(Promise.resolve(value + index))
    const results: number[] = []
    source.pipe(concatMap(project)).subscribe({
      next: x => {
        results.push(x)
      },
      error: err => {
        done(new Error("Subscriber error handler not supposed to be called."))
      },
      complete: () => {
        expect(results).to.deep.equal([4, 4, 4, 4])
        done()
      },
    })
  })
  it("should map values to rejected promises and concatenate", done => {
    const source = from([4, 3, 2, 1])
    const project = (value: number, index: number) =>
      from(Promise.reject("" + value + "-" + index))
    source.pipe(concatMap(project)).subscribe({
      next: x => {
        done(new Error("Subscriber next handler not supposed to be called."))
      },
      error: err => {
        expect(err).to.deep.equal("4-0")
        done()
      },
      complete: () => {
        done(
          new Error("Subscriber complete handler not supposed to be called.")
        )
      },
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        concatMap(value => of(value)),
        take(3)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { of, from, Observable } from "rxjs"
import { concatMapTo, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {concatMapTo} */
describe("concatMapTo", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should map-and-flatten each item to an Observable", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --1-----3--5-------|")
        const e1subs = "  ^------------------!"
        const e2 = cold(" x-x-x|              ", { x: 10 })
        const expected = "--x-x-x-x-x-xx-x-x-|"
        const values = { x: 10 }
        const result = e1.pipe(concatMapTo(e2))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should support the deprecated resultSelector", () => {
    const results: Array<number[]> = []
    of(1, 2, 3)
      .pipe(concatMapTo(of(4, 5, 6), (a, b, i, ii) => [a, b, i, ii]))
      .subscribe({
        next(value) {
          results.push(value)
        },
        error(err) {
          throw err
        },
        complete() {
          expect(results).to.deep.equal([
            [1, 4, 0, 0],
            [1, 5, 0, 1],
            [1, 6, 0, 2],
            [2, 4, 1, 0],
            [2, 5, 1, 1],
            [2, 6, 1, 2],
            [3, 4, 2, 0],
            [3, 5, 2, 1],
            [3, 6, 2, 2],
          ])
        },
      })
  })
  it("should support a void resultSelector (still deprecated)", () => {
    const results: number[] = []
    of(1, 2, 3)
      .pipe(concatMapTo(of(4, 5, 6), void 0))
      .subscribe({
        next(value) {
          results.push(value)
        },
        error(err) {
          throw err
        },
        complete() {
          expect(results).to.deep.equal([4, 5, 6, 4, 5, 6, 4, 5, 6])
        },
      })
  })
  it("should concatMapTo many outer values to many inner values", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = { i: "foo", j: "bar", k: "baz", l: "qux" }
        const e1 = hot("    -a---b---c---d---|                        ")
        const e1subs = "    ^----------------!                        "
        const inner = cold("--i-j-k-l-|                               ", values)
        const innerSubs = [
          "                 -^---------!                              ",
          "                 -----------^---------!                    ",
          "                 ---------------------^---------!          ",
          "                 -------------------------------^---------!",
        ]
        const expected = "  ---i-j-k-l---i-j-k-l---i-j-k-l---i-j-k-l-|"
        const result = e1.pipe(concatMapTo(inner))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(inner.subscriptions).toBe(innerSubs)
      }
    )
  })
  it("should handle an empty source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |")
      const e1subs = "  (^!)"
      const inner = cold("-1-2-3|")
      const innerSubs: string[] = []
      const expected = "|"
      const result = e1.pipe(concatMapTo(inner))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(inner.subscriptions).toBe(innerSubs)
    })
  })
  it("should handle a never source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const inner = cold("-1-2-3|")
      const innerSubs: string[] = []
      const expected = "-"
      const result = e1.pipe(concatMapTo(inner))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(inner.subscriptions).toBe(innerSubs)
    })
  })
  it("should error immediately if given a just-throw source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #")
      const e1subs = "  (^!)"
      const inner = cold("-1-2-3|")
      const innerSubs: string[] = []
      const expected = "#"
      const result = e1.pipe(concatMapTo(inner))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(inner.subscriptions).toBe(innerSubs)
    })
  })
  it("should return a silenced version of the source if the mapped inner is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("   --a-b--c-|")
      const e1subs = "    ^--------!"
      const inner = cold("|")
      // prettier-ignore
      const innerSubs = [
        '                 --(^!)     ',
        '                 ----(^!)   ',
        '                 -------(^!)',
      ];
      const expected = "  ---------|"
      const result = e1.pipe(concatMapTo(inner))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(inner.subscriptions).toBe(innerSubs)
    })
  })
  it("should return a never if the mapped inner is never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("   --a-b--c-|")
      const e1subs = "    ^--------!"
      const inner = cold("-")
      const innerSubs = " --^       "
      const expected = "  ----------"
      const result = e1.pipe(concatMapTo(inner))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(inner.subscriptions).toBe(innerSubs)
    })
  })
  it("should propagate errors if the mapped inner is a just-throw Observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("   --a-b--c-|")
      const e1subs = "    ^-!       "
      const inner = cold("#")
      const innerSubs = " --(^!)    "
      const expected = "  --#"
      const result = e1.pipe(concatMapTo(inner))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(inner.subscriptions).toBe(innerSubs)
    })
  })
  it("should concatMapTo many outer to many inner, complete late", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = { i: "foo", j: "bar", k: "baz", l: "qux" }
        const e1 = hot("    -a---b---c---d----------------------------------|")
        const e1subs = "    ^-----------------------------------------------!"
        const inner = cold(
          "--i-j-k-l-|                                      ",
          values
        )
        const innerSubs = [
          "                 -^---------!                                     ",
          "                 -----------^---------!                           ",
          "                 ---------------------^---------!                 ",
          "                 -------------------------------^---------!       ",
        ]
        const expected = "  ---i-j-k-l---i-j-k-l---i-j-k-l---i-j-k-l--------|"
        const result = e1.pipe(concatMapTo(inner))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(inner.subscriptions).toBe(innerSubs)
      }
    )
  })
  it("should concatMapTo many outer to many inner, outer never completes", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = { i: "foo", j: "bar", k: "baz", l: "qux" }
        const e1 = hot("    -a---b---c---d-----------------------------------")
        const e1subs = "    ^------------------------------------------------"
        const inner = cold(
          "--i-j-k-l-|                                      ",
          values
        )
        const innerSubs = [
          "                 -^---------!                                     ",
          "                 -----------^---------!                           ",
          "                 ---------------------^---------!                 ",
          "                 -------------------------------^---------!       ",
        ]
        const expected = "  ---i-j-k-l---i-j-k-l---i-j-k-l---i-j-k-l---------"
        const result = e1.pipe(concatMapTo(inner))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(inner.subscriptions).toBe(innerSubs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = { i: "foo", j: "bar", k: "baz", l: "qux" }
        const e1 = hot("    -a---b---c---d---| ")
        const e1subs = "    ^----------------! "
        const inner = cold("--i-j-k-l-|        ", values)
        // prettier-ignore
        const innerSubs = [
        '                 -^---------!       ',
        '                 -----------^------!',
      ];
        const expected = "  ---i-j-k-l---i-j-k-"
        const unsub = "     ------------------!"
        const result = e1.pipe(
          mergeMap(x => of(x)),
          concatMapTo(inner),
          mergeMap(x => of(x))
        )
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(inner.subscriptions).toBe(innerSubs)
      }
    )
  })
  it("should concatMapTo many outer to many inner, inner never completes", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = { i: "foo", j: "bar", k: "baz", l: "qux" }
        const e1 = hot("    -a---b---c---d---|")
        const e1subs = "    ^----------------!"
        const inner = cold("--i-j-k-l-        ", values)
        const innerSubs = " -^                "
        const expected = "  ---i-j-k-l--------"
        const result = e1.pipe(concatMapTo(inner))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(inner.subscriptions).toBe(innerSubs)
      }
    )
  })
  it("should concatMapTo many outer to many inner, and inner throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = { i: "foo", j: "bar", k: "baz", l: "qux" }
        const e1 = hot("    -a---b---c---d---|")
        const e1subs = "    ^----------!      "
        const inner = cold("--i-j-k-l-#       ", values)
        const innerSubs = " -^---------!      "
        const expected = "  ---i-j-k-l-#      "
        const result = e1.pipe(concatMapTo(inner))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(inner.subscriptions).toBe(innerSubs)
      }
    )
  })
  it("should concatMapTo many outer to many inner, and outer throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = { i: "foo", j: "bar", k: "baz", l: "qux" }
        const e1 = hot("    -a---b---c---d---#")
        const e1subs = "    ^----------------!"
        const inner = cold("--i-j-k-l-|       ", values)
        // prettier-ignore
        const innerSubs = [
        '                 -^---------!      ',
        '                 -----------^-----!',
      ];
        const expected = "  ---i-j-k-l---i-j-#"
        const result = e1.pipe(concatMapTo(inner))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(inner.subscriptions).toBe(innerSubs)
      }
    )
  })
  it("should concatMapTo many outer to many inner, both inner and outer throw", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = { i: "foo", j: "bar", k: "baz", l: "qux" }
        const e1 = hot("    -a---b---c---d---#")
        const e1subs = "    ^----------!      "
        const inner = cold("--i-j-k-l-#       ", values)
        const innerSubs = " -^---------!      "
        const expected = "  ---i-j-k-l-#      "
        const result = e1.pipe(concatMapTo(inner))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(inner.subscriptions).toBe(innerSubs)
      }
    )
  })
  it("should concatMapTo many outer to an array", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const e1 = hot("  2-----4--------3--------2-------|")
      const expected = "(0123)(0123)---(0123)---(0123)--|"
      const result = e1.pipe(concatMapTo(["0", "1", "2", "3"]))
      expectObservable(result).toBe(expected)
    })
  })
  it("should concatMapTo many outer to inner arrays, and outer throws", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const e1 = hot("  2-----4--------3--------2-------#")
      const expected = "(0123)(0123)---(0123)---(0123)--#"
      const result = e1.pipe(concatMapTo(["0", "1", "2", "3"]))
      expectObservable(result).toBe(expected)
    })
  })
  it("should concatMapTo many outer to inner arrays, outer unsubscribed early", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const e1 = hot("  2-----4--------3--------2-------|")
      const unsub = "   -------------!"
      const expected = "(0123)(0123)--"
      const result = e1.pipe(concatMapTo(["0", "1", "2", "3"]))
      expectObservable(result, unsub).toBe(expected)
    })
  })
  it("should map values to constant resolved promises and concatenate", done => {
    const source = from([4, 3, 2, 1])
    const results: number[] = []
    source.pipe(concatMapTo(from(Promise.resolve(42)))).subscribe({
      next: x => {
        results.push(x)
      },
      error: err => {
        done(new Error("Subscriber error handler not supposed to be called."))
      },
      complete: () => {
        expect(results).to.deep.equal([42, 42, 42, 42])
        done()
      },
    })
  })
  it("should map values to constant rejected promises and concatenate", done => {
    const source = from([4, 3, 2, 1])
    source.pipe(concatMapTo(from(Promise.reject(42)))).subscribe({
      next: x => {
        done(new Error("Subscriber next handler not supposed to be called."))
      },
      error: err => {
        expect(err).to.equal(42)
        done()
      },
      complete: () => {
        done(
          new Error("Subscriber complete handler not supposed to be called.")
        )
      },
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(concatMapTo(of(0)), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { of, Observable } from "rxjs"
import { concatWith, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { NO_SUBS } from "../helpers/test-helper"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {concat} */
describe("concat operator", () => {
  let rxTest: TestScheduler
  beforeEach(() => {
    rxTest = new TestScheduler(observableMatcher)
  })
  it("should concatenate two cold observables", () => {
    rxTest.run(({ cold, expectObservable }) => {
      const e1 = cold(" --a--b-|")
      const e2 = cold("        --x---y--|")
      const expected = "--a--b---x---y--|"
      expectObservable(e1.pipe(concatWith(e2))).toBe(expected)
    })
  })
  it("should work properly with scalar observables", done => {
    const results: string[] = []
    const s1 = new Observable<number>(observer => {
      setTimeout(() => {
        observer.next(1)
        observer.complete()
      })
    }).pipe(concatWith(of(2)))
    s1.subscribe({
      next: x => {
        results.push("Next: " + x)
      },
      error: x => {
        done(new Error("should not be called"))
      },
      complete: () => {
        results.push("Completed")
        expect(results).to.deep.equal(["Next: 1", "Next: 2", "Completed"])
        done()
      },
    })
  })
  it("should complete without emit if both sources are empty", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --|")
      const e1subs = "  ^-!"
      const e2 = cold("   ----|")
      const e2subs = "  --^---!"
      const expected = "------|"
      expectObservable(e1.pipe(concatWith(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not complete if first source does not completes", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---")
      const e1subs = "  ^--"
      const e2 = cold("    --|")
      const e2subs = NO_SUBS
      const expected = "---"
      expectObservable(e1.pipe(concatWith(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not complete if second source does not completes", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --|")
      const e1subs = "  ^-!"
      const e2 = cold("   ---")
      const e2subs = "  --^--"
      const expected = "-----"
      expectObservable(e1.pipe(concatWith(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not complete if both sources do not complete", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---")
      const e1subs = "  ^--"
      const e2 = cold("    ---")
      const e2subs = NO_SUBS
      const expected = "---"
      expectObservable(e1.pipe(concatWith(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise error when first source is empty, second source raises error", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --|")
      const e1subs = "  ^-!"
      const e2 = cold("   ----#")
      const e2subs = "  --^---!"
      const expected = "------#"
      expectObservable(e1.pipe(concatWith(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise error when first source raises error, second source is empty", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---#")
      const e1subs = "  ^--!"
      const e2 = cold("    ----|")
      const expected = "---#"
      const e2subs = NO_SUBS
      expectObservable(e1.pipe(concatWith(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise first error when both source raise error", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---#")
      const e1subs = "  ^--!"
      const e2 = cold("    ------#")
      const expected = "---#"
      const e2subs = NO_SUBS
      expectObservable(e1.pipe(concatWith(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should concat if first source emits once, second source is empty", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a--|")
      const e1subs = "  ^----!"
      const e2 = cold("      --------|")
      const e2subs = "  -----^-------!"
      const expected = "--a----------|"
      expectObservable(e1.pipe(concatWith(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should concat if first source is empty, second source emits once", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --|")
      const e1subs = "  ^-!"
      const e2 = cold("   --a--|")
      const e2subs = "  --^----!"
      const expected = "----a--|"
      expectObservable(e1.pipe(concatWith(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should emit element from first source, and should not complete if second source does not completes", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a--|")
      const e1subs = "  ^----!"
      const e2 = cold("      ---")
      const e2subs = "  -----^--"
      const expected = "--a-----"
      expectObservable(e1.pipe(concatWith(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not complete if first source does not complete", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---")
      const e1subs = "  ^--"
      const e2 = cold("    --a--|")
      const e2subs = NO_SUBS
      const expected = "---"
      expectObservable(e1.pipe(concatWith(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should emit elements from each source when source emit once", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---a|")
      const e1subs = "  ^---!"
      const e2 = cold("     -----b--|")
      const e2subs = "  ----^-------!"
      const expected = "---a-----b--|"
      expectObservable(e1.pipe(concatWith(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should unsubscribe to inner source if outer is unsubscribed early", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  ---a-a--a|            ")
      const e1subs = "   ^--------!            "
      const e2 = cold("           -----b-b--b-|")
      const e2subs = "   ---------^-------!"
      const unsub = "    -----------------!  "
      const expected = " ---a-a--a-----b-b     "
      expectObservable(e1.pipe(concatWith(e2)), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---a-a--a|            ")
      const e1subs = "  ^--------!            "
      const e2 = cold("          -----b-b--b-|")
      const e2subs = "  ---------^--------!    "
      const expected = "---a-a--a-----b-b-    "
      const unsub = "   ------------------!    "
      const result = e1.pipe(
        mergeMap(x => of(x)),
        concatWith(e2),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise error from first source and does not emit from second source", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --#")
      const e1subs = "  ^-!"
      const e2 = cold("   ----a--|")
      const e2subs = NO_SUBS
      const expected = "--#"
      expectObservable(e1.pipe(concatWith(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should emit element from first source then raise error from second source", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a--|")
      const e1subs = "  ^----!"
      const e2 = cold("      -------#")
      const e2subs = "  -----^------!"
      const expected = "--a---------#"
      expectObservable(e1.pipe(concatWith(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should emit all elements from both hot observable sources if first source completes before second source starts emit", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b-|")
      const e1subs = "  ^------!"
      const e2 = hot("  --------x--y--|")
      const e2subs = "  -------^------!"
      const expected = "--a--b--x--y--|"
      expectObservable(e1.pipe(concatWith(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should emit elements from second source regardless of completion time when second source is cold observable", () => {
    rxTest.run(({ hot, cold, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c---|")
      const e1subs = "  ^-----------!"
      const e2 = cold("           -x-y-z-|")
      const e2subs = "  ------------^------!"
      const expected = "--a--b--c----x-y-z-|"
      expectObservable(e1.pipe(concatWith(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not emit collapsing element from second source", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^----------!"
      const e2 = hot("  --------x--y--z--|")
      const e2subs = "  -----------^-----!"
      const expected = "--a--b--c--y--z--|"
      expectObservable(e1.pipe(concatWith(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should emit self without parameters", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---a-|")
      const e1subs = "  ^----!"
      const expected = "---a-|"
      expectObservable(e1.pipe(concatWith())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(concatWith(of(0)), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { BehaviorSubject, merge } from "rxjs"
import { connect, delay } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
describe("connect", () => {
  let rxTest: TestScheduler
  beforeEach(() => {
    rxTest = new TestScheduler(observableMatcher)
  })
  it("should connect a source through a selector function", () => {
    rxTest.run(({ cold, time, expectObservable }) => {
      const source = cold("---a----b-----c---|")
      const d = time("        ---|")
      const expected = "   ---a--a-b--b--c--c|"
      const result = source.pipe(
        connect(shared => merge(shared.pipe(delay(d)), shared))
      )
      expectObservable(result).toBe(expected)
    })
  })
  it("should connect a source through a selector function and use the provided connector", () => {
    rxTest.run(({ cold, time, expectObservable }) => {
      const source = cold("--------a---------b---------c-----|")
      const d = time("             ---|")
      const expected = "   S--S----a--a------b--b------c--c--|"
      const result = source.pipe(
        connect(
          shared => {
            return merge(shared.pipe(delay(d)), shared)
          },
          {
            connector: () => new BehaviorSubject("S"),
          }
        )
      )
      expectObservable(result).toBe(expected)
    })
  })
})
import { expect } from "chai"
import { of, range } from "rxjs"
import { count, skip, take, mergeMap } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {count} */
describe("count", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should count the values of an observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b--c--|")
      const subs = "      ^----------!"
      const expected = "  -----------(x|)"
      expectObservable(source.pipe(count())).toBe(expected, { x: 3 })
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should be never when source is never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(count())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should be zero when source is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |")
      const e1subs = "  (^!)"
      const expected = "(w|)"
      expectObservable(e1.pipe(count())).toBe(expected, { w: 0 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should be never when source doesn't complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--x--^--y--")
      const e1subs = "     ^     "
      const expected = "   ------"
      expectObservable(e1.pipe(count())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should be zero when source doesn't have values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^---|")
      const e1subs = "   ^---!"
      const expected = " ----(w|)"
      expectObservable(e1.pipe(count())).toBe(expected, { w: 0 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should count the unique value of an observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^--y--|")
      const e1subs = "   ^-----!"
      const expected = " ------(w|)"
      expectObservable(e1.pipe(count())).toBe(expected, { w: 1 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should count the values of an ongoing hot observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a-^-b--c--d--|")
      const subs = "          ^----------!"
      const expected = "      -----------(x|)"
      expectObservable(source.pipe(count())).toBe(expected, { x: 3 })
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should count a range() source observable", done => {
    range(1, 10)
      .pipe(count())
      .subscribe({
        next: (value: number) => {
          expect(value).to.equal(10)
        },
        error: x => {
          done(new Error("should not be called"))
        },
        complete: () => {
          done()
        },
      })
  })
  it("should count a range().skip(1) source observable", done => {
    range(1, 10)
      .pipe(skip(1), count())
      .subscribe({
        next: (value: number) => {
          expect(value).to.equal(9)
        },
        error: x => {
          done(new Error("should not be called"))
        },
        complete: () => {
          done()
        },
      })
  })
  it("should count a range().take(1) source observable", done => {
    range(1, 10)
      .pipe(take(1), count())
      .subscribe({
        next: (value: number) => {
          expect(value).to.equal(1)
        },
        error: x => {
          done(new Error("should not be called"))
        },
        complete: () => {
          done()
        },
      })
  })
  it("should work with error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^--y--z--#", { x: 1, y: 2, z: 3 }, "too bad")
      const e1subs = "   ^--------!"
      const expected = " ---------#"
      expectObservable(e1.pipe(count())).toBe(expected, null, "too bad")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work with throw", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #")
      const e1subs = "  (^!)"
      const expected = "#"
      expectObservable(e1.pipe(count())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle an always-true predicate on an empty hot observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^---|")
      const e1subs = "   ^---!"
      const expected = " ----(w|)"
      const predicate = () => {
        return true
      }
      expectObservable(e1.pipe(count(predicate))).toBe(expected, { w: 0 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle an always-false predicate on an empty hot observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^---|")
      const e1subs = "   ^---!"
      const expected = " ----(w|)"
      const predicate = () => {
        return false
      }
      expectObservable(e1.pipe(count(predicate))).toBe(expected, { w: 0 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle an always-true predicate on a simple hot observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^-a-|")
      const e1subs = "   ^---!"
      const expected = " ----(w|)"
      const predicate = () => {
        return true
      }
      expectObservable(e1.pipe(count(predicate))).toBe(expected, { w: 1 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle an always-false predicate on a simple hot observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^-a-|")
      const e1subs = "   ^---!"
      const expected = " ----(w|)"
      const predicate = () => {
        return false
      }
      expectObservable(e1.pipe(count(predicate))).toBe(expected, { w: 0 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1-^-2--3--4-|")
      const e1subs = "   ^-----!    "
      const expected = " -------    "
      const unsub = "    ------!    "
      const result = e1.pipe(count((value: string) => parseInt(value) < 10))
      expectObservable(result, unsub).toBe(expected, { w: 3 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1-^-2--3--4-|")
      const e1subs = "   ^-----!    "
      const expected = " -------    "
      const unsub = "    ------!    "
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        count((value: string) => parseInt(value) < 10),
        mergeMap((x: number) => of(x))
      )
      expectObservable(result, unsub).toBe(expected, { w: 3 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a match-all predicate on observable with many values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1-^-2--3--4-|")
      const e1subs = "   ^---------!"
      const expected = " ----------(w|)"
      const predicate = (value: string) => parseInt(value) < 10
      expectObservable(e1.pipe(count(predicate))).toBe(expected, { w: 3 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a match-none predicate on observable with many values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1-^-2--3--4-|")
      const e1subs = "   ^---------!"
      const expected = " ----------(w|)"
      const predicate = (value: string) => parseInt(value) > 10
      expectObservable(e1.pipe(count(predicate))).toBe(expected, { w: 0 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle an always-true predicate on observable that throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1-^---#")
      const e1subs = "   ^---!"
      const expected = " ----#"
      const predicate = () => true
      expectObservable(e1.pipe(count(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle an always-false predicate on observable that throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1-^---#")
      const e1subs = "   ^---!"
      const expected = " ----#"
      const predicate = () => false
      expectObservable(e1.pipe(count(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle an always-true predicate on a hot never-observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^----")
      const e1subs = "   ^    "
      const expected = " -----"
      const predicate = () => true
      expectObservable(e1.pipe(count(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a predicate that throws, on observable with many values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1-^-2--3--|")
      const e1subs = "   ^----!   "
      const expected = " -----#   "
      const predicate = (value: string) => {
        if (value === "3") {
          throw "error"
        }
        return true
      }
      expectObservable(e1.pipe(count(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
})
import { expect } from "chai"
import { NEVER, timer, of, EMPTY, concat, Subject, Observable } from "rxjs"
import { debounce, mergeMap, mapTo, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {debounce} */
describe("debounce", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  function getTimerSelector(x: number) {
    return () => timer(x, testScheduler)
  }
  it("should debounce values by a specified cold Observable", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a----bc----d-ef----|")
        const e1subs = "  ^-------------------!"
        const e2 = cold("  ---x                ")
        //                       ---x
        //                               ---x
        const e2subs = [
          "               -^--!                ",
          "               ------^!             ",
          "               -------^--!          ",
          "               ------------^-!      ",
          "               --------------^!     ",
          "               ---------------^--!  ",
        ]
        const expected = "----a-----c-------f-|"
        const result = e1.pipe(debounce(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should delay all element by selector observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d---------|")
      const e1subs = "  ^--------------------!"
      const expected = "----a--b--c--d-------|"
      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should debounce by selector observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--bc--d----|")
      const e1subs = "  ^-------------!"
      const expected = "----a---c--d--|"
      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should support a scalar selector observable", () => {
    // If the selector returns a scalar observable, the debounce operator
    // should emit the value immediately.
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--bc--d----|")
      const e1subs = "  ^-------------!"
      const expected = "--a--bc--d----|"
      expectObservable(e1.pipe(debounce(() => of(0)))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should complete when source does not emit", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -----|")
      const e1subs = "  ^----!"
      const expected = "-----|"
      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should complete when source is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |")
      const e1subs = "  (^!)"
      const expected = "|"
      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error when source does not emit and raises error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -----#")
      const e1subs = "  ^----!"
      const expected = "-----#"
      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error when source throws", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #")
      const e1subs = "  (^!)"
      const expected = "#"
      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--bc--d----|")
      const e1subs = "  ^------!       "
      const expected = "----a---       "
      const unsub = "   -------!       "
      const result = e1.pipe(debounce(getTimerSelector(2)))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--bc--d----|")
      const e1subs = "  ^------!       "
      const expected = "----a---       "
      const unsub = "   -------!       "
      const result = e1.pipe(
        mergeMap((x: any) => of(x)),
        debounce(getTimerSelector(2)),
        mergeMap((x: any) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should debounce and does not complete when source does not completes", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--bc--d---")
      const e1subs = "  ^            "
      const expected = "----a---c--d-"
      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not complete when source does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not completes when source never completes", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should delay all element until source raises error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d---------#")
      const e1subs = "  ^--------------------!"
      const expected = "----a--b--c--d-------#"
      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should debounce all elements while source emits by selector observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---a---b---c---d---e|")
      const e1subs = "  ^-------------------!"
      const expected = "--------------------(e|)"
      expectObservable(e1.pipe(debounce(getTimerSelector(4)))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should debounce all element while source emits by selector observable until raises error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d-#")
      const e1subs = "  ^------------!"
      const expected = "-------------#"
      expectObservable(e1.pipe(debounce(getTimerSelector(5)))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should delay element by same selector observable emits multiple", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("       ----a--b--c----d-----e-------|")
        const e1subs = "       ^----------------------------!"
        const expected = "     ------a--b--c----d-----e-----|"
        const selector = cold("--x-y-")
        const selectorSubs = [
          "                    ----^-!                      ",
          "                    -------^-!                   ",
          "                    ----------^-!                ",
          "                    ---------------^-!           ",
          "                    ---------------------^-!     ",
        ]
        expectObservable(e1.pipe(debounce(() => selector))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(selector.subscriptions).toBe(selectorSubs)
      }
    )
  })
  it("should debounce by selector observable emits multiple", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ----a--b--c----d-----e-------|")
        const e1subs = "  ^----------------------------!"
        const expected = "------a-----c----------e-----|"
        const selector = [
          cold("              --x-y-                    "),
          cold("                 ----x-y-               "),
          cold("                    --x-y-              "),
          cold("                         ------x-y-     "),
          cold("                               --x-y-   "),
        ]
        const selectorSubs = [
          "               ----^-!                       ",
          "               -------^--!                   ",
          "               ----------^-!                 ",
          "               ---------------^-----!        ",
          "               ---------------------^-!      ",
        ]
        expectObservable(e1.pipe(debounce(() => selector.shift()!))).toBe(
          expected
        )
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        for (let i = 0; i < selectorSubs.length; i++) {
          expectSubscriptions(selector[i].subscriptions).toBe(selectorSubs[i])
        }
      }
    )
  })
  it("should debounce by selector observable until source completes", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ----a--b--c----d----e|    ")
        const e1subs = "  ^--------------------!    "
        const expected = "------a-----c--------(e|) "
        const selector = [
          cold("              --x-y-                "),
          cold("                 ----x-y-           "),
          cold("                    --x-y-          "),
          cold("                         ------x-y- "),
          cold("                              --x-y-"),
        ]
        const selectorSubs = [
          "               ----^-!                   ",
          "               -------^--!               ",
          "               ----------^-!             ",
          "               ---------------^----!     ",
          "               --------------------^!    ",
        ]
        expectObservable(e1.pipe(debounce(() => selector.shift()!))).toBe(
          expected
        )
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        for (let i = 0; i < selectorSubs.length; i++) {
          expectSubscriptions(selector[i].subscriptions).toBe(selectorSubs[i])
        }
      }
    )
  })
  it("should raise error when selector observable raises error", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --------a--------b--------c---------|")
        const e1subs = "  ^----------------------------!       "
        const expected = "---------a---------b---------#       "
        const selector = [
          cold("                  -x-y-                        "),
          cold("                           --x-y-              "),
          cold("                                    ---#       "),
        ]
        const selectorSubs = [
          "               --------^!                           ",
          "               -----------------^-!                 ",
          "               --------------------------^--!       ",
        ]
        expectObservable(e1.pipe(debounce(() => selector.shift()!))).toBe(
          expected
        )
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        for (let i = 0; i < selectorSubs.length; i++) {
          expectSubscriptions(selector[i].subscriptions).toBe(selectorSubs[i])
        }
      }
    )
  })
  it("should raise error when source raises error with selector observable", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --------a--------b--------c---------d#      ")
        const e1subs = "  ^------------------------------------!      "
        const expected = "---------a---------b---------c-------#      "
        const selector = [
          cold("                  -x-y-                               "),
          cold("                           --x-y-                     "),
          cold("                                    ---x-y-           "),
          cold("                                              ----x-y-"),
        ]
        const selectorSubs = [
          "               --------^!                                  ",
          "               -----------------^-!                        ",
          "               --------------------------^--!              ",
          "               ------------------------------------^!      ",
        ]
        expectObservable(e1.pipe(debounce(() => selector.shift()!))).toBe(
          expected
        )
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        for (let i = 0; i < selectorSubs.length; i++) {
          expectSubscriptions(selector[i].subscriptions).toBe(selectorSubs[i])
        }
      }
    )
  })
  it("should raise error when selector function throws", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --------a--------b--------c---------|")
        const e1subs = "  ^-------------------------!          "
        const expected = "---------a---------b------#          "
        // prettier-ignore
        const selector = [
        cold('                  -x-y-                        '),
        cold('                           --x-y-              '),
      ];
        // prettier-ignore
        const selectorSubs = [
        '               --------^!                           ',
        '               -----------------^-!                 ',
      ];
        function selectorFunction(x: string) {
          if (x !== "c") {
            return selector.shift()
          } else {
            throw "error"
          }
        }
        expectObservable(e1.pipe(debounce(selectorFunction as any))).toBe(
          expected
        )
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        for (let i = 0; i < selectorSubs.length; i++) {
          expectSubscriptions(selector[i].subscriptions).toBe(selectorSubs[i])
        }
      }
    )
  })
  it("should ignore all values except last, when given an empty selector Observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --------a-x-yz---bxy---z--c--x--y--z|   ")
      const e1subs = "  ^-----------------------------------!   "
      const expected = "------------------------------------(z|)"
      function selectorFunction(x: string) {
        return EMPTY
      }
      expectObservable(e1.pipe(debounce(selectorFunction))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should ignore all values except last, when given a never selector Observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --------a-x-yz---bxy---z--c--x--y--z|  ")
      const e1subs = "  ^-----------------------------------!  "
      const expected = "------------------------------------(z|)"
      function selectorFunction() {
        return NEVER
      }
      expectObservable(e1.pipe(debounce(selectorFunction))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not delay by selector observable completes when it does not emits", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --------a--------b--------c---------|   ")
        const e1subs = "  ^-----------------------------------!   "
        const expected = "------------------------------------(c|)"
        const selector = [
          cold("                  -|                              "),
          cold("                           --|                    "),
          cold("                                    ---|          "),
        ]
        const selectorSubs = [
          "               --------^!                              ",
          "               -----------------^-!                    ",
          "               --------------------------^--!          ",
        ]
        expectObservable(e1.pipe(debounce(() => selector.shift()!))).toBe(
          expected
        )
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        for (let i = 0; i < selectorSubs.length; i++) {
          expectSubscriptions(selector[i].subscriptions).toBe(selectorSubs[i])
        }
      }
    )
  })
  it("should not debounce by selector observable completes when it does not emits", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ----a--b-c---------de-------------|   ")
        const e1subs = "  ^---------------------------------!   "
        const expected = "----------------------------------(e|)"
        const selector = [
          cold("              -|                                "),
          cold("                 --|                            "),
          cold("                   ---|                         "),
          cold("                             ----|              "),
          cold("                              -----|            "),
        ]
        const selectorSubs = [
          "               ----^!                                ",
          "               -------^-!                            ",
          "               ---------^--!                         ",
          "               -------------------^!                 ",
          "               --------------------^----!            ",
        ]
        expectObservable(e1.pipe(debounce(() => selector.shift()!))).toBe(
          expected
        )
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        for (let i = 0; i < selectorSubs.length; i++) {
          expectSubscriptions(selector[i].subscriptions).toBe(selectorSubs[i])
        }
      }
    )
  })
  it("should delay by promise resolves", done => {
    const e1 = concat(
      of(1),
      timer(10).pipe(mapTo(2)),
      timer(10).pipe(mapTo(3)),
      timer(100).pipe(mapTo(4))
    )
    const expected = [1, 2, 3, 4]
    e1.pipe(
      debounce(() => {
        return new Promise((resolve: any) => {
          resolve(42)
        })
      })
    ).subscribe({
      next: (x: number) => {
        expect(x).to.equal(expected.shift())
      },
      error: x => {
        done(new Error("should not be called"))
      },
      complete: () => {
        expect(expected.length).to.equal(0)
        done()
      },
    })
  })
  it("should raises error when promise rejects", done => {
    const e1 = concat(
      of(1),
      timer(10).pipe(mapTo(2)),
      timer(10).pipe(mapTo(3)),
      timer(100).pipe(mapTo(4))
    )
    const expected = [1, 2]
    const error = new Error("error")
    e1.pipe(
      debounce((x: number) => {
        if (x === 3) {
          return new Promise((resolve: any, reject: any) => {
            reject(error)
          })
        } else {
          return new Promise((resolve: any) => {
            resolve(42)
          })
        }
      })
    ).subscribe({
      next: (x: number) => {
        expect(x).to.equal(expected.shift())
      },
      error: (err: any) => {
        expect(err).to.be.an("error", "error")
        expect(expected.length).to.equal(0)
        done()
      },
      complete: () => {
        done(new Error("should not be called"))
      },
    })
  })
  it("should debounce correctly when synchronously reentered", () => {
    const results: number[] = []
    const source = new Subject<number>()
    source.pipe(debounce(() => of(null))).subscribe(value => {
      results.push(value)
      if (value === 1) {
        source.next(2)
      }
    })
    source.next(1)
    expect(results).to.deep.equal([1, 2])
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        debounce(() => of(0)),
        take(3)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { NEVER, of, Subject } from "rxjs"
import { AnimationFrameAction } from "rxjs/internal/scheduler/AnimationFrameAction"
import { AnimationFrameScheduler } from "rxjs/internal/scheduler/AnimationFrameScheduler"
import { debounceTime, mergeMap, startWith } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { VirtualTimeScheduler } from "../../src/internal/scheduler/VirtualTimeScheduler"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {debounceTime} */
describe("debounceTime", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should debounce values by 2 time units", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a--bc--d---|")
        const e1subs = "  ^-----------!"
        const expected = "---a---c--d-|"
        const t = time("  --|")
        expectObservable(e1.pipe(debounceTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should delay all elements by the specified time", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a--------b------c----|")
        const e1subs = "  ^---------------------!"
        const expected = "------a--------b------(c|)"
        const t = time("  -----|")
        expectObservable(e1.pipe(debounceTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should debounce and delay element by the specified time", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a--(bc)-----------d-------|")
        const e1subs = "  ^--------------------------!"
        const expected = "---------c--------------d--|"
        const t = time("  -----|")
        expectObservable(e1.pipe(debounceTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should complete when source does not emit", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -----|")
        const e1subs = "  ^----!"
        const expected = "-----|"
        const t = time("  -|")
        expectObservable(e1.pipe(debounceTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should complete when source is empty", () => {
    testScheduler.run(
      ({ cold, time, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" |")
        const e1subs = "  (^!)"
        const expected = "|"
        const t = time("  -|")
        expectObservable(e1.pipe(debounceTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should raise error when source does not emit and raises error", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -----#")
        const e1subs = "  ^----!"
        const expected = "-----#"
        const t = time("  -|")
        expectObservable(e1.pipe(debounceTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should raise error when source throws", () => {
    testScheduler.run(
      ({ cold, time, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" #")
        const e1subs = "  (^!)"
        const expected = "#"
        const t = time("  -|")
        expectObservable(e1.pipe(debounceTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--bc--d----|")
        const e1subs = "  ^------!       "
        const expected = "----a---       "
        const unsub = "   -------!       "
        const t = time("  --|")
        const result = e1.pipe(debounceTime(t))
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not break unsubscription chains when unsubscribed explicitly", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--bc--d----|")
        const e1subs = "  ^------!       "
        const expected = "----a---       "
        const unsub = "   -------!       "
        const t = time("  --|")
        const result = e1.pipe(
          mergeMap((x: any) => of(x)),
          debounceTime(t),
          mergeMap((x: any) => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should debounce and does not complete when source does not completes", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a--(bc)-----------d-------")
        const e1subs = "  ^--------------------------"
        const expected = "---------c--------------d--"
        const t = time("  -----|")
        expectObservable(e1.pipe(debounceTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not completes when source does not completes", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -")
        const e1subs = "  ^"
        const expected = "-"
        const t = time("  -|")
        expectObservable(e1.pipe(debounceTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not completes when source never completes", () => {
    testScheduler.run(
      ({ cold, time, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" -")
        const e1subs = "  ^"
        const expected = "-"
        const t = time("  -|")
        expectObservable(e1.pipe(debounceTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should delay all elements until source raises error", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a--------b------c----#")
        const e1subs = "  ^---------------------!"
        const expected = "------a--------b------#"
        const t = time("  -----|")
        expectObservable(e1.pipe(debounceTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should debounce all elements while source emits within given time", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--b--c--d--e--f--g--h-|")
        const e1subs = "  ^------------------------!"
        const expected = "-------------------------(h|)"
        const t = time("  ----|")
        expectObservable(e1.pipe(debounceTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should debounce all element while source emits within given time until raises error", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--b--c--d--e--f--g--h-#")
        const e1subs = "  ^------------------------!"
        const expected = "-------------------------#"
        const t = time("  ----|")
        expectObservable(e1.pipe(debounceTime(t))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should debounce correctly when synchronously reentered", () => {
    const results: number[] = []
    const source = new Subject<number>()
    const scheduler = new VirtualTimeScheduler()
    source.pipe(debounceTime(0, scheduler)).subscribe(value => {
      results.push(value)
      if (value === 1) {
        source.next(2)
      }
    })
    source.next(1)
    scheduler.flush()
    expect(results).to.deep.equal([1, 2])
  })
  it("should unsubscribe from the scheduled debounce action when downstream unsubscribes", () => {
    const scheduler = new AnimationFrameScheduler(AnimationFrameAction)
    expect(scheduler._scheduled).to.not.exist
    expect(scheduler.actions).to.be.empty
    const subscription = NEVER.pipe(
      startWith(1),
      debounceTime(0, scheduler)
    ).subscribe()
    expect(scheduler._scheduled).to.exist
    expect(scheduler.actions.length).to.equal(1)
    subscription.unsubscribe()
    expect(scheduler._scheduled).to.not.exist
    expect(scheduler.actions).to.be.empty
  })
})
import { expect } from "chai"
import { observableMatcher } from "../helpers/observableMatcher"
import { of, Observable } from "rxjs"
import { defaultIfEmpty, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
/** @test {defaultIfEmpty} */
describe("defaultIfEmpty", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should return the Observable if not empty with a default value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --------|")
      const e1subs = "  ^-------!"
      const expected = "--------(x|)"
      expectObservable(e1.pipe(defaultIfEmpty(42))).toBe(expected, { x: 42 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return the argument if Observable is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |")
      const e1subs = "  (^!)"
      const expected = "(x|)"
      expectObservable(e1.pipe(defaultIfEmpty("x"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return the Observable if not empty with a default value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--|")
      const e1subs = "  ^-------!"
      const expected = "--a--b--|"
      expectObservable(e1.pipe(defaultIfEmpty("x"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow undefined as a default value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --------|")
      const e1subs = "  ^-------!"
      const expected = "--------(U|)"
      expectObservable(e1.pipe(defaultIfEmpty(undefined))).toBe(expected, {
        U: undefined,
      })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--|")
      const e1subs = "  ^---!    "
      const expected = "--a--    "
      const unsub = "   ----!    "
      const result = e1.pipe(defaultIfEmpty("x"))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--|")
      const e1subs = "  ^---!    "
      const expected = "--a--    "
      const unsub = "   ----!    "
      const result = e1.pipe(
        mergeMap(x => of(x)),
        defaultIfEmpty("x"),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should error if the Observable errors", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #")
      const e1subs = "  (^!)"
      const expected = "#"
      expectObservable(e1.pipe(defaultIfEmpty("x"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(defaultIfEmpty(0), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { of, concat } from "rxjs"
import {
  delay,
  repeatWhen,
  skip,
  take,
  tap,
  mergeMap,
  ignoreElements,
} from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import * as sinon from "sinon"
import { expect } from "chai"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {delay} */
describe("delay", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should delay by specified timeframe", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ---a--b--|")
        const e1subs = "  ^--------!"
        const t = time("     --|    ")
        //                      --|
        const expected = "-----a--b|"
        const result = e1.pipe(delay(t))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not delay at all if the delay number is negative", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---a--b--|")
      const e1subs = "  ^--------!"
      const t = -1
      const expected = "---a--b--|"
      const result = e1.pipe(delay(t))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should delay by absolute time period", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--a---a----a----a------------b---b---b---b--|")
        const e1subs = "  ^----------------------------------------------!"
        const t = time("  --------------------|                           ")
        const expected = "--------------------(aaaaa)-----b---b---b---b--|"
        const absoluteDelay = new Date(testScheduler.now() + t)
        const result = e1.pipe(delay(absoluteDelay))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not delay at all if the absolute time is in the past", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--a---a----a----a------------b---b---b---b--|")
      const e1subs = "  ^----------------------------------------------!"
      const t = -10000
      const expected = "--a--a---a----a----a------------b---b---b---b--|"
      const absoluteDelay = new Date(testScheduler.now() + t)
      const result = e1.pipe(delay(absoluteDelay))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should delay by absolute time period after source ends", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("---^--a-----a---a-----a---|             ")
        const e1subs = "   ^----------------------!             "
        const t = time("   ------------------------------|      ")
        const expected = " ------------------------------(aaaa|)"
        const absoluteDelay = new Date(testScheduler.now() + t)
        const result = e1.pipe(delay(absoluteDelay))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should raise error when source raises error", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ---a---b---#")
        const e1subs = "  ^----------!"
        const t = time("     ---|     ")
        //                       ---|
        const expected = "------a---b#"
        const result = e1.pipe(delay(t))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should raise error when source raises error before absolute delay fires", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--a---a-----#     ")
        const e1subs = "  ^--------------!     "
        const t = time("  --------------------|")
        const expected = "---------------#     "
        const absoluteDelay = new Date(testScheduler.now() + t)
        const result = e1.pipe(delay(absoluteDelay))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should raise error when source raises error after absolute delay fires", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("---^---a--a---a---a--------b---b---b--#")
        const e1subs = "   ^----------------------------------!"
        const t = time("   -----------------|                  ")
        const expected = " -----------------(aaaa)-b---b---b--#"
        const absoluteDelay = new Date(testScheduler.now() + t)
        const result = e1.pipe(delay(absoluteDelay))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should delay when source does not emit", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ----|")
        const e1subs = "  ^---!"
        const t = time("  ---| ")
        const expected = "----|"
        const result = e1.pipe(delay(t))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not delay when source is empty", () => {
    testScheduler.run(
      ({ cold, time, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" |   ")
        const e1subs = "  (^!)"
        const t = time("  ---|")
        const expected = "|   "
        const result = e1.pipe(delay(t))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should delay complete when a value is scheduled", () => {
    testScheduler.run(
      ({ cold, time, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" -a-|    ")
        const e1subs = "  ^--!    "
        const t = time("   ---|   ")
        const expected = "----(a|)"
        const result = e1.pipe(delay(t))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not complete when source does not complete", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ---a---b---------")
        const e1subs = "  ^---------------!"
        const t = time("     ---|          ")
        //                       ---|
        const expected = "------a---b------"
        const unsub = "   ----------------!"
        const result = e1.pipe(delay(t))
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ---a---b----")
        const e1subs = "  ^-------!   "
        const t = time("     ---|     ")
        //                       ---|
        const expected = "------a--   "
        const unsub = "   --------!   "
        const result = e1.pipe(
          mergeMap((x: any) => of(x)),
          delay(t),
          mergeMap((x: any) => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not complete when source never completes", () => {
    testScheduler.run(
      ({ cold, time, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" -   ")
        const e1subs = "  ^   "
        const t = time("  ---|")
        const expected = "-   "
        const result = e1.pipe(delay(t))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should unsubscribe scheduled actions after execution", () => {
    testScheduler.run(
      ({ cold, time, expectObservable, expectSubscriptions }) => {
        let subscribeSpy: any = null
        const counts: number[] = []
        const e1 = cold(" a|      ")
        const t = time("  -|      ")
        const expected = "--a-(a|)"
        const result = e1.pipe(
          repeatWhen(notifications => {
            const delayed = notifications.pipe(delay(t))
            subscribeSpy = sinon.spy((delayed as any)["source"], "subscribe")
            return delayed
          }),
          skip(1),
          take(2),
          tap({
            next() {
              const [[subscriber]] = subscribeSpy.args
              counts.push(subscriber._finalizers.length)
            },
            complete() {
              expect(counts).to.deep.equal([1, 1])
            },
          })
        )
        expectObservable(result).toBe(expected)
      }
    )
  })
  it("should be possible to delay complete by composition", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ---a--b---|  ")
        const e1subs = "  ^---------!  "
        const t = time("     --|       ")
        //                      --|
        //                          --|
        const expected = "-----a--b---|"
        const result = concat(
          e1.pipe(delay(t)),
          of(undefined).pipe(delay(t), ignoreElements())
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
})
import { of, EMPTY } from "rxjs"
import { delayWhen, tap } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
import { expect } from "chai"
/** @test {delayWhen} */
describe("delayWhen", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should delay by duration selector", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ---a---b---c--|      ")
        const expected = "-----a------c----(b|)"
        const subs = "    ^-------------!      "
        const selector = [
          cold("             --x--|            "),
          cold("                 ----------(x|)"),
          cold("                     -x--|     "),
        ]
        const selectorSubs = [
          "               ---^-!               ",
          "               -------^---------!   ",
          "               -----------^!        ",
        ]
        let idx = 0
        function durationSelector(x: any) {
          return selector[idx++]
        }
        const result = e1.pipe(delayWhen(durationSelector))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(selector[0].subscriptions).toBe(selectorSubs[0])
        expectSubscriptions(selector[1].subscriptions).toBe(selectorSubs[1])
        expectSubscriptions(selector[2].subscriptions).toBe(selectorSubs[2])
      }
    )
  })
  it("should delay by selector", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("     --a--b--| ")
        const expected = "   ---a--b-| "
        const subs = "       ^-------! "
        const selector = cold("-x--|   ")
        //                        -x--|
        // prettier-ignore
        const selectorSubs = [
        '                  --^!      ',
        '                  -----^!   ',
      ];
        const result = e1.pipe(delayWhen((x: any) => selector))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(selector.subscriptions).toBe(selectorSubs)
      }
    )
  })
  it("should raise error if source raises error", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("      --a--# ")
        const expected = "    ---a-# "
        const subs = "        ^----! "
        const selector = cold(" -x--|")
        const selectorSubs = "--^!   "
        const result = e1.pipe(delayWhen((x: any) => selector))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(selector.subscriptions).toBe(selectorSubs)
      }
    )
  })
  it("should raise error if selector raises error", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("      --a--b--|")
        const expected = "    ---#     "
        const subs = "        ^--!     "
        const selector = cold(" -#     ")
        const selectorSubs = "--^!     "
        const result = e1.pipe(delayWhen((x: any) => selector))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(selector.subscriptions).toBe(selectorSubs)
      }
    )
  })
  it("should delay by selector and completes after value emits", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("     --a--b--|       ")
        const expected = "   ---------a--(b|)"
        const subs = "       ^-------!       "
        const selector = cold("-------x--|   ")
        //                        -------x--|
        // prettier-ignore
        const selectorSubs = [
        '                  --^------!      ',
        '                  -----^------!   '
      ];
        const result = e1.pipe(delayWhen((x: any) => selector))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(selector.subscriptions).toBe(selectorSubs)
      }
    )
  })
  it("should delay, but not emit if the selector never emits a notification", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("     --a--b--|   ")
        const expected = "   -----------|"
        const subs = "       ^-------!   "
        const selector = cold("------|   ")
        //                        ------|
        // prettier-ignore
        const selectorSubs = [
        '                  --^-----!   ',
        '                  -----^-----!'
      ];
        const result = e1.pipe(delayWhen((x: any) => selector))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(selector.subscriptions).toBe(selectorSubs)
      }
    )
  })
  it("should not emit for async source and sync empty selector", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  a--|")
      const expected = "---|"
      const subs = "    ^--!"
      const result = e1.pipe(delayWhen((x: any) => EMPTY))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should not emit if selector never emits", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("     --a--b--|")
        const expected = "   -        "
        const subs = "       ^-------!"
        const selector = cold("-      ")
        //                        -
        // prettier-ignore
        const selectorSubs = [
        '                  --^      ',
        '                  -----^   ',
      ];
        const result = e1.pipe(delayWhen((x: any) => selector))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(selector.subscriptions).toBe(selectorSubs)
      }
    )
  })
  it("should delay by first value from selector", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("     --a--b--|       ")
        const expected = "   ------a--(b|)   "
        const subs = "       ^-------!       "
        const selector = cold("----x--y--|   ")
        //                        ----x--y--|
        // prettier-ignore
        const selectorSubs = [
        '                  --^---!         ',
        '                  -----^---!      ',
      ];
        const result = e1.pipe(delayWhen((x: any) => selector))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(selector.subscriptions).toBe(selectorSubs)
      }
    )
  })
  it("should delay by selector that does not completes", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("     --a--b--|          ")
        const expected = "   ------a--(b|)      "
        const subs = "       ^-------!          "
        const selector = cold("----x-----y---   ")
        //                        ----x-----y---
        // prettier-ignore
        const selectorSubs = [
        '                  --^---!            ',
        '                  -----^---!         '
      ];
        const result = e1.pipe(delayWhen((x: any) => selector))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(selector.subscriptions).toBe(selectorSubs)
      }
    )
  })
  it("should raise error if selector throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--|")
      const e1subs = "  ^-!      "
      const expected = "--#      "
      const err = new Error("error")
      const result = e1.pipe(
        delayWhen(<any>((x: any) => {
          throw err
        }))
      )
      expectObservable(result).toBe(expected, null, err)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should start subscription when subscription delay emits", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("       -----a---b---| ")
        const expected = "     -------a---b-| "
        const subs = "         ---^---------! "
        const selector = cold("     --x--|    ")
        //                              --x--|
        // prettier-ignore
        const selectorSubs = [
        '                      -----^-!     ',
        '                      ---------^-! '
      ];
        const subDelay = cold("---x--|        ")
        const subDelaySub = "  ^--!           "
        const result = e1.pipe(delayWhen((x: any) => selector, subDelay))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(selector.subscriptions).toBe(selectorSubs)
        expectSubscriptions(subDelay.subscriptions).toBe(subDelaySub)
      }
    )
  })
  it("should start subscription when subscription delay completes without emit value", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("       -----a---b---| ")
        const expected = "     -------a---b-| "
        const subs = "         ---^---------! "
        const selector = cold("     --x--|    ")
        //                              --x--|
        // prettier-ignore
        const selectorSubs = [
        '                    -----^-!       ',
        '                    ---------^-!   '
      ];
        const subDelay = cold("---|           ")
        const subDelaySub = "  ^--!           "
        const result = e1.pipe(delayWhen((x: any) => selector, subDelay))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(selector.subscriptions).toBe(selectorSubs)
        expectSubscriptions(subDelay.subscriptions).toBe(subDelaySub)
      }
    )
  })
  it("should raise error when subscription delay raises error", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("       -----a---b---|")
        const expected = "     ---#          "
        const selector = cold("     --x--|   ")
        const subDelay = cold("---#          ")
        const subDelaySub = "  ^--!          "
        const result = e1.pipe(delayWhen((x: any) => selector, subDelay))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe([])
        expectSubscriptions(selector.subscriptions).toBe([])
        expectSubscriptions(subDelay.subscriptions).toBe(subDelaySub)
      }
    )
  })
  it("should complete when duration selector returns synchronous observable", () => {
    let next: boolean = false
    let complete: boolean = false
    of(1)
      .pipe(delayWhen(() => of(2)))
      .subscribe({
        next: () => (next = true),
        complete: () => (complete = true),
      })
    expect(next).to.be.true
    expect(complete).to.be.true
  })
  it("should call predicate with indices starting at 0", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("       --a--b--c--|")
        const e1subs = "       ^----------!"
        const expected = "     --a--b--c--|"
        const selector = cold("  (x|)")
        //                          (x|)
        //                             (x|)
        let indices: number[] = []
        const predicate = (value: string, index: number) => {
          indices.push(index)
          return selector
        }
        const result = e1.pipe(delayWhen(predicate))
        expectObservable(
          result.pipe(
            tap({
              complete: () => {
                expect(indices).to.deep.equal([0, 1, 2])
              },
            })
          )
        ).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
})
import { expect } from "chai"
import { of, Notification, ObservableNotification, Observable } from "rxjs"
import { dematerialize, map, mergeMap, materialize, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {dematerialize} */
describe("dematerialize", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should dematerialize an Observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: "{x}",
        b: "{y}",
        c: "{z}",
        d: "|",
      }
      const e1 = hot("  --a--b--c--d-|", values)
      const e1subs = "  ^----------!  "
      const expected = "--x--y--z--|  "
      const result = e1.pipe(
        map((x: string) => {
          if (x === "|") {
            return Notification.createComplete()
          } else {
            return Notification.createNext(x.replace("{", "").replace("}", ""))
          }
        }),
        dematerialize()
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should dematerialize a happy stream", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: Notification.createNext("w"),
        b: Notification.createNext("x"),
        c: Notification.createNext("y"),
        d: Notification.createComplete(),
      }
      const e1 = hot("  --a--b--c--d--|", values)
      const e1subs = "  ^----------!   "
      const expected = "--w--x--y--|   "
      expectObservable(e1.pipe(dematerialize())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should dematerialize a sad stream", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: Notification.createNext("w"),
        b: Notification.createNext("x"),
        c: Notification.createNext("y"),
        d: Notification.createError("error"),
      }
      const e1 = hot("  --a--b--c--d--|", values)
      const e1subs = "  ^----------!   "
      const expected = "--w--x--y--#   "
      expectObservable(e1.pipe(dematerialize())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should dematerialize stream does not completes", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot<ObservableNotification<any>>("------")
      const e1subs = "                             ^"
      const expected = "                           -"
      expectObservable(e1.pipe(dematerialize())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should dematerialize stream never completes", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold<ObservableNotification<any>>("-")
      const e1subs = "                              ^"
      const expected = "                            -"
      expectObservable(e1.pipe(dematerialize())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should dematerialize stream does not emit", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot<ObservableNotification<any>>("----|")
      const e1subs = "                             ^---!"
      const expected = "                           ----|"
      expectObservable(e1.pipe(dematerialize())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should dematerialize empty stream", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold<ObservableNotification<any>>("|   ")
      const e1subs = "                              (^!)"
      const expected = "                            |   "
      expectObservable(e1.pipe(dematerialize())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should dematerialize stream throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const error = "error"
      const e1 = hot("  (x|)", { x: Notification.createError(error) })
      const e1subs = "  (^!)"
      const expected = "#   "
      expectObservable(e1.pipe(dematerialize())).toBe(expected, null, error)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: Notification.createNext("w"),
        b: Notification.createNext("x"),
      }
      const e1 = hot("  --a--b--c--d--|", values)
      const e1subs = "  ^------!       "
      const expected = "--w--x--       "
      const unsub = "   -------!       "
      const result = e1.pipe(dematerialize())
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: Notification.createNext("w"),
        b: Notification.createNext("x"),
      }
      const e1 = hot("  --a--b--c--d--|", values)
      const e1subs = "  ^------!       "
      const expected = "--w--x--       "
      const unsub = "   -------!       "
      const result = e1.pipe(
        mergeMap((x: any) => of(x)),
        dematerialize(),
        mergeMap((x: any) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should dematerialize and completes when stream completes with complete notification", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----(a|)", { a: Notification.createComplete() })
      const e1subs = "  ^---!   "
      const expected = "----|   "
      expectObservable(e1.pipe(dematerialize())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should dematerialize and completes when stream emits complete notification", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----a--|", { a: Notification.createComplete() })
      const e1subs = "  ^---!   "
      const expected = "----|   "
      expectObservable(e1.pipe(dematerialize())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work with materialize", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----a--b---c---d---e----f--|")
      const e1subs = "  ^--------------------------!"
      const expected = "----a--b---c---d---e----f--|"
      const result = e1.pipe(materialize(), dematerialize())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(materialize(), dematerialize(), take(3))
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { distinct, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of, Observable } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {distinct} */
describe("distinct", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should distinguish between values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--a--a--b--b--a--|")
      const e1subs = "  ^-------------------!"
      const expected = "--a--------b--------|"
      expectObservable(e1.pipe(distinct())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should distinguish between values and does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--a--a--b--b--a-")
      const e1subs = "  ^------------------"
      const expected = "--a--------b-------"
      expectObservable(e1.pipe(distinct())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not complete if source never completes", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(distinct())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not complete if source does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(distinct())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should complete if source is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |")
      const e1subs = "  (^!)"
      const expected = "|"
      expectObservable(e1.pipe(distinct())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should complete if source does not emit", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ------|")
      const e1subs = "  ^-----!"
      const expected = "------|"
      expectObservable(e1.pipe(distinct())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit if source emits single element only", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--|")
      const e1subs = "  ^----!"
      const expected = "--a--|"
      expectObservable(e1.pipe(distinct())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit if source is scalar", () => {
    testScheduler.run(({ expectObservable }) => {
      const e1 = of("a")
      const expected = "(a|)"
      expectObservable(e1.pipe(distinct())).toBe(expected)
    })
  })
  it("should raises error if source raises error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--a--#")
      const e1subs = "  ^-------!"
      const expected = "--a-----#"
      expectObservable(e1.pipe(distinct())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raises error if source throws", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      expectObservable(e1.pipe(distinct())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not omit if source elements are all different", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--f--|")
      const e1subs = "  ^-------------------!"
      const expected = "--a--b--c--d--e--f--|"
      expectObservable(e1.pipe(distinct())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--b--d--a--f--|")
      const e1subs = "  ^---------!          "
      const expected = "--a--b-----          "
      const unsub = "   ----------!          "
      const result = e1.pipe(distinct())
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--b--d--a--f--|")
      const e1subs = "  ^---------!          "
      const expected = "--a--b-----          "
      const unsub = "   ----------!          "
      const result = e1.pipe(
        mergeMap((x: any) => of(x)),
        distinct(),
        mergeMap((x: any) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit once if source elements are all same", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--a--a--a--a--a--|")
      const e1subs = "  ^-------------------!"
      const expected = "--a-----------------|"
      expectObservable(e1.pipe(distinct())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should distinguish values by key", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6 }
      const e1 = hot("  --a--b--c--d--e--f--|", values)
      const e1subs = "  ^-------------------!"
      const expected = "--a--b--c-----------|"
      const selector = (value: number) => value % 3
      expectObservable(e1.pipe(distinct(selector))).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raises error when selector throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--f--|")
      const e1subs = "  ^----------!         "
      const expected = "--a--b--c--#         "
      const selector = (value: string) => {
        if (value === "d") {
          throw new Error("d is for dumb")
        }
        return value
      }
      expectObservable(e1.pipe(distinct(selector))).toBe(
        expected,
        undefined,
        new Error("d is for dumb")
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should support a flushing stream", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--a--b--a--b--|")
      const e1subs = "  ^-------------------!"
      const e2 = hot("  -----------x--------|")
      const e2subs = "  ^-------------------!"
      const expected = "--a--b--------a--b--|"
      expectObservable(e1.pipe(distinct(undefined, e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise error if flush raises error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--a--b--a--b--|")
      const e1subs = "  ^------------!       "
      const e2 = hot("  -----------x-#       ")
      const e2subs = "  ^------------!       "
      const expected = "--a--b-------#       "
      expectObservable(e1.pipe(distinct(undefined, e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should unsubscribe from the flushing stream when the main stream is unsubbed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--a--b--a--b--|")
      const e1subs = "  ^----------!         "
      const e2 = hot("  -----------x--------|")
      const e2subs = "  ^----------!         "
      const unsub = "   -----------!         "
      const expected = "--a--b------         "
      expectObservable(e1.pipe(distinct(undefined, e2)), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should allow opting in to default comparator with flush", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--a--b--a--b--|")
      const e1subs = "  ^-------------------!"
      const e2 = hot("  -----------x--------|")
      const e2subs = "  ^-------------------!"
      const expected = "--a--b--------a--b--|"
      expectObservable(e1.pipe(distinct(undefined, e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(distinct(), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { distinctUntilChanged, mergeMap, take } from "rxjs/operators"
import { of, Observable, Subject } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {distinctUntilChanged} */
describe("distinctUntilChanged", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should distinguish between values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -1--2-2----1-3-|")
      const e1subs = "  ^--------------!"
      const expected = "-1--2------1-3-|"
      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should distinguish between values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--a--a--b--b--a--|")
      const e1subs = "  ^-------------------!"
      const expected = "--a--------b-----a--|"
      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should distinguish between values and does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--a--a--b--b--a-")
      const e1subs = "  ^------------------"
      const expected = "--a--------b-----a-"
      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not complete if source never completes", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not complete if source does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should complete if source is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should complete if source does not emit", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ------|")
      const e1subs = "  ^-----!"
      const expected = "------|"
      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit if source emits single element only", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--|")
      const e1subs = "  ^----!"
      const expected = "--a--|"
      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit if source is scalar", () => {
    testScheduler.run(({ expectObservable }) => {
      const e1 = of("a")
      const expected = "(a|)"
      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected)
    })
  })
  it("should raise error if source raises error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--a--#")
      const e1subs = "  ^-------!"
      const expected = "--a-----#"
      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if source throws", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not omit if source elements are all different", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--f--|")
      const e1subs = "  ^-------------------!"
      const expected = "--a--b--c--d--e--f--|"
      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--b--d--a--f--|")
      const e1subs = "  ^---------!          "
      const expected = "--a--b-----          "
      const unsub = "   ----------!          "
      const result = e1.pipe(distinctUntilChanged())
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--b--d--a--f--|")
      const e1subs = "  ^---------!          "
      const expected = "--a--b-----          "
      const unsub = "   ----------!          "
      const result = e1.pipe(
        mergeMap((x: any) => of(x)),
        distinctUntilChanged(),
        mergeMap((x: any) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit once if source elements are all same", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--a--a--a--a--a--|")
      const e1subs = "  ^-------------------!"
      const expected = "--a-----------------|"
      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit once if comparator returns true always regardless of source emits", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--f--|")
      const e1subs = "  ^-------------------!"
      const expected = "--a-----------------|"
      const comparator = () => true
      expectObservable(e1.pipe(distinctUntilChanged(comparator))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit all if comparator returns false always regardless of source emits", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--a--a--a--a--a--|")
      const e1subs = "  ^-------------------!"
      const expected = "--a--a--a--a--a--a--|"
      const comparator = () => false
      expectObservable(e1.pipe(distinctUntilChanged(comparator))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should distinguish values by comparator", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--f--|", {
        a: 1,
        b: 2,
        c: 3,
        d: 4,
        e: 5,
        f: 6,
      })
      const e1subs = "  ^-------------------!"
      const expected = "--a-----c-----e-----|"
      const comparator = (x: number, y: number) => y % 2 === 0
      expectObservable(e1.pipe(distinctUntilChanged(comparator))).toBe(
        expected,
        { a: 1, c: 3, e: 5 }
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error when comparator throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--f--|")
      const e1subs = "  ^----------!         "
      const expected = "--a--b--c--#         "
      const comparator = (x: string, y: string) => {
        if (y === "d") {
          throw "error"
        }
        return x === y
      }
      expectObservable(e1.pipe(distinctUntilChanged(comparator))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should use the keySelector to pick comparator values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--f--|", {
        a: 1,
        b: 2,
        c: 3,
        d: 4,
        e: 5,
        f: 6,
      })
      const e1subs = "  ^-------------------!"
      const expected = "--a--b-----d-----f--|"
      const comparator = (x: number, y: number) => y % 2 === 1
      const keySelector = (x: number) => x % 2
      expectObservable(
        e1.pipe(distinctUntilChanged(comparator, keySelector))
      ).toBe(expected, { a: 1, b: 2, d: 4, f: 6 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should use the keySelector even for the first emit", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--|", { a: 2, b: 4 })
      const e1subs = "  ^-------!"
      const expected = "--a-----|"
      const keySelector = (x: number) => x % 2
      expectObservable(e1.pipe(distinctUntilChanged(null!, keySelector))).toBe(
        expected,
        { a: 2 }
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error when keySelector throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--f--|")
      const e1subs = "  ^----------!         "
      const expected = "--a--b--c--#         "
      const keySelector = (x: string) => {
        if (x === "d") {
          throw "error"
        }
        return x
      }
      expectObservable(
        e1.pipe(distinctUntilChanged(null as any, keySelector))
      ).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(distinctUntilChanged(), take(3))
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
  // This test is to cover a corner case where someone might write
  // synchronous, reentrant code. At the time this test was authored,
  // the operator was written in such a way that it would allow
  // the duplicate non-distinct values to be emitted repeatedly.
  it("should work properly with reentrant streams", () => {
    const subject = new Subject<number | undefined>()
    const results: any[] = []
    let count = 0
    subject.pipe(distinctUntilChanged()).subscribe(n => {
      results.push(n)
      // Protect against an infinite loop in this test.
      // That shouldn't happen.
      if (++count > 2) {
        throw new Error("this should have only been hit once")
      }
      // If we reenter with the same value, it should not
      // emit again.
      subject.next(1)
    })
    // Start with 1.
    subject.next(1)
    // It should only have emitted one value.
    expect(results).to.deep.equal([1])
  })
})
import { expect } from "chai"
import { distinctUntilKeyChanged, mergeMap, map, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of, Observable } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {distinctUntilKeyChanged} */
describe("distinctUntilKeyChanged", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should distinguish between values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: { k: 1 }, b: { k: 2 }, c: { k: 3 } }
      const e1 = hot("  -a--b-b----a-c-|", values)
      const e1Subs = "  ^--------------!"
      const expected = "-a--b------a-c-|"
      const result = e1.pipe(distinctUntilKeyChanged("k"))
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1Subs)
    })
  })
  it("should distinguish between values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: { val: 1 }, b: { val: 2 } }
      const e1 = hot("  --a--a--a--b--b--a--|", values)
      const e1subs = "  ^-------------------!"
      const expected = "--a--------b-----a--|"
      expectObservable(e1.pipe(distinctUntilKeyChanged("val"))).toBe(
        expected,
        values
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should distinguish between values and does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: { val: 1 }, b: { val: 2 } }
      const e1 = hot("  --a--a--a--b--b--a-", values)
      const e1subs = "  ^                  "
      const expected = "--a--------b-----a-"
      expectObservable(e1.pipe(distinctUntilKeyChanged("val"))).toBe(
        expected,
        values
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should distinguish between values with key", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: { val: 1 },
        b: { valOther: 1 },
        c: { valOther: 3 },
        d: { val: 1 },
        e: { val: 5 },
      }
      const e1 = hot<any>("--a--b--c--d--e--|", values)
      const e1subs = "     ^----------------!"
      const expected = "   --a--b-----d--e--|"
      expectObservable(e1.pipe(distinctUntilKeyChanged("val"))).toBe(
        expected,
        values
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not compare if source does not have element with key", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: { valOther: 1 },
        b: { valOther: 1 },
        c: { valOther: 3 },
        d: { valOther: 1 },
        e: { valOther: 5 },
      }
      const e1 = hot<any>("--a--b--c--d--e--|", values)
      const e1subs = "     ^----------------!"
      const expected = "   --a--------------|"
      expectObservable(e1.pipe(distinctUntilKeyChanged("val"))).toBe(
        expected,
        values
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not complete if source never completes", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold<any>("-")
      const e1subs = "      ^"
      const expected = "    -"
      expectObservable(e1.pipe(distinctUntilKeyChanged("val"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not complete if source does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot<any>("-")
      const e1subs = "     ^"
      const expected = "   -"
      expectObservable(e1.pipe(distinctUntilKeyChanged("val"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should complete if source is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold<any>("|")
      const e1subs = "      (^!)"
      const expected = "    |"
      expectObservable(e1.pipe(distinctUntilKeyChanged("val"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should complete if source does not emit", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot<any>("------|")
      const e1subs = "     ^-----!"
      const expected = "   ------|"
      expectObservable(e1.pipe(distinctUntilKeyChanged("val"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit if source emits single element only", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: { val: 1 } }
      const e1 = hot("  --a--|", values)
      const e1subs = "  ^----!"
      const expected = "--a--|"
      expectObservable(e1.pipe(distinctUntilKeyChanged("val"))).toBe(
        expected,
        values
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit if source is scalar", () => {
    testScheduler.run(({ expectObservable }) => {
      const values = { a: { val: 1 } }
      const e1 = of(values.a)
      const expected = "(a|)"
      expectObservable(e1.pipe(distinctUntilKeyChanged("val"))).toBe(
        expected,
        values
      )
    })
  })
  it("should raise error if source raises error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: { val: 1 } }
      const e1 = hot("  --a--a--#", values)
      const e1subs = "  ^-------!"
      const expected = "--a-----#"
      expectObservable(e1.pipe(distinctUntilKeyChanged("val"))).toBe(
        expected,
        values
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if source throws", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold<any>("#   ")
      const e1subs = "      (^!)"
      const expected = "    #   "
      expectObservable(e1.pipe(distinctUntilKeyChanged("val"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not omit if source elements are all different", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: { val: 1 },
        b: { val: 2 },
        c: { val: 3 },
        d: { val: 4 },
        e: { val: 5 },
      }
      const e1 = hot("  --a--b--c--d--e--|", values)
      const e1subs = "  ^----------------!"
      const expected = "--a--b--c--d--e--|"
      expectObservable(e1.pipe(distinctUntilKeyChanged("val"))).toBe(
        expected,
        values
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: { val: 1 },
        b: { val: 2 },
        c: { val: 3 },
        d: { val: 4 },
        e: { val: 5 },
      }
      const e1 = hot("  --a--b--b--d--a--e--|", values)
      const e1subs = "  ^---------!          "
      const expected = "--a--b-----          "
      const unsub = "   ----------!          "
      const result = e1.pipe(distinctUntilKeyChanged("val"))
      expectObservable(result, unsub).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: { val: 1 },
        b: { val: 2 },
        c: { val: 3 },
        d: { val: 4 },
        e: { val: 5 },
      }
      const e1 = hot("  --a--b--b--d--a--e--|", values)
      const e1subs = "  ^---------!          "
      const expected = "--a--b-----          "
      const unsub = "   ----------!          "
      const result = e1.pipe(
        mergeMap((x: any) => of(x)),
        distinctUntilKeyChanged("val"),
        mergeMap((x: any) => of(x))
      )
      expectObservable(result, unsub).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit once if source elements are all same", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: { val: 1 } }
      const e1 = hot("  --a--a--a--a--a--a--|", values)
      const e1subs = "  ^-------------------!"
      const expected = "--a-----------------|"
      expectObservable(e1.pipe(distinctUntilKeyChanged("val"))).toBe(
        expected,
        values
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit once if comparer returns true always regardless of source emits", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: { val: 1 },
        b: { val: 2 },
        c: { val: 3 },
        d: { val: 4 },
        e: { val: 5 },
      }
      const e1 = hot("  --a--b--c--d--e--|", values)
      const e1subs = "  ^----------------!"
      const expected = "--a--------------|"
      expectObservable(
        e1.pipe(distinctUntilKeyChanged("val", () => true))
      ).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit all if comparer returns false always regardless of source emits", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: { val: 1 } }
      const e1 = hot("  --a--a--a--a--a--a--|", values)
      const e1subs = "  ^-------------------!"
      const expected = "--a--a--a--a--a--a--|"
      expectObservable(
        e1.pipe(distinctUntilKeyChanged("val", () => false))
      ).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should distinguish values by selector", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: { val: 1 },
        b: { val: 2 },
        c: { val: 3 },
        d: { val: 4 },
        e: { val: 5 },
      }
      const e1 = hot("  --a--b--c--d--e--|", values)
      const e1subs = "  ^----------------!"
      const expected = "--a-----c-----e--|"
      const selector = (x: number, y: number) => y % 2 === 0
      expectObservable(e1.pipe(distinctUntilKeyChanged("val", selector))).toBe(
        expected,
        values
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error when comparer throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: { val: 1 },
        b: { val: 2 },
        c: { val: 3 },
        d: { val: 4 },
        e: { val: 5 },
      }
      const e1 = hot("  --a--b--c--d--e--|", values)
      const e1subs = "  ^----------!      "
      const expected = "--a--b--c--#      "
      const selector = (x: number, y: number) => {
        if (y === 4) {
          throw "error"
        }
        return x === y
      }
      expectObservable(e1.pipe(distinctUntilKeyChanged("val", selector))).toBe(
        expected,
        values
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        map(value => ({ value })),
        distinctUntilKeyChanged("value"),
        take(3)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { elementAt, mergeMap } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { ArgumentOutOfRangeError, of, range, Observable } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {elementAt} */
describe("elementAt", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should return next to last element by zero-based index", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c-d---|")
      const e1subs = "  ^-------!      "
      const expected = "--------(c|)   "
      expectObservable(e1.pipe(elementAt(2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return first element by zero-based index", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^-!"
      const expected = "--(a|)"
      expectObservable(e1.pipe(elementAt(0))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow undefined as a default value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -----a--a---a-|   ")
      const e1subs = "  ^-------------!   "
      const expected = "--------------(U|)"
      expectObservable(e1.pipe(elementAt(100, undefined))).toBe(expected, {
        U: undefined,
      })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return non-first element by zero-based index", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--f--|")
      const e1subs = "  ^----------!         "
      const expected = "-----------(d|)      "
      expectObservable(e1.pipe(elementAt(3))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return last element by zero-based index", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^-------!   "
      const expected = "--------(c|)"
      expectObservable(e1.pipe(elementAt(2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if e1 is Empty Observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      expectObservable(e1.pipe(elementAt(0))).toBe(
        expected,
        undefined,
        new ArgumentOutOfRangeError()
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if source throws", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      expectObservable(e1.pipe(elementAt(0))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not complete if source never completes", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const expected = "-"
      const e1subs = "  ^"
      expectObservable(e1.pipe(elementAt(0))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^-----!     "
      const expected = "-------     "
      const unsub = "   ------!     "
      const result = e1.pipe(elementAt(2))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result Observable is unsubscribed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^-----!     "
      const expected = "-------     "
      const unsub = "   ------!     "
      const result = e1.pipe(
        mergeMap((x: any) => of(x)),
        elementAt(2),
        mergeMap((x: any) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should throw if index is smaller than zero", () => {
    expect(() => {
      range(0, 10).pipe(elementAt(-1))
    }).to.throw(ArgumentOutOfRangeError)
  })
  it("should raise error if index is out of range but does not have default value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--|")
      const e1subs = "  ^----!"
      const expected = "-----#"
      expectObservable(e1.pipe(elementAt(3))).toBe(
        expected,
        null,
        new ArgumentOutOfRangeError()
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return default value if index is out of range", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--|   ")
      const e1subs = "  ^----!   "
      const expected = "-----(x|)"
      const defaultValue = "42"
      expectObservable(e1.pipe(elementAt(3, defaultValue))).toBe(expected, {
        x: defaultValue,
      })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits, it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(elementAt(2)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { of, Observable } from "rxjs"
import { endWith, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {endWith} */
describe("endWith", () => {
  const defaultEndValue = "x"
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should append to a cold Observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---a--b--c--|   ")
      const e1subs = "  ^-----------!   "
      const expected = "---a--b--c--(s|)"
      expectObservable(e1.pipe(endWith("s"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should append numbers to a cold Observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const values = { a: 1, b: 2, c: 3, s: 4 }
      const e1 = cold(" ---a--b--c--|   ", values)
      const e1subs = "  ^-----------!   "
      const expected = "---a--b--c--(s|)"
      expectObservable(e1.pipe(endWith(values.s))).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should end an observable with given value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--|   ")
      const e1subs = "  ^----!   "
      const expected = "--a--(x|)"
      expectObservable(e1.pipe(endWith(defaultEndValue))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not end with given value if source does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----a-")
      const e1subs = "  ^     "
      const expected = "----a-"
      expectObservable(e1.pipe(endWith(defaultEndValue))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not end with given value if source never emits and does not completes", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(endWith(defaultEndValue))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should end with given value if source does not emit but does complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---|   ")
      const e1subs = "  ^--!   "
      const expected = "---(x|)"
      expectObservable(e1.pipe(endWith(defaultEndValue))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit given value and complete immediately if source is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "(x|)"
      expectObservable(e1.pipe(endWith(defaultEndValue))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should end with given value and source both if source emits single value", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" (a|) ")
      const e1subs = "  (^!) "
      const expected = "(ax|)"
      expectObservable(e1.pipe(endWith(defaultEndValue))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should end with given values when given more than one value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -----a--|    ")
      const e1subs = "  ^-------!    "
      const expected = "-----a--(yz|)"
      expectObservable(e1.pipe(endWith("y", "z"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error and not end with given value if source raises error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --#")
      const e1subs = "  ^-!"
      const expected = "--#"
      expectObservable(e1.pipe(endWith(defaultEndValue))).toBe(
        expected,
        defaultEndValue
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error immediately and not end with given value if source throws error immediately", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      expectObservable(e1.pipe(endWith(defaultEndValue))).toBe(
        expected,
        defaultEndValue
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---a--b----c--d--|")
      const e1subs = "  ^--------!        "
      const expected = "---a--b---        "
      const unsub = "   ---------!        "
      const result = e1.pipe(endWith("s"))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---a--b----c--d--|")
      const e1subs = "  ^--------!        "
      const expected = "---a--b---        "
      const unsub = "   ---------!        "
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        endWith("s"),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should end with empty if given value is not specified", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -a-|")
      const e1subs = "  ^--!"
      const expected = "-a-|"
      expectObservable(e1.pipe(endWith())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should accept scheduler as last argument with single value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--|   ")
      const e1subs = "  ^----!   "
      const expected = "--a--(x|)"
      expectObservable(e1.pipe(endWith(defaultEndValue, testScheduler))).toBe(
        expected
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should accept scheduler as last argument with multiple value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -----a--|    ")
      const e1subs = "  ^-------!    "
      const expected = "-----a--(yz|)"
      expectObservable(e1.pipe(endWith("y", "z", testScheduler))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(endWith(0), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { every, mergeMap } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of, Observable, Observer } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {every} */
describe("every", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  function truePredicate(x: number | string) {
    return true
  }
  function predicate(x: number | string) {
    return +x % 5 === 0
  }
  it("should return false if only one of elements does not match with predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: 5, b: 10, c: 15, d: 18, e: 20 }
      const e1 = hot("  --a--b--c--d--e--|", values)
      const e1subs = "  ^----------!      "
      const expected = "-----------(x|)   "
      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: false })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should accept thisArg with scalar observables", () => {
    const thisArg = {}
    of(1)
      .pipe(
        every(function (this: any, value: number, index: number) {
          expect(this).to.deep.equal(thisArg)
          return true
        }, thisArg)
      )
      .subscribe()
  })
  it("should increment index on each call to the predicate", () => {
    const indices: number[] = []
    of(1, 2, 3, 4)
      .pipe(
        every((_, i) => {
          indices.push(i)
          return true
        })
      )
      .subscribe()
    expect(indices).to.deep.equal([0, 1, 2, 3])
  })
  it("should accept thisArg with array observable", () => {
    const thisArg = {}
    of(1, 2, 3, 4)
      .pipe(
        every(function (this: any, value: number, index: number) {
          expect(this).to.deep.equal(thisArg)
          return true
        }, thisArg)
      )
      .subscribe()
  })
  it("should accept thisArg with ordinary observable", () => {
    const thisArg = {}
    const source = new Observable((observer: Observer<number>) => {
      observer.next(1)
      observer.complete()
    })
    source
      .pipe(
        every(function (this: any, value: number, index: number) {
          expect(this).to.deep.equal(thisArg)
          return true
        }, thisArg)
      )
      .subscribe()
  })
  it("should emit true if source is empty", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -----|   ")
      const e1subs = "  ^----!   "
      const expected = "-----(x|)"
      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: true })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit false if single source element does not match with predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--|")
      const e1subs = "  ^-!   "
      const expected = "--(x|)"
      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: false })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit false if none of elements match with predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--|")
      const e1subs = "  ^-!               "
      const expected = "--(x|)            "
      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: false })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return false if only some of elements matches with predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: 5, b: 10, c: 15 }
      const e1 = hot("  --a--b--c--d--e--|", values)
      const e1subs = "  ^----------!      "
      const expected = "-----------(x|)   "
      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: false })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: 5, b: 10, c: 15 }
      const e1 = hot("  --a--b--c--d--e--|", values)
      const e1subs = "  ^------!          "
      const expected = "--------          "
      const unsub = "   -------!          "
      const result = e1.pipe(every(predicate))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result observable is unsubscribed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: 5, b: 10, c: 15 }
      const e1 = hot("  --a--b--c--d--e--|", values)
      const e1subs = "  ^------!          "
      const expected = "--------          "
      const unsub = "   -------!          "
      const result = e1.pipe(
        mergeMap((x: any) => of(x)),
        every(predicate),
        mergeMap((x: any) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should propagate error if predicate eventually throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--|")
      const e1subs = "  ^-------!"
      const expected = "--------#"
      function faultyPredicate(x: string) {
        if (x === "c") {
          throw "error"
        } else {
          return true
        }
      }
      expectObservable(e1.pipe(every(faultyPredicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit true if single source element matches with predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: 5 }
      const e1 = hot("  --a--|   ", values)
      const e1subs = "  ^----!   "
      const expected = "-----(x|)"
      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: true })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit true if scalar source matches with predicate", () => {
    testScheduler.run(({ expectObservable }) => {
      const e1 = of(5)
      const expected = "(x|)"
      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: true })
    })
  })
  it("should emit false if scalar source does not match with predicate", () => {
    testScheduler.run(({ expectObservable }) => {
      const e1 = of(3)
      const expected = "(x|)"
      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: false })
    })
  })
  it("should propagate error if predicate throws on scalar source", () => {
    testScheduler.run(({ expectObservable }) => {
      const e1 = of(3)
      const expected = "#"
      function faultyPredicate(x: number): boolean {
        throw "error"
      }
      expectObservable(e1.pipe(every(faultyPredicate))).toBe(expected)
    })
  })
  it("should emit true if scalar array source matches with predicate", () => {
    testScheduler.run(({ expectObservable }) => {
      const e1 = of(5, 10, 15, 20)
      const expected = "(x|)"
      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: true })
    })
  })
  it("should emit false if scalar array source does not match with predicate", () => {
    testScheduler.run(({ expectObservable }) => {
      const e1 = of(5, 9, 15, 20)
      const expected = "(x|)"
      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: false })
    })
  })
  it("should propagate error if predicate eventually throws on scalar array source", () => {
    testScheduler.run(({ expectObservable }) => {
      const e1 = of(5, 10, 15, 20)
      const expected = "#"
      function faultyPredicate(x: number) {
        if (x === 15) {
          throw "error"
        }
        return true
      }
      expectObservable(e1.pipe(every(faultyPredicate))).toBe(expected)
    })
  })
  it("should emit true if all source elements match with predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: 5, b: 10, c: 15, d: 20, e: 25 }
      const e1 = hot("  --a--b--c--d--e--|   ", values)
      const e1subs = "  ^----------------!   "
      const expected = "-----------------(x|)"
      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: true })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if source raises error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --#")
      const e1subs = "  ^-!"
      const expected = "--#"
      expectObservable(e1.pipe(every(truePredicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not complete if source never emits", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(every(truePredicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit true if source element matches with predicate after subscription", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: 5, b: 10, c: 15, d: 20, e: 25 }
      const e1 = hot("--z--^--a--b--c--d--e--|   ", values)
      const e1subs = "     ^-----------------!   "
      const expected = "   ------------------(x|)"
      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: true })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit false if source element does not match with predicate after subscription", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: 5, b: 10, c: 15, d: 20 }
      const e1 = hot("--z--^--b--c--z--d--|", values)
      const e1subs = "     ^--------!      "
      const expected = "   ---------(x|)   "
      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: false })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if source raises error after subscription", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--z--^--#")
      const e1subs = "     ^--!"
      const expected = "   ---#"
      expectObservable(e1.pipe(every(truePredicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should emit true if source does not emit after subscription", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--z--^-----|   ")
      const e1subs = "     ^-----!   "
      const expected = "   ------(x|)"
      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: true })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
})
import { expect } from "chai"
import { exhaustAll, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of, Observable } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {exhaust} */
describe("exhaust", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should handle a hot observable of hot observables", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const x = hot("   -----a---b---c--|                  ")
      const xsubs = "   ------^---------!                  "
      const y = hot("   -------d--e---f---|                ")
      const ysubs: string[] = []
      const z = hot("   --------------g--h---i---|         ")
      const zsubs = "   --------------------^----!         "
      const e1 = hot("  ------x-------y-----z-------------|", {
        x: x,
        y: y,
        z: z,
      })
      const e1subs = "  ^---------------------------------!"
      const expected = "---------b---c-------i------------|"
      expectObservable(e1.pipe(exhaustAll())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(x.subscriptions).toBe(xsubs)
      expectSubscriptions(y.subscriptions).toBe(ysubs)
      expectSubscriptions(z.subscriptions).toBe(zsubs)
    })
  })
  it("should switch to first immediately-scheduled inner Observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" (ab|)")
      const e1subs = "  (^!) "
      const e2 = cold(" (cd|)")
      const e2subs: string[] = []
      const expected = "(ab|)"
      expectObservable(of(e1, e2).pipe(exhaustAll())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should handle throw", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      expectObservable(e1.pipe(exhaustAll())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      expectObservable(e1.pipe(exhaustAll())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(exhaustAll())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a hot observable of observables", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("        --a---b---c--|               ")
        const xsubs = "   ------^------------!               "
        const y = cold("                ---d--e---f---|      ")
        const ysubs: string[] = []
        const z = cold("                      ---g--h---i---|")
        const zsubs = "   --------------------^-------------!"
        const e1 = hot("  ------x-------y-----z-------------|", {
          x: x,
          y: y,
          z: z,
        })
        const e1subs = "  ^---------------------------------!"
        const expected = "--------a---b---c------g--h---i---|"
        expectObservable(e1.pipe(exhaustAll())).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(z.subscriptions).toBe(zsubs)
      }
    )
  })
  it("should handle a hot observable of observables, outer is unsubscribed early", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("        --a---b---c--|         ")
        const xsubs = "   ------^---------!            "
        const y = cold("                ---d--e---f---|")
        const ysubs: string[] = []
        const e1 = hot("  ------x-------y------|       ", { x: x, y: y })
        const unsub = "   ----------------!            "
        const expected = "--------a---b----            "
        expectObservable(e1.pipe(exhaustAll()), unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("        --a---b---c--|         ")
        const xsubs = "   ------^---------!            "
        const y = cold("                ---d--e---f---|")
        const ysubs: string[] = []
        const e1 = hot("  ------x-------y------|       ", { x: x, y: y })
        const unsub = "   ----------------!            "
        const expected = "--------a---b----            "
        const result = e1.pipe(
          mergeMap(x => of(x)),
          exhaustAll(),
          mergeMap(x => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
      }
    )
  })
  it("should handle a hot observable of observables, inner never completes", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("     --a---b--|              ")
        const xsubs = "   ---^--------!              "
        const y = cold("         -d---e-             ")
        const ysubs: string[] = []
        const z = cold("                ---f--g---h--")
        const zsubs = "   --------------^------------"
        const e1 = hot("  ---x---y------z----------| ", { x: x, y: y, z: z })
        const expected = "-----a---b-------f--g---h--"
        expectObservable(e1.pipe(exhaustAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(z.subscriptions).toBe(zsubs)
      }
    )
  })
  it("should handle a synchronous switch and stay on the first inner observable", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("        --a---b---c--|   ")
        const xsubs = "   ------^------------!   "
        const y = cold("        ---d--e---f---|  ")
        const ysubs: string[] = []
        const e1 = hot("  ------(xy)------------|", { x: x, y: y })
        const expected = "--------a---b---c-----|"
        expectObservable(e1.pipe(exhaustAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
      }
    )
  })
  it("should handle a hot observable of observables, one inner throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("        --a---#                ")
        const xsubs = "   ------^-----!                "
        const y = cold("                ---d--e---f---|")
        const ysubs: string[] = []
        const e1 = hot("  ------x-------y------|       ", { x: x, y: y })
        const expected = "--------a---#                "
        expectObservable(e1.pipe(exhaustAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
      }
    )
  })
  it("should handle a hot observable of observables, outer throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("        --a---b---c--|         ")
        const xsubs = "   ------^------------!         "
        const y = cold("                ---d--e---f---|")
        const ysubs: string[] = []
        const e1 = hot("  ------x-------y-------#      ", { x: x, y: y })
        const expected = "--------a---b---c-----#      "
        expectObservable(e1.pipe(exhaustAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
      }
    )
  })
  it("should handle an empty hot observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ------|")
      const e1subs = "  ^-----!"
      const expected = "------|"
      expectObservable(e1.pipe(exhaustAll())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a never hot observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(exhaustAll())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should complete not before the outer completes", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("        --a---b---c--|   ")
        const xsubs = "   ------^------------!   "
        const e1 = hot("  ------x---------------|", { x: x })
        const expected = "--------a---b---c-----|"
        expectObservable(e1.pipe(exhaustAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
      }
    )
  })
  it("should handle an observable of promises", done => {
    const expected = [1]
    of(Promise.resolve(1), Promise.resolve(2), Promise.resolve(3))
      .pipe(exhaustAll())
      .subscribe({
        next: x => {
          expect(x).to.equal(expected.shift())
        },
        complete: () => {
          expect(expected.length).to.equal(0)
          done()
        },
      })
  })
  it("should handle an observable of promises, where one rejects", done => {
    of(Promise.reject(2), Promise.resolve(1))
      .pipe(exhaustAll())
      .subscribe({
        next: x => {
          done(new Error("should not be called"))
        },
        error: err => {
          expect(err).to.equal(2)
          done()
        },
        complete: () => {
          done(new Error("should not be called"))
        },
      })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    of(synchronousObservable)
      .pipe(exhaustAll(), take(3))
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
  it("should handle synchronously completing inner observables", done => {
    let i = 1
    of(of(1), of(2))
      .pipe(exhaustAll())
      .subscribe({
        next: v => expect(v).to.equal(i++),
        complete: () => {
          expect(i).to.equal(3)
          done()
        },
      })
  })
})
import { TestScheduler } from "rxjs/testing"
import { concat, defer, Observable, of, BehaviorSubject } from "rxjs"
import { exhaustMap, mergeMap, takeWhile, map, take } from "rxjs/operators"
import { expect } from "chai"
import { asInteropObservable } from "../helpers/interop-helper"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {exhaustMap} */
describe("exhaustMap", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should map-and-flatten each item to an Observable", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = { x: 10, y: 30, z: 50 }
        const e1 = hot("   --1-----3--5-------|")
        const e1subs = "   ^------------------!"
        const e2 = cold("    x-x-x|            ", values)
        //                         x-x-x|
        //                            x-x-x|
        const expected = " --x-x-x-y-y-y------|"
        const result = e1.pipe(exhaustMap(x => e2.pipe(map(i => i * +x))))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should support the deprecated resultSelector", () => {
    const results: Array<number[]> = []
    of(1, 2, 3)
      .pipe(
        exhaustMap(
          x => of(x, x + 1, x + 2),
          (a, b, i, ii) => [a, b, i, ii]
        )
      )
      .subscribe({
        next(value) {
          results.push(value)
        },
        error(err) {
          throw err
        },
        complete() {
          expect(results).to.deep.equal([
            [1, 1, 0, 0],
            [1, 2, 0, 1],
            [1, 3, 0, 2],
            [2, 2, 1, 0],
            [2, 3, 1, 1],
            [2, 4, 1, 2],
            [3, 3, 2, 0],
            [3, 4, 2, 1],
            [3, 5, 2, 2],
          ])
        },
      })
  })
  it("should support a void resultSelector (still deprecated)", () => {
    const results: number[] = []
    of(1, 2, 3)
      .pipe(exhaustMap(x => of(x, x + 1, x + 2), void 0))
      .subscribe({
        next(value) {
          results.push(value)
        },
        error(err) {
          throw err
        },
        complete() {
          expect(results).to.deep.equal([1, 2, 3, 2, 3, 4, 3, 4, 5])
        },
      })
  })
  it("should handle outer throw", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const x = cold("  --a--b--c--|")
      const xsubs: string[] = []
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      const result = e1.pipe(exhaustMap(() => x))
      expectObservable(result).toBe(expected)
      expectSubscriptions(x.subscriptions).toBe(xsubs)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle outer empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const x = cold("  --a--b--c--|")
      const xsubs: string[] = []
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      const result = e1.pipe(exhaustMap(() => x))
      expectObservable(result).toBe(expected)
      expectSubscriptions(x.subscriptions).toBe(xsubs)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle outer never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const x = cold("  --a--b--c--|")
      const xsubs: string[] = []
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      const result = e1.pipe(exhaustMap(() => x))
      expectObservable(result).toBe(expected)
      expectSubscriptions(x.subscriptions).toBe(xsubs)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if project throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---x---------y-----------------z-------------|")
      const e1subs = "  ^--!"
      const expected = "---#"
      const result = e1.pipe(
        exhaustMap(() => {
          throw "error"
        })
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should switch with a selector function", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("     --a--b--c--|                               ")
        const xsubs = "   ---^----------!                               "
        const y = cold("               --d--e--f--|                     ")
        const ysubs: string[] = []
        const z = cold("                                 --g--h--i--|   ")
        const zsubs = "   -------------------------------^----------!   "
        const e1 = hot("  ---x---------y-----------------z-------------|")
        const e1subs = "  ^--------------------------------------------!"
        const expected = "-----a--b--c---------------------g--h--i-----|"
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
          z: z,
        }
        const result = e1.pipe(exhaustMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(z.subscriptions).toBe(zsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch inner cold observables, outer is unsubscribed early", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("     --a--b--c--|                               ")
        const xsubs = "   ---^----------!                               "
        const y = cold("               --d--e--f--|                     ")
        const ysubs: string[] = []
        const z = cold("                                 --g--h--i--|   ")
        const zsubs = "   -------------------------------^--!           "
        const e1 = hot("  ---x---------y-----------------z-------------|")
        const unsub = "   ----------------------------------!           "
        const e1subs = "  ^---------------------------------!           "
        const expected = "-----a--b--c---------------------g-           "
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
          z: z,
        }
        const result = e1.pipe(exhaustMap(value => observableLookup[value]))
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(z.subscriptions).toBe(zsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("     --a--b--c--|                               ")
        const xsubs = "   ---^----------!                               "
        const y = cold("               --d--e--f--|                     ")
        const ysubs: string[] = []
        const z = cold("                                 --g--h--i--|   ")
        const zsubs = "   -------------------------------^--!           "
        const e1 = hot("  ---x---------y-----------------z-------------|")
        const e1subs = "  ^---------------------------------!           "
        const expected = "-----a--b--c---------------------g-           "
        const unsub = "   ----------------------------------!           "
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
          z: z,
        }
        const result = e1.pipe(
          mergeMap(x => of(x)),
          exhaustMap(value => observableLookup[value]),
          mergeMap(x => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(z.subscriptions).toBe(zsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not break unsubscription chains with interop inners when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("     --a--b--c--|                               ")
        const xsubs = "   ---^----------!                               "
        const y = cold("               --d--e--f--|                     ")
        const ysubs: string[] = []
        const z = cold("                                 --g--h--i--|   ")
        const zsubs = "   -------------------------------^--!           "
        const e1 = hot("  ---x---------y-----------------z-------------|")
        const e1subs = "  ^---------------------------------!           "
        const expected = "-----a--b--c---------------------g-           "
        const unsub = "   ----------------------------------!           "
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
          z: z,
        }
        // This test is the same as the previous test, but the observable is
        // manipulated to make it look like an interop observable - an observable
        // from a foreign library. Interop subscribers are treated differently:
        // they are wrapped in a safe subscriber. This test ensures that
        // unsubscriptions are chained all the way to the interop subscriber.
        const result = e1.pipe(
          mergeMap(x => of(x)),
          exhaustMap(value => asInteropObservable(observableLookup[value])),
          mergeMap(x => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(z.subscriptions).toBe(zsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = concat(
      defer(() => {
        sideEffects.push(1)
        return of(1)
      }),
      defer(() => {
        sideEffects.push(2)
        return of(2)
      }),
      defer(() => {
        sideEffects.push(3)
        return of(3)
      })
    )
    of(null)
      .pipe(
        exhaustMap(() => synchronousObservable),
        takeWhile(x => x != 2) // unsubscribe at the second side-effect
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([1, 2])
  })
  it("should switch inner cold observables, inner never completes", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("     --a--b--c--|                              ")
        const xsubs = "   ---^----------!                              "
        const y = cold("               --d--e--f--|                    ")
        const ysubs: string[] = []
        const z = cold("                                 --g--h--i-----")
        const zsubs = "   -------------------------------^-------------"
        const e1 = hot("  ---x---------y-----------------z---------|   ")
        const e1subs = "  ^----------------------------------------!   "
        const expected = "-----a--b--c---------------------g--h--i-----"
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
          z: z,
        }
        const result = e1.pipe(exhaustMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(z.subscriptions).toBe(zsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should handle a synchronous switch and stay on the first inner observable", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|   ")
        const xsubs = "   ---------^----------------!   "
        const y = cold("           ---f---g---h---i--|  ")
        const ysubs: string[] = []
        const e1 = hot("  ---------(xy)----------------|")
        const e1subs = "  ^----------------------------!"
        const expected = "-----------a--b--c--d--e-----|"
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        const result = e1.pipe(exhaustMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch inner cold observables, one inner throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--#             ")
        const xsubs = "   ---------^-------------!             "
        const y = cold("                     ---f---g---h---i--")
        const ysubs: string[] = []
        const e1 = hot("  ---------x---------y---------|       ")
        const e1subs = "  ^----------------------!             "
        const expected = "-----------a--b--c--d--#             "
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        const result = e1.pipe(exhaustMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch inner hot observables", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const x = hot("   -----a--b--c--d--e--|                  ")
      const xsubs = "   ---------^----------!                  "
      const y = hot("   --p-o-o-p-------f---g---h---i--|       ")
      const ysubs: string[] = []
      const z = hot("   ---z-o-o-m-------------j---k---l---m--|")
      const zsubs = "   --------------------^-----------------!"
      const e1 = hot("  ---------x----y-----z--------|         ")
      const e1subs = "  ^----------------------------!         "
      const expected = "-----------c--d--e-----j---k---l---m--|"
      const observableLookup: Record<string, Observable<string>> = {
        x: x,
        y: y,
        z: z,
      }
      const result = e1.pipe(exhaustMap(value => observableLookup[value]))
      expectObservable(result).toBe(expected)
      expectSubscriptions(x.subscriptions).toBe(xsubs)
      expectSubscriptions(y.subscriptions).toBe(ysubs)
      expectSubscriptions(z.subscriptions).toBe(zsubs)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should switch inner empty and empty", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("           |                    ")
        const y = cold("                     |          ")
        const xsubs = "   ---------(^!)                 "
        const ysubs = "   -------------------(^!)       "
        const e1 = hot("  ---------x---------y---------|")
        const e1subs = "  ^----------------------------!"
        const expected = "-----------------------------|"
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        const result = e1.pipe(exhaustMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch inner empty and never", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("           |                    ")
        const xsubs = "   ---------(^!)                 "
        const y = cold("                     -          ")
        const ysubs = "   -------------------^          "
        const e1 = hot("  ---------x---------y---------|")
        const e1subs = "  ^----------------------------!"
        const expected = "------------------------------"
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        const result = e1.pipe(exhaustMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should never switch inner never", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("           -                     ")
        const xsubs = "   ---------^                     "
        const y = cold("                     #           ")
        const ysubs: string[] = []
        const e1 = hot("  ---------x---------y----------|")
        const e1subs = "  ^-----------------------------!"
        const expected = "-------------------------------"
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        const result = e1.pipe(exhaustMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch inner empty and throw", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("           |                    ")
        const xsubs = "   ---------(^!)                 "
        const y = cold("                     #          ")
        const ysubs = "   -------------------(^!)       "
        const e1 = hot("  ---------x---------y---------|")
        const e1subs = "  ^------------------!          "
        const expected = "-------------------#          "
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        const result = e1.pipe(exhaustMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should handle outer error", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|")
        const xsubs = "   ---------^---------!       "
        const e1 = hot("  ---------x---------#       ")
        const e1subs = "  ^------------------!       "
        const expected = "-----------a--b--c-#       "
        const observableLookup: Record<string, Observable<string>> = { x: x }
        const result = e1.pipe(exhaustMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        exhaustMap(value => of(value)),
        take(3)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
  it("should ignore subsequent synchronous reentrances during subscribing the inner sub", () => {
    const e = new BehaviorSubject(1)
    const results: Array<number> = []
    e.pipe(
      take(3),
      exhaustMap(
        value =>
          new Observable<number>(subscriber => {
            e.next(value + 1)
            subscriber.next(value)
          })
      )
    ).subscribe(value => results.push(value))
    expect(results).to.deep.equal([1])
  })
})
import { expand, mergeMap, map, take, toArray } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import {
  EMPTY,
  Observable,
  of,
  Observer,
  asapScheduler,
  asyncScheduler,
  Observable,
} from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {expand} */
describe("expand", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should recursively map-and-flatten each item to an Observable", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --x----|  ", { x: 1 })
        const e1subs = "  ^------!  "
        const e2 = cold("   --c|    ", { c: 2 })
        //                    --c|
        //                      --c|
        const expected = "--a-b-c-d|"
        const values = { a: 1, b: 2, c: 4, d: 8 }
        const result = e1.pipe(
          expand(x => (x === 8 ? EMPTY : e2.pipe(map(c => c * x))))
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should work with scheduler", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --x----|  ", { x: 1 })
        const e1subs = "  ^------!  "
        const e2 = cold("   --c|    ", { c: 2 })
        //                    --c|
        //                      --c|
        const expected = "--a-b-c-d|"
        const values = { a: 1, b: 2, c: 4, d: 8 }
        const result = e1.pipe(
          expand(
            x => (x === 8 ? EMPTY : e2.pipe(map(c => c * x))),
            Infinity,
            testScheduler
          )
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should map and recursively flatten", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: 1,
          b: 1 + 1, // a + a,
          c: 2 + 2, // b + b,
          d: 4 + 4, // c + c,
          e: 8 + 8, // d + d
        }
        const e1 = hot("  (a|)            ", values)
        const e1subs = "  (^!)            "
        const e2shape = " ---(z|)         "
        const expected = "a--b--c--d--(e|)"
        /*
        expectation explanation: (conjunction junction?) ...
        since `cold('---(z|)')` emits `x + x` and completes on frame 30
        but the next "expanded" return value is synchronously subscribed to in
        that same frame, it stacks like so:
        a
        ---(b|)
           ---(c|)
              ---(d|)
                 ---(e|)      (...which flattens into:)
        a--b--c--d--(e|)
      */
        const result = e1.pipe(
          expand((x, index): Observable<any> => {
            if (x === 16) {
              return EMPTY
            } else {
              return cold(e2shape, { z: x + x })
            }
          })
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should map and recursively flatten, and handle event raised error", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: 1,
          b: 1 + 1, // a + a,
          c: 2 + 2, // b + b,
          d: 4 + 4, // c + c,
          e: 8 + 8, // d + d
        }
        const e1 = hot("  (a|)         ", values)
        const e1subs = "  (^!)         "
        const e2shape = " ---(z|)      "
        const expected = "a--b--c--(d#)"
        const result = e1.pipe(
          expand(x => {
            if (x === 8) {
              return cold<number>("#")
            }
            return cold(e2shape, { z: x + x })
          })
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should map and recursively flatten, and propagate error thrown from projection", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: 1,
          b: 1 + 1, // a + a,
          c: 2 + 2, // b + b,
          d: 4 + 4, // c + c,
          e: 8 + 8, // d + d
        }
        const e1 = hot("  (a|)         ", values)
        const e1subs = "  (^!)         "
        const e2shape = " ---(z|)      "
        const expected = "a--b--c--(d#)"
        const result = e1.pipe(
          expand(x => {
            if (x === 8) {
              throw "error"
            }
            return cold(e2shape, { z: x + x })
          })
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should allow unsubscribing early", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: 1,
          b: 1 + 1, // a + a,
          c: 2 + 2, // b + b,
          d: 4 + 4, // c + c,
          e: 8 + 8, // d + d
        }
        const e1 = hot("  (a|)    ", values)
        const unsub = "   -------!"
        const e1subs = "  (^!)    "
        const e2shape = " ---(z|) "
        const expected = "a--b--c-"
        const result = e1.pipe(
          expand((x): Observable<any> => {
            if (x === 16) {
              return EMPTY
            }
            return cold(e2shape, { z: x + x })
          })
        )
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: 1,
          b: 1 + 1, // a + a,
          c: 2 + 2, // b + b,
          d: 4 + 4, // c + c,
          e: 8 + 8, // d + d
        }
        const e1 = hot("  (a|)    ", values)
        const e1subs = "  (^!)    "
        const e2shape = " ---(z|) "
        const expected = "a--b--c-"
        const unsub = "   -------!"
        const result = e1.pipe(
          mergeMap(x => of(x)),
          expand((x): Observable<any> => {
            if (x === 16) {
              return EMPTY
            }
            return cold(e2shape, { z: x + x })
          }),
          mergeMap(x => of(x))
        )
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should allow concurrent expansions", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: 1,
          b: 1 + 1, // a + a,
          c: 2 + 2, // b + b,
          d: 4 + 4, // c + c,
          e: 8 + 8, // d + d
        }
        const e1 = hot("  a-a|              ", values)
        const e1subs = "  ^--!              "
        const e2shape = " ---(z|)           "
        const expected = "a-ab-bc-cd-de-(e|)"
        const result = e1.pipe(
          expand((x): Observable<any> => {
            if (x === 16) {
              return EMPTY
            }
            return cold(e2shape, { z: x + x })
          })
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should allow configuring the concurrency limit parameter to 1", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: 1,
          b: 1 + 1, // a + a,
          c: 2 + 2, // b + b,
          d: 4 + 4, // c + c,
          e: 8 + 8, // d + d
          u: 10,
          v: 20, // u + u
          x: 40, // v + v
          y: 80, // x + x
          z: 160, // y + y
        }
        const e1 = hot("  a-u|                         ", values)
        const e1subs = "  ^--!                         "
        const e2shape = " ---(z|)                      "
        //                 ---(z|)
        //                    ---(z|)
        //                       ---(z|)
        //                          ---(z|)
        //                             ---(z|)
        //                                ---(z|)
        //                                   ---(z|)
        // Notice how for each column, there is at most 1 `-` character.
        const expected = "a--u--b--v--c--x--d--y--(ez|)"
        const concurrencyLimit = 1
        const result = e1.pipe(
          expand((x): Observable<any> => {
            if (x === 16 || x === 160) {
              return EMPTY
            }
            return cold(e2shape, { z: x + x })
          }, concurrencyLimit)
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should allow configuring the concurrency limit parameter to 2", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: 1,
          b: 1 + 1, // a + a,
          c: 2 + 2, // b + b,
          u: 10,
          v: 20, // u + u
          x: 40, // v + v
        }
        const e1 = hot("  a---au|                   ", values)
        const e1subs = "  ^-----!                   "
        const e2shape = " ------(z|)                "
        //                  ------(z|)
        //                    ------(z|)
        //                        ------(z|)
        //                          ------(z|)
        //                              ------(z|)
        //                                ------(z|)
        // Notice how for each column, there is at most 2 `-` characters.
        const expected = "a---a-u---b-b---v-(cc)(x|)"
        const concurrencyLimit = 2
        const result = e1.pipe(
          expand((x): Observable<any> => {
            if (x === 4 || x === 40) {
              return EMPTY
            }
            return cold(e2shape, { z: x + x })
          }, concurrencyLimit)
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should ignore concurrency limit if it is not passed", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: 1,
          b: 1 + 1, // a + a,
          c: 2 + 2, // b + b,
          d: 4 + 4, // c + c,
          e: 8 + 8, // d + d
          u: 10,
          v: 20, // u + u
          x: 40, // v + v
          y: 80, // x + x
          z: 160, // y + y
        }
        const e1 = hot("  a-u|              ", values)
        const e1subs = "  ^--!              "
        const e2shape = " ---(z|)           "
        const expected = "a-ub-vc-xd-ye-(z|)"
        const concurrencyLimit = 100
        const result = e1.pipe(
          expand((x): Observable<any> => {
            if (x === 16 || x === 160) {
              return EMPTY
            }
            return cold(e2shape, { z: x + x })
          }, concurrencyLimit)
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should map and recursively flatten with scalars", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: 1,
        b: 1 + 1, // a + a,
        c: 2 + 2, // b + b,
        d: 4 + 4, // c + c,
        e: 8 + 8, // d + d
      }
      const e1 = hot("  (a|)    ", values)
      const e1subs = "  (^!)    "
      const expected = "(abcde|)"
      const result = e1.pipe(
        expand(x => {
          if (x === 16) {
            return EMPTY
          }
          return of(x + x) // scalar
        })
      )
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should recursively flatten promises", done => {
    const expected = [1, 2, 4, 8, 16]
    of(1)
      .pipe(
        expand((x): any => {
          if (x === 16) {
            return EMPTY
          }
          return Promise.resolve(x + x)
        })
      )
      .subscribe({
        next: x => {
          expect(x).to.equal(expected.shift())
        },
        complete: () => {
          expect(expected.length).to.equal(0)
          done()
        },
      })
  })
  it("should recursively flatten Arrays", done => {
    const expected = [1, 2, 4, 8, 16]
    of(1)
      .pipe(
        expand((x): any => {
          if (x === 16) {
            return EMPTY
          }
          return [x + x]
        })
      )
      .subscribe({
        next: x => {
          expect(x).to.equal(expected.shift())
        },
        complete: () => {
          expect(expected.length).to.equal(0)
          done()
        },
      })
  })
  it("should recursively flatten lowercase-o observables", done => {
    const expected = [1, 2, 4, 8, 16]
    const project = (x: number): qt.Observable<number> => {
      if (x === 16) {
        return EMPTY as any
      }
      return {
        subscribe(observer: Observer<number>) {
          observer.next(x + x)
          observer.complete()
        },
        [Symbol.observable]() {
          return this
        },
      } as any
    }
    of(1)
      .pipe(expand(project))
      .subscribe({
        next: x => {
          expect(x).to.equal(expected.shift())
        },
        complete: () => {
          expect(expected.length).to.equal(0)
          done()
        },
      })
  })
  it("should work when passing undefined for the optional arguments", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: 1,
          b: 1 + 1, // a + a,
          c: 2 + 2, // b + b,
          d: 4 + 4, // c + c,
          e: 8 + 8, // d + d
        }
        const e1 = hot("  (a|)            ", values)
        const e1subs = "  (^!)            "
        const e2shape = " ---(z|)         "
        const expected = "a--b--c--d--(e|)"
        const project = (x: any, index: number): Observable<any> => {
          if (x === 16) {
            return EMPTY
          }
          return cold(e2shape, { z: x + x })
        }
        const result = e1.pipe(expand(project, undefined, undefined))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should work with the AsapScheduler", done => {
    const expected = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    of(0)
      .pipe(
        expand(x => of(x + 1), Infinity, asapScheduler),
        take(10),
        toArray()
      )
      .subscribe({
        next: actual => expect(actual).to.deep.equal(expected),
        error: done,
        complete: done,
      })
  })
  it("should work with the AsyncScheduler", done => {
    const expected = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    of(0)
      .pipe(
        expand(x => of(x + 1), Infinity, asyncScheduler),
        take(10),
        toArray()
      )
      .subscribe({
        next: actual => expect(actual).to.deep.equal(expected),
        error: done,
        complete: done,
      })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        expand(() => EMPTY),
        take(3)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { filter, tap, map, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of, Observable, from } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {filter} */
describe("filter", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  function oddFilter(x: number | string) {
    return +x % 2 === 1
  }
  function isPrime(i: number | string) {
    if (+i <= 1) {
      return false
    }
    const max = Math.floor(Math.sqrt(+i))
    for (let j = 2; j <= max; ++j) {
      if (+i % j === 0) {
        return false
      }
    }
    return true
  }
  it("should filter out even values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --0--1--2--3--4--|")
      const e1subs = "  ^----------------!"
      const expected = "-----1-----3-----|"
      expectObservable(e1.pipe(filter(oddFilter))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should filter in only prime numbers", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1--2--^-3-4-5-6--7-8--9--|")
      const e1subs = "       ^------------------!"
      const expected = "     --3---5----7-------|"
      expectObservable(e1.pipe(filter(isPrime))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should filter with an always-true predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1--2--^-3-4-5-6--7-8--9--|")
      const e1subs = "       ^------------------!"
      const expected = "     --3-4-5-6--7-8--9--|"
      const predicate = () => {
        return true
      }
      expectObservable(e1.pipe(filter(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should filter with an always-false predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1--2--^-3-4-5-6--7-8--9--|")
      const e1subs = "       ^------------------!"
      const expected = "     -------------------|"
      const predicate = () => {
        return false
      }
      expectObservable(e1.pipe(filter(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should filter in only prime numbers, source unsubscribes early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1--2--^-3-4-5-6--7-8--9--|")
      const e1subs = "       ^-----------!       "
      const expected = "     --3---5----7-       "
      const unsub = "        ------------!       "
      expectObservable(e1.pipe(filter(isPrime)), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should filter in only prime numbers, source throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1--2--^-3-4-5-6--7-8--9--#")
      const e1subs = "       ^------------------!"
      const expected = "     --3---5----7-------#"
      expectObservable(e1.pipe(filter(isPrime))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should filter in only prime numbers, but predicate throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1--2--^-3-4-5-6--7-8--9--|")
      const e1subs = "       ^-------!           "
      const expected = "     --3---5-#           "
      let invoked = 0
      function predicate(x: any) {
        invoked++
        if (invoked === 4) {
          throw "error"
        }
        return isPrime(x)
      }
      expectObservable(e1.pipe(filter(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should filter in only prime numbers, predicate with index", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1--2--^-3-4-5-6--7-8--9--|")
      const e1subs = "       ^------------------!"
      const expected = "     --3--------7-------|"
      function predicate(x: any, i: number) {
        return isPrime(+x + i * 10)
      }
      expectObservable(e1.pipe(filter(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should invoke predicate once for each checked value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1--2--^-3-4-5-6--7-8--9--|")
      const e1subs = "       ^------------------!"
      const expected = "     --3---5----7-------|"
      let invoked = 0
      const predicate = (x: any) => {
        invoked++
        return isPrime(x)
      }
      const result = e1.pipe(
        filter(predicate),
        tap({
          complete: () => {
            expect(invoked).to.equal(7)
          },
        })
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should filter in only prime numbers, predicate with index, source unsubscribes early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1--2--^-3-4-5-6--7-8--9--|")
      const e1subs = "       ^-----------!       "
      const expected = "     --3--------7-       "
      const unsub = "        ------------!       "
      function predicate(x: any, i: number) {
        return isPrime(+x + i * 10)
      }
      expectObservable(e1.pipe(filter(predicate)), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should filter in only prime numbers, predicate with index, source throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1--2--^-3-4-5-6--7-8--9--#")
      const e1subs = "       ^------------------!"
      const expected = "     --3--------7-------#"
      function predicate(x: any, i: number) {
        return isPrime(+x + i * 10)
      }
      expectObservable(e1.pipe(filter(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should filter in only prime numbers, predicate with index and throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1--2--^-3-4-5-6--7-8--9--|")
      const e1subs = "       ^-------!           "
      const expected = "     --3-----#           "
      let invoked = 0
      function predicate(x: any, i: number) {
        invoked++
        if (invoked === 4) {
          throw "error"
        }
        return isPrime(+x + i * 10)
      }
      expectObservable(e1.pipe(filter(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should compose with another filter to allow multiples of six", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1--2--^-3-4-5-6--7-8--9--|")
      const e1subs = "       ^------------------!"
      const expected = "     --------6----------|"
      const result = e1.pipe(
        filter((x: string) => +x % 2 === 0),
        filter((x: string) => +x % 3 === 0)
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should be able to accept and use a thisArg", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1--2--^-3-4-5-6--7-8--9--|")
      const e1subs = "       ^------------------!"
      const expected = "     --------6----------|"
      class Filterer {
        filter1 = (x: string) => +x % 2 === 0
        filter2 = (x: string) => +x % 3 === 0
      }
      const filterer = new Filterer()
      const result = e1.pipe(
        filter(function (this: any, x) {
          return this.filter1(x)
        }, filterer),
        filter(function (this: any, x) {
          return this.filter2(x)
        }, filterer),
        filter(function (this: any, x) {
          return this.filter1(x)
        }, filterer)
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should be able to use filter and map composed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1--2--^-3-4-5-6--7-8--9--|")
      const e1subs = "       ^------------------!"
      const expected = "     ----a---b----c-----|"
      const values = { a: 16, b: 36, c: 64 }
      const result = e1.pipe(
        filter((x: string) => +x % 2 === 0),
        map((x: string) => +x * +x)
      )
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should propagate errors from the source", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --0--1--2--3--4--#")
      const e1subs = "  ^----------------!"
      const expected = "-----1-----3-----#"
      expectObservable(e1.pipe(filter(oddFilter))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      expectObservable(e1.pipe(filter(oddFilter))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(filter(oddFilter))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle throw", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      expectObservable(e1.pipe(filter(oddFilter))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should send errors down the error path", done => {
    of(42)
      .pipe(
        filter((x: number, index: number): boolean => {
          throw "bad"
        })
      )
      .subscribe({
        next: (x: number) => {
          done(new Error("should not be called"))
        },
        error: (err: any) => {
          expect(err).to.equal("bad")
          done()
        },
        complete: () => {
          done(new Error("should not be called"))
        },
      })
  })
  it("should not break unsubscription chain when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1--2--^-3-4-5-6--7-8--9--|")
      const e1subs = "       ^-----------!       "
      const expected = "     --3---5----7-       "
      const unsub = "        ------------!       "
      const result = e1.pipe(
        mergeMap((x: any) => of(x)),
        filter(isPrime),
        mergeMap((x: any) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should support type guards without breaking previous behavior", () => {
    // tslint:disable no-unused-variable
    // type guards with interfaces and classes
    {
      interface Bar {
        bar?: string
      }
      interface Baz {
        baz?: number
      }
      class Foo implements Bar, Baz {
        constructor(public bar: string = "name", public baz: number = 42) {}
      }
      const isBar = (x: any): x is Bar => x && (<Bar>x).bar !== undefined
      const isBaz = (x: any): x is Baz => x && (<Baz>x).baz !== undefined
      const foo: Foo = new Foo()
      of(foo)
        .pipe(filter(foo => foo.baz === 42))
        .subscribe(x => x.baz) // x is still Foo
      of(foo)
        .pipe(filter(isBar))
        .subscribe(x => x.bar) // x is Bar!
      const foobar: Bar = new Foo() // type is interface, not the class
      of(foobar)
        .pipe(filter(foobar => foobar.bar === "name"))
        .subscribe(x => x.bar) // <-- x is still Bar
      of(foobar)
        .pipe(filter(isBar))
        .subscribe(x => x.bar) // <--- x is Bar!
      const barish = { bar: "quack", baz: 42 } // type can quack like a Bar
      of(barish)
        .pipe(filter(x => x.bar === "quack"))
        .subscribe(x => x.bar) // x is still { bar: string; baz: number; }
      of(barish)
        .pipe(filter(isBar))
        .subscribe(bar => bar.bar) // x is Bar!
    }
    // type guards with primitive types
    {
      const xs: Observable<string | number> = from([1, "aaa", 3, "bb"])
      // This type guard will narrow a `string | number` to a string in the examples below
      const isString = (x: string | number): x is string =>
        typeof x === "string"
      xs.pipe(filter(isString)).subscribe(s => s.length) // s is string
      // In contrast, this type of regular boolean predicate still maintains the original type
      xs.pipe(filter(x => typeof x === "number")).subscribe(x => x) // x is still string | number
      xs.pipe(filter((x, i) => typeof x === "number" && x > i)).subscribe(
        x => x
      ) // x is still string | number
    }
    // tslint:disable enable
  })
  it("should support Boolean as a predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { t: 1, f: 0 }
      const e1 = hot("-t--f--^-t-f-t-f--t-f--f--|", values)
      const e1subs = "       ^------------------!"
      const expected = "     --t---t----t-------|"
      expectObservable(e1.pipe(filter(Boolean))).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        filter(() => true),
        take(3)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { finalize, map, share, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
import { of, timer, interval, NEVER, Observable, noop } from "rxjs"
import { asInteropObservable } from "../helpers/interop-helper"
/** @test {finalize} */
describe("finalize", () => {
  it("should call finalize after complete", done => {
    let completed = false
    of(1, 2, 3)
      .pipe(
        finalize(() => {
          expect(completed).to.be.true
          done()
        })
      )
      .subscribe({
        complete: () => {
          completed = true
        },
      })
  })
  it("should call finalize after error", done => {
    let thrown = false
    of(1, 2, 3)
      .pipe(
        map(function (x) {
          if (x === 3) {
            throw x
          }
          return x
        }),
        finalize(() => {
          expect(thrown).to.be.true
          done()
        })
      )
      .subscribe({
        error: () => {
          thrown = true
        },
      })
  })
  it("should call finalize upon disposal", done => {
    let disposed = false
    const subscription = timer(100)
      .pipe(
        finalize(() => {
          expect(disposed).to.be.true
          done()
        })
      )
      .subscribe()
    disposed = true
    subscription.unsubscribe()
  })
  it("should call finalize when synchronously subscribing to and unsubscribing from a shared Observable", done => {
    interval(50).pipe(finalize(done), share()).subscribe().unsubscribe()
  })
  it("should call two finalize instances in succession on a shared Observable", done => {
    let invoked = 0
    function checkFinally() {
      invoked += 1
      if (invoked === 2) {
        done()
      }
    }
    of(1, 2, 3)
      .pipe(finalize(checkFinally), finalize(checkFinally), share())
      .subscribe()
  })
  it("should handle empty", () => {
    const testScheduler = new TestScheduler(observableMatcher)
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      let executed = false
      const e1 = hot("  |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      const result = e1.pipe(finalize(() => (executed = true)))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      // manually flush so `finalize()` has chance to execute before the test is over.
      testScheduler.flush()
      expect(executed).to.be.true
    })
  })
  it("should handle never", () => {
    const testScheduler = new TestScheduler(observableMatcher)
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      let executed = false
      const e1 = hot("  -")
      const e1subs = "  ^"
      const expected = "-"
      const result = e1.pipe(finalize(() => (executed = true)))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      // manually flush so `finalize()` has chance to execute before the test is over.
      testScheduler.flush()
      expect(executed).to.be.false
    })
  })
  it("should handle throw", () => {
    const testScheduler = new TestScheduler(observableMatcher)
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      let executed = false
      const e1 = hot("  #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      const result = e1.pipe(finalize(() => (executed = true)))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      // manually flush so `finalize()` has chance to execute before the test is over.
      testScheduler.flush()
      expect(executed).to.be.true
    })
  })
  it("should handle basic hot observable", () => {
    const testScheduler = new TestScheduler(observableMatcher)
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      let executed = false
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^----------!"
      const expected = "--a--b--c--|"
      const result = e1.pipe(finalize(() => (executed = true)))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      // manually flush so `finalize()` has chance to execute before the test is over.
      testScheduler.flush()
      expect(executed).to.be.true
    })
  })
  it("should handle basic cold observable", () => {
    const testScheduler = new TestScheduler(observableMatcher)
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      let executed = false
      const e1 = cold(" --a--b--c--|")
      const e1subs = "  ^----------!"
      const expected = "--a--b--c--|"
      const result = e1.pipe(finalize(() => (executed = true)))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      // manually flush so `finalize()` has chance to execute before the test is over.
      testScheduler.flush()
      expect(executed).to.be.true
    })
  })
  it("should handle basic error", () => {
    const testScheduler = new TestScheduler(observableMatcher)
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      let executed = false
      const e1 = hot("  --a--b--c--#")
      const e1subs = "  ^----------!"
      const expected = "--a--b--c--#"
      const result = e1.pipe(finalize(() => (executed = true)))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      // manually flush so `finalize()` has chance to execute before the test is over.
      testScheduler.flush()
      expect(executed).to.be.true
    })
  })
  it("should handle unsubscription", () => {
    const testScheduler = new TestScheduler(observableMatcher)
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      let executed = false
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^-----!     "
      const expected = "--a--b-"
      const unsub = "   ------!"
      const result = e1.pipe(finalize(() => (executed = true)))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      // manually flush so `finalize()` has chance to execute before the test is over.
      testScheduler.flush()
      expect(executed).to.be.true
    })
  })
  it("should handle interop source observables", () => {
    // https://github.com/ReactiveX/rxjs/issues/5237
    let finalized = false
    const subscription = asInteropObservable(NEVER)
      .pipe(finalize(() => (finalized = true)))
      .subscribe()
    subscription.unsubscribe()
    expect(finalized).to.be.true
  })
  it("should finalize sources before sinks", () => {
    const finalized: string[] = []
    of(42)
      .pipe(
        finalize(() => finalized.push("source")),
        finalize(() => finalized.push("sink"))
      )
      .subscribe()
    expect(finalized).to.deep.equal(["source", "sink"])
  })
  it("should finalize after the finalization", () => {
    const order: string[] = []
    const source = new Observable<void>(() => {
      return () => order.push("finalizer")
    })
    const subscription = source
      .pipe(finalize(() => order.push("finalize")))
      .subscribe()
    subscription.unsubscribe()
    expect(order).to.deep.equal(["finalizer", "finalize"])
  })
  it("should finalize after the finalizer with synchronous completion", () => {
    const order: string[] = []
    const source = new Observable<void>(subscriber => {
      subscriber.complete()
      return () => order.push("finalizer")
    })
    source.pipe(finalize(() => order.push("finalize"))).subscribe()
    expect(order).to.deep.equal(["finalizer", "finalize"])
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        finalize(() => {
          /* noop */
        }),
        take(3)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
  it("should execute finalize even with a sync thrown error", () => {
    let called = false
    const badObservable = new Observable(() => {
      throw new Error("bad")
    }).pipe(
      finalize(() => {
        called = true
      })
    )
    badObservable.subscribe({
      error: noop,
    })
    expect(called).to.be.true
  })
  it("should execute finalize in order even with a sync error", () => {
    const results: any[] = []
    const badObservable = new Observable(subscriber => {
      subscriber.error(new Error("bad"))
    }).pipe(
      finalize(() => {
        results.push(1)
      }),
      finalize(() => {
        results.push(2)
      })
    )
    badObservable.subscribe({
      error: noop,
    })
    expect(results).to.deep.equal([1, 2])
  })
  it("should execute finalize in order even with a sync thrown error", () => {
    const results: any[] = []
    const badObservable = new Observable(() => {
      throw new Error("bad")
    }).pipe(
      finalize(() => {
        results.push(1)
      }),
      finalize(() => {
        results.push(2)
      })
    )
    badObservable.subscribe({
      error: noop,
    })
    expect(results).to.deep.equal([1, 2])
  })
  it("should finalize in the proper order", () => {
    const results: any[] = []
    of(1)
      .pipe(
        finalize(() => results.push(1)),
        finalize(() => results.push(2)),
        finalize(() => results.push(3)),
        finalize(() => results.push(4))
      )
      .subscribe()
    expect(results).to.deep.equal([1, 2, 3, 4])
  })
})
import { expect } from "chai"
import { find, mergeMap, delay } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
import { of, Observable, from } from "rxjs"
/** @test {find} */
describe("find", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  function truePredicate(x: any) {
    return true
  }
  it("should return matching element from source emits single element", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: 3, b: 9, c: 15, d: 20 }
      const e1 = hot("  ---a--b--c--d---|", values)
      const e1subs = "  ^--------!       "
      const expected = "---------(c|)    "
      const predicate = function (x: number) {
        return x % 5 === 0
      }
      expectObservable(e1.pipe(find(predicate))).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not emit if source does not emit", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(find(truePredicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return undefined if source is empty to match predicate", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "(x|)"
      const result = e1.pipe(find(truePredicate))
      expectObservable(result).toBe(expected, { x: undefined })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return matching element from source emits single element", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--|")
      const e1subs = "  ^-!   "
      const expected = "--(a|)"
      const predicate = function (value: string) {
        return value === "a"
      }
      expectObservable(e1.pipe(find(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return matching element from source emits multiple elements", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b---c-|")
      const e1subs = "  ^----!      "
      const expected = "-----(b|)   "
      const predicate = function (value: string) {
        return value === "b"
      }
      expectObservable(e1.pipe(find(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work with a custom thisArg", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b---c-|")
      const e1subs = "  ^----!      "
      const expected = "-----(b|)   "
      const finder = {
        target: "b",
      }
      const predicate = function (this: typeof finder, value: string) {
        return value === this.target
      }
      expectObservable(e1.pipe(find(predicate, finder))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return undefined if element does not match with predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|   ")
      const e1subs = "  ^----------!   "
      const expected = "-----------(x|)"
      const predicate = function (value: string) {
        return value === "z"
      }
      expectObservable(e1.pipe(find(predicate))).toBe(expected, {
        x: undefined,
      })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^-----!     "
      const expected = "-------     "
      const unsub = "   ------!     "
      const result = e1.pipe(find((value: string) => value === "z"))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^-----!     "
      const expected = "-------     "
      const unsub = "   ------!     "
      const result = e1.pipe(
        mergeMap(x => of(x)),
        find(value => value === "z"),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should unsubscribe when the predicate is matched", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--b---c-|")
        const e1subs = "  ^----!      "
        const t = time("    --|       ")
        //                     --|
        const expected = "-------(b|) "
        const result = e1.pipe(
          find((value: string) => value === "b"),
          delay(t)
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should raise if source raise error while element does not match with predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--#")
      const e1subs = "  ^-------!"
      const expected = "--------#"
      const predicate = function (value: string) {
        return value === "z"
      }
      expectObservable(e1.pipe(find(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if predicate throws error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^-!         "
      const expected = "--#         "
      const predicate = function (value: string) {
        throw "error"
      }
      expectObservable(e1.pipe(find(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should support type guards without breaking previous behavior", () => {
    // tslint:disable no-unused-variable
    // type guards with interfaces and classes
    {
      interface Bar {
        bar?: string
      }
      interface Baz {
        baz?: number
      }
      class Foo implements Bar, Baz {
        constructor(public bar: string = "name", public baz: number = 42) {}
      }
      const isBar = (x: any): x is Bar => x && (<Bar>x).bar !== undefined
      const isBaz = (x: any): x is Baz => x && (<Baz>x).baz !== undefined
      const foo: Foo = new Foo()
      of(foo)
        .pipe(find(foo => foo.baz === 42))
        .subscribe(x => x!.baz) // x is still Foo
      of(foo)
        .pipe(find(isBar))
        .subscribe(x => x!.bar) // x is Bar!
      const foobar: Bar = new Foo() // type is interface, not the class
      of(foobar)
        .pipe(find(foobar => foobar.bar === "name"))
        .subscribe(x => x!.bar) // <-- x is still Bar
      of(foobar)
        .pipe(find(isBar))
        .subscribe(x => x!.bar) // <--- x is Bar!
      const barish = { bar: "quack", baz: 42 } // type can quack like a Bar
      of(barish)
        .pipe(find(x => x.bar === "quack"))
        .subscribe(x => x!.bar) // x is still { bar: string; baz: number; }
      of(barish)
        .pipe(find(isBar))
        .subscribe(bar => bar!.bar) // x is Bar!
    }
    // type guards with primitive types
    {
      const xs: Observable<string | number> = from([1, "aaa", 3, "bb"])
      // This type guard will narrow a `string | number` to a string in the examples below
      const isString = (x: string | number): x is string =>
        typeof x === "string"
      xs.pipe(find(isString)).subscribe(s => s!.length) // s is string
      // In contrast, this type of regular boolean predicate still maintains the original type
      xs.pipe(find(x => typeof x === "number")).subscribe(x => x) // x is still string | number
      xs.pipe(find((x, i) => typeof x === "number" && x > i)).subscribe(x => x) // x is still string | number
    }
    // tslint:disable enable
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits, it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(find(value => value === 2)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { findIndex, mergeMap, delay } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
import { of, Observable } from "rxjs"
/** @test {findIndex} */
describe("findIndex", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  function truePredicate(x: any) {
    return true
  }
  it("should return matching element from source emits single element", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: 3, b: 9, c: 15, d: 20 }
      const e1 = hot("  ---a--b--c--d---|", values)
      const e1subs = "  ^--------!       "
      const expected = "---------(x|)    "
      const predicate = function (x: number) {
        return x % 5 === 0
      }
      expectObservable(e1.pipe(findIndex(predicate))).toBe(expected, { x: 2 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not emit if source does not emit", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(findIndex(truePredicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return negative index if source is empty to match predicate", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "(x|)"
      const result = e1.pipe(findIndex(truePredicate))
      expectObservable(result).toBe(expected, { x: -1 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return index of element from source emits single element", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--|", { a: 1 })
      const e1subs = "  ^-!   "
      const expected = "--(x|)"
      const predicate = function (value: number) {
        return value === 1
      }
      expectObservable(e1.pipe(findIndex(predicate))).toBe(expected, { x: 0 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return index of matching element from source emits multiple elements", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b---c-|", { b: 7 })
      const e1subs = "  ^----!      "
      const expected = "-----(x|)   "
      const predicate = function (value: number) {
        return value === 7
      }
      expectObservable(e1.pipe(findIndex(predicate))).toBe(expected, { x: 1 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work with a custom thisArg", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const sourceValues = { b: 7 }
      const e1 = hot("  --a--b---c-|", sourceValues)
      const e1subs = "  ^----!      "
      const expected = "-----(x|)   "
      const predicate = function (this: typeof sourceValues, value: number) {
        return value === this.b
      }
      const result = e1.pipe(findIndex(predicate, sourceValues))
      expectObservable(result).toBe(expected, { x: 1 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return negative index if element does not match with predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|   ")
      const e1subs = "  ^----------!   "
      const expected = "-----------(x|)"
      const predicate = function (value: string) {
        return value === "z"
      }
      expectObservable(e1.pipe(findIndex(predicate))).toBe(expected, { x: -1 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^-----!     "
      const expected = "-------     "
      const unsub = "   ------!     "
      const result = e1.pipe(findIndex((value: string) => value === "z"))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^-----!     "
      const expected = "-------     "
      const unsub = "   ------!     "
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        findIndex((value: string) => value === "z"),
        mergeMap((x: number) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should unsubscribe when the predicate is matched", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--b---c-|")
        const e1subs = "  ^----!      "
        const t = time("    --|       ")
        //                     --|
        const expected = "-------(x|) "
        const result = e1.pipe(
          findIndex((value: string) => value === "b"),
          delay(t)
        )
        expectObservable(result).toBe(expected, { x: 1 })
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should raise if source raise error while element does not match with predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--#")
      const e1subs = "  ^-------!"
      const expected = "--------#"
      const predicate = function (value: string) {
        return value === "z"
      }
      expectObservable(e1.pipe(findIndex(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if predicate throws error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^-!         "
      const expected = "--#         "
      const predicate = function (value: string) {
        throw "error"
      }
      expectObservable(e1.pipe(findIndex(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits, it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(findIndex(value => value === 2))
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { observableMatcher } from "../helpers/observableMatcher"
import { first, mergeMap, delay } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of, from, Observable, Subject, EmptyError } from "rxjs"
/** @test {first} */
describe("first", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should take the first value of an observable with many values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -----a--b--c---d---|")
      const e1subs = "  ^----!              "
      const expected = "-----(a|)           "
      expectObservable(e1.pipe(first())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should take the first value of an observable with one value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---(a|)")
      const e1subs = "  ^--!   "
      const expected = "---(a|)"
      expectObservable(e1.pipe(first())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow undefined as a default value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -----a--a---a-|   ")
      const e1subs = "  ^-------------!   "
      const expected = "--------------(U|)"
      expectObservable(e1.pipe(first(value => value === "b", undefined))).toBe(
        expected,
        { U: undefined }
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should error on empty", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^----|")
      const e1subs = "     ^----!"
      const expected = "   -----#"
      expectObservable(e1.pipe(first())).toBe(expected, null, new EmptyError())
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return the default value if source observable was empty", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-----^----|   ")
      const e1subs = "     ^----!   "
      const expected = "   -----(a|)"
      expectObservable(e1.pipe(first(null, "a"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should only emit one value in recursive cases", () => {
    const subject = new Subject<number>()
    const results: number[] = []
    subject.pipe(first()).subscribe(x => {
      results.push(x)
      subject.next(x + 1)
    })
    subject.next(0)
    expect(results).to.deep.equal([0])
  })
  it("should propagate error from the source observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^---#")
      const e1subs = "   ^---!"
      const expected = " ----#"
      expectObservable(e1.pipe(first())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should go on forever on never", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--^-------")
      const e1subs = "  ^-------"
      const expected = "--------"
      expectObservable(e1.pipe(first())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^-----b----c---d--|")
      const e1subs = "     ^--!               "
      const expected = "   ----               "
      const unsub = "      ---!               "
      expectObservable(e1.pipe(first()), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^-----b----c---d--|")
      const e1subs = "     ^--!               "
      const expected = "   ----               "
      const unsub = "      ---!               "
      const result = e1.pipe(
        mergeMap(x => of(x)),
        first(),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should unsubscribe when the first value is received", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--b---c-|")
        const e1subs = "  ^-!         "
        const t = time("    --|       ")
        const expected = "----(a|)    "
        const result = e1.pipe(first(), delay(t))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should return first value that matches a predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^--b--c--a--c--|")
      const e1subs = "    ^-----!         "
      const expected = "  ------(c|)      "
      expectObservable(e1.pipe(first(value => value === "c"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return first value that matches a predicate for odd numbers", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: 1, b: 2, c: 3, d: 4, e: 5 }
      const e1 = hot("--a-^--b--c--d--e--|", values)
      const e1subs = "    ^-----!         "
      const expected = "  ------(c|)      "
      expectObservable(e1.pipe(first(x => x % 2 === 1))).toBe(expected, {
        c: 3,
      })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should error when no value matches the predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^--b--c--a--c--|")
      const e1subs = "    ^--------------!"
      const expected = "  ---------------#"
      expectObservable(e1.pipe(first(x => x === "s"))).toBe(
        expected,
        null,
        new EmptyError()
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return the default value when no value matches the predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^--b--c--a--c--|   ")
      const e1subs = "    ^--------------!   "
      const expected = "  ---------------(d|)"
      expectObservable(e1.pipe(first(x => x === "s", "d"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should propagate error when no value matches the predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^--b--c--a--#")
      const e1subs = "    ^-----------!"
      const expected = "  ------------#"
      expectObservable(e1.pipe(first(x => x === "s"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return first value that matches the index in the predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^--b--c--a--c--|")
      const e1subs = "    ^--------!      "
      const expected = "  ---------(a|)   "
      expectObservable(e1.pipe(first((_, i) => i === 2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should propagate error from predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: 1, b: 2, c: 3, d: 4, e: 5 }
      const e1 = hot("--a-^--b--c--d--e--|", values)
      const e1subs = "    ^--------!      "
      const expected = "  ---------#      "
      const predicate = function (value: number) {
        if (value < 4) {
          return false
        } else {
          throw "error"
        }
      }
      expectObservable(e1.pipe(first(predicate))).toBe(expected, null, "error")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should support type guards without breaking previous behavior", () => {
    // tslint:disable no-unused-variable
    // type guards with interfaces and classes
    {
      interface Bar {
        bar?: string
      }
      interface Baz {
        baz?: number
      }
      class Foo implements Bar, Baz {
        constructor(public bar: string = "name", public baz: number = 42) {}
      }
      const isBar = (x: any): x is Bar => x && (x as Bar).bar !== undefined
      const isBaz = (x: any): x is Baz => x && (x as Baz).baz !== undefined
      const foo: Foo = new Foo()
      of(foo)
        .pipe(first())
        .subscribe(x => x.baz) // x is Foo
      of(foo)
        .pipe(first(foo => foo.bar === "name"))
        .subscribe(x => x.baz) // x is still Foo
      of(foo)
        .pipe(first(isBar))
        .subscribe(x => x.bar) // x is Bar!
      const foobar: Bar = new Foo() // type is the interface, not the class
      of(foobar)
        .pipe(first())
        .subscribe(x => x.bar) // x is Bar
      of(foobar)
        .pipe(first(foobar => foobar.bar === "name"))
        .subscribe(x => x.bar) // x is still Bar
      of(foobar)
        .pipe(first(isBaz))
        .subscribe(x => x.baz) // x is Baz!
      const barish = { bar: "quack", baz: 42 } // type can quack like a Bar
      of(barish)
        .pipe(first())
        .subscribe(x => x.baz) // x is still { bar: string; baz: number; }
      of(barish)
        .pipe(first(x => x.bar === "quack"))
        .subscribe(x => x.bar) // x is still { bar: string; baz: number; }
      of(barish)
        .pipe(first(isBar))
        .subscribe(x => x.bar) // x is Bar!
    }
    // type guards with primitive types
    {
      const xs: Observable<string | number> = from([1, "aaa", 3, "bb"])
      // This type guard will narrow a `string | number` to a string in the examples below
      const isString = (x: string | number): x is string =>
        typeof x === "string"
      // missing predicate preserves the type
      xs.pipe(first()).subscribe(x => x) // x is still string | number
      // null predicate preserves the type
      xs.pipe(first(null)).subscribe(x => x) // x is still string | number
      // undefined predicate preserves the type
      xs.pipe(first(undefined)).subscribe(x => x) // x is still string | number
      // After the type guard `first` predicates, the type is narrowed to string
      xs.pipe(first(isString)).subscribe(s => s.length) // s is string
      // boolean predicates preserve the type
      xs.pipe(first(x => typeof x === "string")).subscribe(x => x) // x is still string | number
    }
    // tslint:disable enable
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits, it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(first(value => value === 2)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import {
  groupBy,
  delay,
  tap,
  map,
  take,
  mergeMap,
  materialize,
  skip,
  ignoreElements,
} from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import {
  ReplaySubject,
  of,
  Observable,
  Operator,
  Observer,
  Subject,
} from "rxjs"
import { createNotification } from "rxjs/internal/NotificationFactories"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {groupBy} */
describe("groupBy operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should group numbers by odd/even", () => {
    testScheduler.run(({ cold, hot, expectObservable }) => {
      const e1 = hot("  --1---2---3---4---5---|")
      const expected = "--x---y---------------|"
      const x = cold("  1-------3-------5---|")
      const y = cold("  2-------4-------|")
      const expectedValues = { x: x, y: y }
      const source = e1.pipe(groupBy((val: string) => parseInt(val) % 2))
      expectObservable(source).toBe(expected, expectedValues)
    })
  })
  function reverseString(str: string) {
    return str.split("").reverse().join("")
  }
  function mapObject(obj: Record<string, any>, fn: Function) {
    const out: Record<string, any> = {}
    for (const p in obj) {
      if (obj.hasOwnProperty(p)) {
        out[p] = fn(obj[p])
      }
    }
    return out
  }
  it("should group values", done => {
    const expectedGroups = [
      { key: 1, values: [1, 3] },
      { key: 0, values: [2] },
    ]
    of(1, 2, 3)
      .pipe(groupBy(x => x % 2))
      .subscribe({
        next: (g: any) => {
          const expectedGroup = expectedGroups.shift()!
          expect(g.key).to.equal(expectedGroup.key)
          g.subscribe((x: any) => {
            expect(x).to.deep.equal(expectedGroup.values.shift())
          })
        },
        complete: done,
      })
  })
  it("should group values with an element selector", done => {
    const expectedGroups = [
      { key: 1, values: ["1!", "3!"] },
      { key: 0, values: ["2!"] },
    ]
    of(1, 2, 3)
      .pipe(
        groupBy(
          x => x % 2,
          x => x + "!"
        )
      )
      .subscribe({
        next: (g: any) => {
          const expectedGroup = expectedGroups.shift()!
          expect(g.key).to.equal(expectedGroup.key)
          g.subscribe((x: any) => {
            expect(x).to.deep.equal(expectedGroup.values.shift())
          })
        },
        complete: done,
      })
  })
  it("should group values with a duration selector", () => {
    const expectedGroups = [
      { key: 1, values: [1, 3] },
      { key: 0, values: [2, 4] },
      { key: 1, values: [5] },
      { key: 0, values: [6] },
    ]
    const resultingGroups: { key: number; values: number[] }[] = []
    of(1, 2, 3, 4, 5, 6)
      .pipe(
        groupBy(x => x % 2, {
          duration: g => g.pipe(skip(1)),
        })
      )
      .subscribe((g: any) => {
        let group = { key: g.key, values: [] as number[] }
        g.subscribe((x: any) => {
          group.values.push(x)
        })
        resultingGroups.push(group)
      })
    expect(resultingGroups).to.deep.equal(expectedGroups)
  })
  it("should group values with a subject selector", done => {
    const expectedGroups = [
      { key: 1, values: [3] },
      { key: 0, values: [2] },
    ]
    of(1, 2, 3)
      .pipe(
        groupBy(x => x % 2, {
          connector: () => new ReplaySubject(1),
        }),
        // Ensure each inner group reaches the destination after the first event
        // has been next'd to the group
        delay(5)
      )
      .subscribe({
        next: (g: any) => {
          const expectedGroup = expectedGroups.shift()!
          expect(g.key).to.equal(expectedGroup.key)
          g.subscribe((x: any) => {
            expect(x).to.deep.equal(expectedGroup.values.shift())
          })
        },
        complete: done,
      })
  })
  it("should handle an empty Observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      const source = e1.pipe(groupBy((val: string) => val.toLowerCase().trim()))
      expectObservable(source).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a never Observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      const source = e1.pipe(groupBy((val: string) => val.toLowerCase().trim()))
      expectObservable(source).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a just-throw Observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  #  ")
      const e1subs = "  (^!)"
      const expected = "#   "
      const source = e1.pipe(groupBy((val: string) => val.toLowerCase().trim()))
      expectObservable(source).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle an Observable with a single value", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = { a: "  foo" }
        const e1 = hot("  ^--a--|", values)
        const e1subs = "  ^-----!"
        const expected = "---g--|"
        const g = cold("     a--|", values)
        const expectedValues = { g: g }
        const source = e1.pipe(
          groupBy((val: string) => val.toLowerCase().trim())
        )
        expectObservable(source).toBe(expected, expectedValues)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should group values with a keySelector", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: "  foo",
          b: " FoO ",
          c: "baR  ",
          d: "foO ",
          e: " Baz   ",
          f: "  qux ",
          g: "   bar",
          h: " BAR  ",
          i: "FOO ",
          j: "baz  ",
          k: " bAZ ",
          l: "    fOo    ",
        }
        const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
        const e1subs = "       ^-------------------------!"
        const expected = "     --w---x---y-z-------------|"
        const w = cold("         a-b---d---------i-----l-|", values)
        const x = cold("             c-------g-h---------|", values)
        const y = cold("                 e---------j-k---|", values)
        const z = cold("                   f-------------|", values)
        const expectedValues = { w: w, x: x, y: y, z: z }
        const source = e1.pipe(
          groupBy((val: string) => val.toLowerCase().trim())
        )
        expectObservable(source).toBe(expected, expectedValues)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should emit GroupObservables", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: "  foo",
          b: " FoO ",
        }
        const e1 = hot("-1--2--^-a-b----|", values)
        const e1subs = "       ^--------!"
        const expected = "     --g------|"
        const expectedValues = { g: "foo" }
        const source = e1.pipe(
          groupBy((val: string) => val.toLowerCase().trim()),
          tap((group: any) => {
            expect(group.key).to.equal("foo")
            expect(group instanceof Observable).to.be.true
          }),
          map((group: any) => {
            return group.key
          })
        )
        expectObservable(source).toBe(expected, expectedValues)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should group values with a keySelector, assert GroupSubject key", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: "  foo",
        b: " FoO ",
        c: "baR  ",
        d: "foO ",
        e: " Baz   ",
        f: "  qux ",
        g: "   bar",
        h: " BAR  ",
        i: "FOO ",
        j: "baz  ",
        k: " bAZ ",
        l: "    fOo    ",
      }
      const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
      const e1subs = "       ^-------------------------!"
      const expected = "     --w---x---y-z-------------|"
      const expectedValues = { w: "foo", x: "bar", y: "baz", z: "qux" }
      const source = e1.pipe(
        groupBy((val: string) => val.toLowerCase().trim()),
        map((g: any) => g.key)
      )
      expectObservable(source).toBe(expected, expectedValues)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should group values with a keySelector, but outer throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: "  foo",
        b: " FoO ",
        c: "baR  ",
        d: "foO ",
        e: " Baz   ",
        f: "  qux ",
        g: "   bar",
        h: " BAR  ",
        i: "FOO ",
        j: "baz  ",
        k: " bAZ ",
        l: "    fOo    ",
      }
      const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-#", values)
      const e1subs = "       ^-------------------------!"
      const expected = "     --w---x---y-z-------------#"
      const expectedValues = { w: "foo", x: "bar", y: "baz", z: "qux" }
      const source = e1.pipe(
        groupBy((val: string) => val.toLowerCase().trim()),
        map((g: any) => g.key)
      )
      expectObservable(source).toBe(expected, expectedValues)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should group values with a keySelector, inners propagate error from outer", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: "  foo",
          b: " FoO ",
          c: "baR  ",
          d: "foO ",
          e: " Baz   ",
          f: "  qux ",
          g: "   bar",
          h: " BAR  ",
          i: "FOO ",
          j: "baz  ",
          k: " bAZ ",
          l: "    fOo    ",
        }
        const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-#", values)
        const e1subs = "       ^-------------------------!"
        const expected = "     --w---x---y-z-------------#"
        const w = cold("         a-b---d---------i-----l-#", values)
        const x = cold("             c-------g-h---------#", values)
        const y = cold("                 e---------j-k---#", values)
        const z = cold("                   f-------------#", values)
        const expectedValues = { w: w, x: x, y: y, z: z }
        const source = e1.pipe(
          groupBy((val: string) => val.toLowerCase().trim())
        )
        expectObservable(source).toBe(expected, expectedValues)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should allow outer to be unsubscribed early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: "  foo",
        b: " FoO ",
        c: "baR  ",
        d: "foO ",
        e: " Baz   ",
        f: "  qux ",
        g: "   bar",
        h: " BAR  ",
        i: "FOO ",
        j: "baz  ",
        k: " bAZ ",
        l: "    fOo    ",
      }
      const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
      const unsub = "        -----------!               "
      const e1subs = "       ^----------!               "
      const expected = "     --w---x---y-               "
      const expectedValues = { w: "foo", x: "bar", y: "baz" }
      const source = e1.pipe(
        groupBy((val: string) => val.toLowerCase().trim()),
        map((group: any) => group.key)
      )
      expectObservable(source, unsub).toBe(expected, expectedValues)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should unsubscribe from the source when the outer and inner subscriptions are disposed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: "  foo",
        b: " FoO ",
        c: "baR  ",
        d: "foO ",
        e: " Baz   ",
        f: "  qux ",
        g: "   bar",
        h: " BAR  ",
        i: "FOO ",
        j: "baz  ",
        k: " bAZ ",
        l: "    fOo    ",
      }
      const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
      const e1subs = "       ^-!                        "
      const expected = "     --(a|)                     "
      const source = e1.pipe(
        groupBy(val => val.toLowerCase().trim()),
        take(1),
        mergeMap(group => group.pipe(take(1)))
      )
      expectObservable(source).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chain when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: "  foo",
        b: " FoO ",
        c: "baR  ",
        d: "foO ",
        e: " Baz   ",
        f: "  qux ",
        g: "   bar",
        h: " BAR  ",
        i: "FOO ",
        j: "baz  ",
        k: " bAZ ",
        l: "    fOo    ",
      }
      const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
      const e1subs = "       ^----------!               "
      const expected = "     --w---x---y-               "
      const unsub = "        -----------!               "
      const expectedValues = { w: "foo", x: "bar", y: "baz" }
      const source = e1.pipe(
        mergeMap((x: string) => of(x)),
        groupBy((x: string) => x.toLowerCase().trim()),
        mergeMap((group: any) => of(group.key))
      )
      expectObservable(source, unsub).toBe(expected, expectedValues)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should group values with a keySelector which eventually throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: "  foo",
          b: " FoO ",
          c: "baR  ",
          d: "foO ",
          e: " Baz   ",
          f: "  qux ",
          g: "   bar",
          h: " BAR  ",
          i: "FOO ",
          j: "baz  ",
          k: " bAZ ",
          l: "    fOo    ",
        }
        const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
        const e1subs = "       ^-------------------!"
        const expected = "     --w---x---y-z-------#"
        const w = cold("         a-b---d---------i-#", values)
        const x = cold("             c-------g-h---#", values)
        const y = cold("                 e---------#", values)
        const z = cold("                   f-------#", values)
        const expectedValues = { w: w, x: x, y: y, z: z }
        let invoked = 0
        const source = e1.pipe(
          groupBy((val: string) => {
            invoked++
            if (invoked === 10) {
              throw "error"
            }
            return val.toLowerCase().trim()
          })
        )
        expectObservable(source).toBe(expected, expectedValues)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should group values with a keySelector and elementSelector, but elementSelector throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: "  foo",
          b: " FoO ",
          c: "baR  ",
          d: "foO ",
          e: " Baz   ",
          f: "  qux ",
          g: "   bar",
          h: " BAR  ",
          i: "FOO ",
          j: "baz  ",
          k: " bAZ ",
          l: "    fOo    ",
        }
        const reversedValues = mapObject(values, reverseString)
        const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
        const e1subs = "       ^-------------------!"
        const expected = "     --w---x---y-z-------#"
        const w = cold("         a-b---d---------i-#", reversedValues)
        const x = cold("             c-------g-h---#", reversedValues)
        const y = cold("                 e---------#", reversedValues)
        const z = cold("                   f-------#", reversedValues)
        const expectedValues = { w: w, x: x, y: y, z: z }
        let invoked = 0
        const source = e1.pipe(
          groupBy(
            (val: string) => val.toLowerCase().trim(),
            (val: string) => {
              invoked++
              if (invoked === 10) {
                throw "error"
              }
              return reverseString(val)
            }
          )
        )
        expectObservable(source).toBe(expected, expectedValues)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should allow the outer to be unsubscribed early but inners continue", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: "  foo",
          b: " FoO ",
          c: "baR  ",
          d: "foO ",
          e: " Baz   ",
          f: "  qux ",
          g: "   bar",
          h: " BAR  ",
          i: "FOO ",
          j: "baz  ",
          k: " bAZ ",
          l: "    fOo    ",
        }
        const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
        const unsub = "         ---------!                "
        const expected = "      --w---x---                "
        const w = cold("        a-b---d---------i-----l-| ", values)
        const x = cold("            c-------g-h---------| ", values)
        const expectedValues = { w: w, x: x }
        const source = e1.pipe(
          groupBy((val: string) => val.toLowerCase().trim())
        )
        expectObservable(source, unsub).toBe(expected, expectedValues)
      }
    )
  })
  it("should allow an inner to be unsubscribed early but other inners continue", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const values = {
        a: "  foo",
        b: " FoO ",
        c: "baR  ",
        d: "foO ",
        e: " Baz   ",
        f: "  qux ",
        g: "   bar",
        h: " BAR  ",
        i: "FOO ",
        j: "baz  ",
        k: " bAZ ",
        l: "    fOo    ",
      }
      const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
      const expected = "     --w---x---y-z-------------|"
      const w = "            --a-b---d-                 "
      const unsubw = "       ---------!                 "
      const x = "            ------c-------g-h---------|"
      const y = "            ----------e---------j-k---|"
      const z = "            ------------f-------------|"
      const expectedGroups = {
        w: TestScheduler.parseMarbles(w, values, undefined, undefined, true),
        x: TestScheduler.parseMarbles(x, values, undefined, undefined, true),
        y: TestScheduler.parseMarbles(y, values, undefined, undefined, true),
        z: TestScheduler.parseMarbles(z, values, undefined, undefined, true),
      }
      const fooUnsubscriptionFrame = TestScheduler.parseMarblesAsSubscriptions(
        unsubw,
        true
      ).unsubscribedFrame
      const source = e1.pipe(
        groupBy(val => val.toLowerCase().trim()),
        map(group => {
          const arr: any[] = []
          const subscription = group
            .pipe(phonyMarbelize(testScheduler))
            .subscribe(value => {
              arr.push(value)
            })
          if (group.key === "foo") {
            testScheduler.schedule(() => {
              subscription.unsubscribe()
            }, fooUnsubscriptionFrame - testScheduler.frame)
          }
          return arr
        })
      )
      expectObservable(source).toBe(expected, expectedGroups)
    })
  })
  it("should allow inners to be unsubscribed early at different times", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const values = {
        a: "  foo",
        b: " FoO ",
        c: "baR  ",
        d: "foO ",
        e: " Baz   ",
        f: "  qux ",
        g: "   bar",
        h: " BAR  ",
        i: "FOO ",
        j: "baz  ",
        k: " bAZ ",
        l: "    fOo    ",
      }
      const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
      const expected = "     --w---x---y-z-------------|"
      const w = "            --a-b---d-                 "
      const unsubw = "       ---------!                 "
      const x = "            ------c------              "
      const unsubx = "       ------------!              "
      const y = "            ----------e------          "
      const unsuby = "       ----------------!          "
      const z = "            ------------f-------       "
      const unsubz = "       -------------------!       "
      const expectedGroups = {
        w: TestScheduler.parseMarbles(w, values, undefined, undefined, true),
        x: TestScheduler.parseMarbles(x, values, undefined, undefined, true),
        y: TestScheduler.parseMarbles(y, values, undefined, undefined, true),
        z: TestScheduler.parseMarbles(z, values, undefined, undefined, true),
      }
      const unsubscriptionFrames: Record<string, number> = {
        foo: TestScheduler.parseMarblesAsSubscriptions(unsubw, true)
          .unsubscribedFrame,
        bar: TestScheduler.parseMarblesAsSubscriptions(unsubx, true)
          .unsubscribedFrame,
        baz: TestScheduler.parseMarblesAsSubscriptions(unsuby, true)
          .unsubscribedFrame,
        qux: TestScheduler.parseMarblesAsSubscriptions(unsubz, true)
          .unsubscribedFrame,
      }
      const source = e1.pipe(
        groupBy((val: string) => val.toLowerCase().trim()),
        map((group: any) => {
          const arr: any[] = []
          const subscription = group
            .pipe(phonyMarbelize(testScheduler))
            .subscribe((value: any) => {
              arr.push(value)
            })
          testScheduler.schedule(() => {
            subscription.unsubscribe()
          }, unsubscriptionFrames[group.key] - testScheduler.frame)
          return arr
        })
      )
      expectObservable(source).toBe(expected, expectedGroups)
    })
  })
  it("should allow subscribing late to an inner Observable, outer completes", () => {
    testScheduler.run(
      ({ hot, expectObservable, expectSubscriptions, time }) => {
        const values = {
          a: "  foo",
          b: " FoO ",
          d: "foO ",
          i: "FOO ",
          l: "    fOo    ",
        }
        const e1 = hot("          --a-b---d---------i-----l-|  ", values)
        const subs = "            ^-------------------------!  "
        const subDuration = time("--------------------------|  ")
        const expected = "        ----------------------------|"
        e1.pipe(groupBy((val: string) => val.toLowerCase().trim())).subscribe(
          (group: any) => {
            testScheduler.schedule(() => {
              expectObservable(group).toBe(expected)
            }, subDuration)
          }
        )
        expectSubscriptions(e1.subscriptions).toBe(subs)
      }
    )
  })
  it("should allow subscribing late to an inner Observable, outer throws", () => {
    testScheduler.run(
      ({ hot, expectObservable, expectSubscriptions, time }) => {
        const values = {
          a: "  foo",
          b: " FoO ",
          d: "foO ",
          i: "FOO ",
          l: "    fOo    ",
        }
        const e1 = hot("           --a-b---d---------i-----l-#", values)
        const subs = "             ^-------------------------! "
        const subsDuration = time("--------------------------| ")
        const expected = "         ----------------------------#"
        e1.pipe(groupBy((val: string) => val.toLowerCase().trim())).subscribe({
          next: (group: any) => {
            testScheduler.schedule(() => {
              expectObservable(group).toBe(expected)
            }, subsDuration)
          },
          error: () => {
            //noop
          },
        })
        expectSubscriptions(e1.subscriptions).toBe(subs)
      }
    )
  })
  it("should allow subscribing late to inner, unsubscribe outer early", () => {
    testScheduler.run(
      ({ hot, expectObservable, expectSubscriptions, time }) => {
        const values = {
          a: "  foo",
          b: " FoO ",
          d: "foO ",
          i: "FOO ",
          l: "    fOo    ",
        }
        const e1 = hot("           --a-b---d---------i-----l-#", values)
        const unsub = "            ------------!              "
        const e1subs = "           ^-----------!              "
        const subsDuration = time("------------|              ")
        const expectedOuter = "    --w----------              "
        const expectedInner = "    -------------              "
        const outerValues = { w: "foo" }
        const source = e1.pipe(
          groupBy((val: string) => val.toLowerCase().trim()),
          tap((group: any) => {
            testScheduler.schedule(() => {
              expectObservable(group).toBe(expectedInner)
            }, subsDuration)
          }),
          map((group: any) => {
            return group.key
          })
        )
        expectObservable(source, unsub).toBe(expectedOuter, outerValues)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should allow using a keySelector, elementSelector, and durationSelector", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: "  foo",
          b: " FoO ",
          c: "baR  ",
          d: "foO ",
          e: " Baz   ",
          f: "  qux ",
          g: "   bar",
          h: " BAR  ",
          i: "FOO ",
          j: "baz  ",
          k: " bAZ ",
          l: "    fOo    ",
        }
        const reversedValues = mapObject(values, reverseString)
        const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
        const e1subs = "       ^-------------------------!"
        const expected = "     --v---w---x-y-----z-------|"
        const v = cold("       a-b---(d|)                 ", reversedValues)
        const w = cold("             c-------g-(h|)       ", reversedValues)
        const x = cold("                  e---------j-(k|)", reversedValues)
        const y = cold("                   f-------------|", reversedValues)
        const z = cold("                         i-----l-|", reversedValues)
        const expectedValues = { v: v, w: w, x: x, y: y, z: z }
        const source = e1.pipe(
          groupBy(
            (val: string) => val.toLowerCase().trim(),
            (val: string) => reverseString(val),
            (group: any) => group.pipe(skip(2))
          )
        )
        expectObservable(source).toBe(expected, expectedValues)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should allow using a keySelector, elementSelector, and durationSelector that throws", () => {
    testScheduler.run(({ cold, hot, expectObservable }) => {
      const values = {
        a: "  foo",
        b: " FoO ",
        c: "baR  ",
        d: "foO ",
        e: " Baz   ",
        f: "  qux ",
        g: "   bar",
        h: " BAR  ",
        i: "FOO ",
        j: "baz  ",
        k: " bAZ ",
        l: "    fOo    ",
      }
      const reversedValues = mapObject(values, reverseString)
      const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
      const expected = "     --v---w---x-y-----z-------|"
      const v = cold("         a-b---(d#)               ", reversedValues)
      const w = cold("             c-------g-(h#)       ", reversedValues)
      const x = cold("                 e---------j-(k#) ", reversedValues)
      const y = cold("                   f-------------|", reversedValues)
      const z = cold("                         i-----l-|", reversedValues)
      const expectedValues = { v: v, w: w, x: x, y: y, z: z }
      const source = e1.pipe(
        groupBy(
          (val: string) => val.toLowerCase().trim(),
          (val: string) => reverseString(val),
          (group: any) =>
            group.pipe(
              skip(2),
              map(() => {
                throw "error"
              })
            )
        )
      )
      expectObservable(source).toBe(expected, expectedValues)
    })
  })
  it("should allow using a keySelector and a durationSelector, outer throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: "  foo",
          b: " FoO ",
          c: "baR  ",
          d: "foO ",
          e: " Baz   ",
          f: "  qux ",
          g: "   bar",
          h: " BAR  ",
          i: "FOO ",
          j: "baz  ",
          k: " bAZ ",
          l: "    fOo    ",
        }
        const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-#", values)
        const e1subs = "       ^-------------------------!"
        const expected = "     --v---w---x-y-----z-------#"
        const v = cold("         a-b---(d|)               ", values)
        const w = cold("             c-------g-(h|)       ", values)
        const x = cold("                 e---------j-(k|) ", values)
        const y = cold("                   f-------------#", values)
        const z = cold("                         i-----l-#", values)
        const expectedValues = { v: v, w: w, x: x, y: y, z: z }
        const source = e1.pipe(
          groupBy(val => val.toLowerCase().trim(), {
            duration: group => group.pipe(skip(2)),
          })
        )
        expectObservable(source).toBe(expected, expectedValues)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should allow using a durationSelector, and outer unsubscribed early", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: "  foo",
          b: " FoO ",
          c: "baR  ",
          d: "foO ",
          e: " Baz   ",
          f: "  qux ",
          g: "   bar",
          h: " BAR  ",
          i: "FOO ",
          j: "baz  ",
          k: " bAZ ",
          l: "    fOo    ",
        }
        const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
        const unsub = "        -----------!               "
        const expected = "     --v---w---x-               "
        const v = cold("         a-b---(d|)               ", values)
        const w = cold("             c-------g-(h|)       ", values)
        const x = cold("                 e---------j-(k|) ", values)
        const expectedValues = { v: v, w: w, x: x }
        const source = e1.pipe(
          groupBy(val => val.toLowerCase().trim(), {
            duration: group => group.pipe(skip(2)),
          })
        )
        expectObservable(source, unsub).toBe(expected, expectedValues)
      }
    )
  })
  it("should allow using a durationSelector, outer and all inners unsubscribed early", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const values = {
        a: "  foo",
        b: " FoO ",
        c: "baR  ",
        d: "foO ",
        e: " Baz   ",
        f: "  qux ",
        g: "   bar",
        h: " BAR  ",
        i: "FOO ",
        j: "baz  ",
        k: " bAZ ",
        l: "    fOo    ",
      }
      const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
      const unsub = "        -----------!"
      const expected = "     --v---w---x-"
      const v = "            --a-b---(d|)"
      const w = "            ------c-----"
      const x = "            ----------e-"
      const expectedGroups = {
        v: TestScheduler.parseMarbles(v, values, undefined, undefined, true),
        w: TestScheduler.parseMarbles(w, values, undefined, undefined, true),
        x: TestScheduler.parseMarbles(x, values, undefined, undefined, true),
      }
      const unsubscriptionFrame = TestScheduler.parseMarblesAsSubscriptions(
        unsub,
        true
      ).unsubscribedFrame
      const source = e1.pipe(
        groupBy(val => val.toLowerCase().trim(), {
          duration: group => group.pipe(skip(2)),
        }),
        map(group => {
          const arr: any[] = []
          const subscription = group
            .pipe(phonyMarbelize(testScheduler))
            .subscribe(value => {
              arr.push(value)
            })
          testScheduler.schedule(() => {
            subscription.unsubscribe()
          }, unsubscriptionFrame - testScheduler.frame)
          return arr
        })
      )
      expectObservable(source, unsub).toBe(expected, expectedGroups)
    })
  })
  it("should dispose a durationSelector after closing the group", () => {
    testScheduler.run(({ cold, hot, expectSubscriptions }) => {
      const obs = hot(" -0-1--------2-| ")
      const sub = "     ^--------------!"
      // prettier-ignore
      const unsubs = [
        '              -^--!',
        '              ---^--!',
        '              ------------^-!',
      ];
      const dur = "     ---s"
      const durations = [cold(dur), cold(dur), cold(dur)]
      const unsubscribedFrame = TestScheduler.parseMarblesAsSubscriptions(
        sub,
        true
      ).unsubscribedFrame
      obs
        .pipe(
          groupBy(val => val, {
            duration: group => durations[Number(group.key)],
          })
        )
        .subscribe()
      testScheduler.schedule(() => {
        durations.forEach((d, i) => {
          expectSubscriptions(d.subscriptions).toBe(unsubs[i])
        })
      }, unsubscribedFrame)
    })
  })
  it("should allow using a durationSelector, but keySelector throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: "  foo",
          b: " FoO ",
          c: "baR  ",
          d: "foO ",
          e: " Baz   ",
          f: "  qux ",
          g: "   bar",
          h: " BAR  ",
          i: "FOO ",
          j: "baz  ",
          k: " bAZ ",
          l: "    fOo    ",
        }
        const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
        const e1subs = "       ^-------------------!      "
        const expected = "     --v---w---x-y-----z-#      "
        const v = cold("         a-b---(d|)               ", values)
        const w = cold("             c-------g-(h|)       ", values)
        const x = cold("                 e---------#      ", values)
        const y = cold("                   f-------#      ", values)
        const z = cold("                         i-#      ", values)
        const expectedValues = { v: v, w: w, x: x, y: y, z: z }
        let invoked = 0
        const source = e1.pipe(
          groupBy(
            (val: any) => {
              invoked++
              if (invoked === 10) {
                throw "error"
              }
              return val.toLowerCase().trim()
            },
            (val: string) => val,
            (group: any) => group.pipe(skip(2))
          )
        )
        expectObservable(source).toBe(expected, expectedValues)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should allow using a durationSelector, but elementSelector throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: "  foo",
          b: " FoO ",
          c: "baR  ",
          d: "foO ",
          e: " Baz   ",
          f: "  qux ",
          g: "   bar",
          h: " BAR  ",
          i: "FOO ",
          j: "baz  ",
          k: " bAZ ",
          l: "    fOo    ",
        }
        const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
        const e1subs = "       ^-------------------!      "
        const expected = "     --v---w---x-y-----z-#      "
        const v = cold("         a-b---(d|)               ", values)
        const w = cold("             c-------g-(h|)       ", values)
        const x = cold("                 e---------#      ", values)
        const y = cold("                   f-------#      ", values)
        const z = cold("                         i-#      ", values)
        const expectedValues = { v: v, w: w, x: x, y: y, z: z }
        let invoked = 0
        const source = e1.pipe(
          groupBy(
            (val: string) => val.toLowerCase().trim(),
            (val: string) => {
              invoked++
              if (invoked === 10) {
                throw "error"
              }
              return val
            },
            (group: any) => group.pipe(skip(2))
          )
        )
        expectObservable(source).toBe(expected, expectedValues)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should allow using a durationSelector which eventually throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: "  foo",
          b: " FoO ",
          c: "baR  ",
          d: "foO ",
          e: " Baz   ",
          f: "  qux ",
          g: "   bar",
          h: " BAR  ",
          i: "FOO ",
          j: "baz  ",
          k: " bAZ ",
          l: "    fOo    ",
        }
        const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
        const e1subs = "       ^-----------!              "
        const expected = "  --v---w---x-(y#)              "
        const v = cold("         a-b---(d|)               ", values)
        const w = cold("             c-----#              ", values)
        const x = cold("                 e-#              ", values)
        const y = cold("                   #              ", values)
        const expectedValues = { v: v, w: w, x: x, y: y }
        let invoked = 0
        const source = e1.pipe(
          groupBy(
            (val: string) => val.toLowerCase().trim(),
            (val: string) => val,
            (group: any) => {
              invoked++
              if (invoked === 4) {
                throw "error"
              }
              return group.pipe(skip(2))
            }
          )
        )
        expectObservable(source).toBe(expected, expectedValues)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should allow an inner to be unsubscribed early but other inners continue, with durationSelector", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = {
          a: "  foo",
          b: " FoO ",
          c: "baR  ",
          d: "foO ",
          e: " Baz   ",
          f: "  qux ",
          g: "   bar",
          h: " BAR  ",
          i: "FOO ",
          j: "baz  ",
          k: " bAZ ",
          l: "    fOo    ",
        }
        const reversedValues = mapObject(values, reverseString)
        const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
        const e1subs = "       ^-------------------------!"
        const expected = "     --v---w---x-y-----z-------|"
        const v = "            --a-b---                   "
        const unsubv = "       -------!                   "
        const w = "            ------c-------g-(h|)       "
        const x = "             ----------e---------j-(k|)"
        const y = "            ------------f-------------|"
        const z = "            ------------------i-----l-|"
        const expectedGroups = {
          v: TestScheduler.parseMarbles(
            v,
            reversedValues,
            undefined,
            undefined,
            true
          ),
          w: TestScheduler.parseMarbles(
            w,
            reversedValues,
            undefined,
            undefined,
            true
          ),
          x: TestScheduler.parseMarbles(
            x,
            reversedValues,
            undefined,
            undefined,
            true
          ),
          y: TestScheduler.parseMarbles(
            y,
            reversedValues,
            undefined,
            undefined,
            true
          ),
          z: TestScheduler.parseMarbles(
            z,
            reversedValues,
            undefined,
            undefined,
            true
          ),
        }
        const fooUnsubscriptionFrame =
          TestScheduler.parseMarblesAsSubscriptions(
            unsubv,
            true
          ).unsubscribedFrame
        const source = e1.pipe(
          groupBy(
            (val: string) => val.toLowerCase().trim(),
            (val: string) => reverseString(val),
            (group: any) => group.pipe(skip(2))
          ),
          map((group: any, index: number) => {
            const arr: any[] = []
            const subscription = group
              .pipe(phonyMarbelize(testScheduler))
              .subscribe((value: any) => {
                arr.push(value)
              })
            if (group.key === "foo" && index === 0) {
              testScheduler.schedule(() => {
                subscription.unsubscribe()
              }, fooUnsubscriptionFrame - testScheduler.frame)
            }
            return arr
          })
        )
        expectObservable(source).toBe(expected, expectedGroups)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should allow inners to be unsubscribed early at different times, with durationSelector", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: "  foo",
        b: " FoO ",
        c: "baR  ",
        d: "foO ",
        e: " Baz   ",
        f: "  qux ",
        g: "   bar",
        h: " BAR  ",
        i: "FOO ",
        j: "baz  ",
        k: " bAZ ",
        l: "    fOo    ",
      }
      const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|", values)
      const e1subs = "       ^-------------------------!"
      const expected = "     --v---w---x-y-----z-------|"
      const v = "            --a-b---                   "
      const unsubv = "       -------!                   "
      const w = "            ------c---                 "
      const unsubw = "       ---------!                 "
      const x = "            ----------e---------j-     "
      const unsubx = "       ---------------------!     "
      const y = "            ------------f----          "
      const unsuby = "       ----------------!          "
      const z = "            ------------------i----    "
      const unsubz = "       ----------------------!    "
      const expectedGroups = {
        v: TestScheduler.parseMarbles(v, values, undefined, undefined, true),
        w: TestScheduler.parseMarbles(w, values, undefined, undefined, true),
        x: TestScheduler.parseMarbles(x, values, undefined, undefined, true),
        y: TestScheduler.parseMarbles(y, values, undefined, undefined, true),
        z: TestScheduler.parseMarbles(z, values, undefined, undefined, true),
      }
      const unsubscriptionFrames: Record<string, number> = {
        foo: TestScheduler.parseMarblesAsSubscriptions(unsubv, true)
          .unsubscribedFrame,
        bar: TestScheduler.parseMarblesAsSubscriptions(unsubw, true)
          .unsubscribedFrame,
        baz: TestScheduler.parseMarblesAsSubscriptions(unsubx, true)
          .unsubscribedFrame,
        qux: TestScheduler.parseMarblesAsSubscriptions(unsuby, true)
          .unsubscribedFrame,
        foo2: TestScheduler.parseMarblesAsSubscriptions(unsubz, true)
          .unsubscribedFrame,
      }
      const hasUnsubscribed: Record<string, boolean> = {}
      const source = e1.pipe(
        groupBy(
          (val: string) => val.toLowerCase().trim(),
          (val: string) => val,
          (group: any) => group.pipe(skip(2))
        ),
        map((group: any) => {
          const arr: any[] = []
          const subscription = group
            .pipe(phonyMarbelize(testScheduler))
            .subscribe((value: any) => {
              arr.push(value)
            })
          const unsubscriptionFrame = hasUnsubscribed[group.key]
            ? unsubscriptionFrames[group.key + "2"]
            : unsubscriptionFrames[group.key]
          testScheduler.schedule(() => {
            subscription.unsubscribe()
            hasUnsubscribed[group.key] = true
          }, unsubscriptionFrame - testScheduler.frame)
          return arr
        })
      )
      expectObservable(source).toBe(expected, expectedGroups)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return inners that when subscribed late exhibit hot behavior", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: "  foo",
        b: " FoO ",
        c: "baR  ",
        d: "foO ",
        e: " Baz   ",
        f: "  qux ",
        g: "   bar",
        h: " BAR  ",
        i: "FOO ",
        j: "baz  ",
        k: " bAZ ",
        l: "    fOo    ",
      }
      const e1 = hot("-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|    ", values)
      const e1subs = "       ^-------------------------!    "
      const expected = "     --v---w---x-y-------------|    "
      const subv = "         ---^                           " // foo
      const v = "            ----b---d---------i-----l-|    " // foo
      const subw = "         ---------^                     " // bar
      const w = "            --------------g-h---------|    " // bar
      const subx = "         -------------------^           " // baz
      const x = "            --------------------j-k---|    " // baz
      const suby = "         ------------------------------^" // qux
      const y = "            ------------------------------|" // qux
      const expectedGroups = {
        v: TestScheduler.parseMarbles(v, values, undefined, undefined, true),
        w: TestScheduler.parseMarbles(w, values, undefined, undefined, true),
        x: TestScheduler.parseMarbles(x, values, undefined, undefined, true),
        y: TestScheduler.parseMarbles(y, values, undefined, undefined, true),
      }
      const subscriptionFrames: Record<string, number> = {
        foo: TestScheduler.parseMarblesAsSubscriptions(subv, true)
          .subscribedFrame,
        bar: TestScheduler.parseMarblesAsSubscriptions(subw, true)
          .subscribedFrame,
        baz: TestScheduler.parseMarblesAsSubscriptions(subx, true)
          .subscribedFrame,
        qux: TestScheduler.parseMarblesAsSubscriptions(suby, true)
          .subscribedFrame,
      }
      const result = e1.pipe(
        groupBy(
          (val: string) => val.toLowerCase().trim(),
          (val: string) => val
        ),
        map((group: any) => {
          const innerNotifications: any[] = []
          const subscriptionFrame = subscriptionFrames[group.key]
          testScheduler.schedule(() => {
            group
              .pipe(phonyMarbelize(testScheduler))
              .subscribe((value: any) => {
                innerNotifications.push(value)
              })
          }, subscriptionFrame - testScheduler.frame)
          return innerNotifications
        })
      )
      expectObservable(result).toBe(expected, expectedGroups)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return inner group that when subscribed late emits complete()", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: "  foo",
        b: " FoO ",
        d: "foO ",
        i: "FOO ",
        l: "    fOo    ",
      }
      const e1 = hot("-1--2--^-a-b---d---------i-----l-|      ", values)
      const e1subs = "       ^-------------------------!      "
      const expected = "     --g-----------------------|      "
      const innerSub = "     --------------------------------^"
      const g = "            --------------------------------|"
      const expectedGroups = {
        g: TestScheduler.parseMarbles(g, values, undefined, undefined, true),
      }
      const innerSubscriptionFrame = TestScheduler.parseMarblesAsSubscriptions(
        innerSub,
        true
      ).subscribedFrame
      const source = e1.pipe(
        groupBy(
          (val: string) => val.toLowerCase().trim(),
          (val: string) => val,
          (group: any) => group.pipe(skip(7))
        ),
        map((group: any) => {
          const arr: any[] = []
          testScheduler.schedule(() => {
            group
              .pipe(phonyMarbelize(testScheduler))
              .subscribe((value: any) => {
                arr.push(value)
              })
          }, innerSubscriptionFrame - testScheduler.frame)
          return arr
        })
      )
      expectObservable(source).toBe(expected, expectedGroups)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it.skip("should return inner group that when subscribed late emits error()", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = {
        a: "  foo",
        b: " FoO ",
        d: "foO ",
        i: "FOO ",
        l: "    fOo    ",
      }
      const e1 = hot("-1--2--^-a-b---d---------i-----l-#      ", values)
      const e1subs = "       ^-------------------------!      "
      const expected = "     --g-----------------------#      "
      const innerSub = "     --------------------------------^"
      const g = "            --------------------------------#"
      const expectedGroups = {
        g: TestScheduler.parseMarbles(g, values, undefined, undefined, true),
      }
      const innerSubscriptionFrame = TestScheduler.parseMarblesAsSubscriptions(
        innerSub,
        true
      ).subscribedFrame
      const source = e1.pipe(
        groupBy(
          (val: string) => val.toLowerCase().trim(),
          (val: string) => val,
          (group: any) => group.pipe(skip(7))
        ),
        map((group: any) => {
          const arr: any[] = []
          testScheduler.schedule(() => {
            group
              .pipe(phonyMarbelize(testScheduler))
              .subscribe((value: any) => {
                arr.push(value)
              })
          }, innerSubscriptionFrame - testScheduler.frame)
          return arr
        })
      )
      expectObservable(source).toBe(expected, expectedGroups)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not error for late subscribed inners if outer is unsubscribed before inners are subscribed", () => {
    testScheduler.run(({ hot, expectObservable }) => {
      const source = hot("-----^----a----b-----a------b----a----b---#")
      // Unsubscribe before the error happens.
      const unsub = "          -------------------!                  "
      // Used to hold two subjects we're going to use to subscribe to our groups
      const subjects: Record<string, Subject<string>> = {
        a: new Subject(),
        b: new Subject(),
      }
      const result = source.pipe(
        groupBy(char => char),
        tap({
          // The real test is here, schedule each group to be subscribed to
          // long after the source errors and long after the unsubscription happens.
          next: group => {
            testScheduler.schedule(
              () => group.subscribe(subjects[group.key]),
              1000
            )
          },
        }),
        // We don't are about what the outer is emitting
        ignoreElements()
      )
      // Just to get the test going.
      expectObservable(result, unsub).toBe("-")
      // Our two groups should error immediately upon subscription.
      expectObservable(subjects.a).toBe("-")
      expectObservable(subjects.b).toBe("-")
    })
  })
  it("should not break lift() composability", done => {
    class MyCustomObservable<T> extends Observable<T> {
      lift<R>(operator: Operator<T, R>): Observable<R> {
        const observable = new MyCustomObservable<R>()
        ;(<any>observable).source = this
        ;(<any>observable).operator = operator
        return observable
      }
    }
    const result = new MyCustomObservable((observer: Observer<number>) => {
      observer.next(1)
      observer.next(2)
      observer.next(3)
      observer.complete()
    }).pipe(
      groupBy(
        (x: number) => x % 2,
        (x: number) => x + "!"
      )
    )
    expect(result instanceof MyCustomObservable).to.be.true
    const expectedGroups = [
      { key: 1, values: ["1!", "3!"] },
      { key: 0, values: ["2!"] },
    ]
    result.subscribe({
      next: (g: any) => {
        const expectedGroup = expectedGroups.shift()!
        expect(g.key).to.equal(expectedGroup.key)
        g.subscribe((x: any) => {
          expect(x).to.deep.equal(expectedGroup.values.shift())
        })
      },
      error: x => {
        done(new Error("should not be called"))
      },
      complete: () => {
        done()
      },
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        groupBy(value => value),
        take(3)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
/**
 * TODO: A helper operator to deal with legacy tests above that could probably be written a different way
 */
function phonyMarbelize<T>(testScheduler: TestScheduler) {
  return (source: Observable<T>) =>
    source.pipe(
      materialize(),
      map(notification => {
        // Because we're hacking some weird inner-observable marbles here, we need
        // to make sure this is all the same shape as it would be from the TestScheduler
        // assertions
        return {
          frame: testScheduler.frame,
          notification: createNotification(
            notification.kind,
            notification.value,
            notification.error
          ),
        }
      })
    )
}
import { ignoreElements, mergeMap } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {ignoreElements} */
describe("ignoreElements", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should ignore all the elements of the source", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--|")
      const e1subs = "  ^-------------!"
      const expected = "--------------|"
      expectObservable(e1.pipe(ignoreElements())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--|")
      const e1subs = "  ^------!       "
      const expected = "--------       "
      const unsub = "   -------!       "
      const result = e1.pipe(ignoreElements())
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing early and explicitly with higher order", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--|")
      const e1subs = "  ^------!       "
      const expected = "--------       "
      const unsub = "   -------!       "
      const result = e1.pipe(
        mergeMap(x => of(x)),
        ignoreElements(),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should propagate errors from the source", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--#")
      const e1subs = "  ^----!"
      const expected = "-----#"
      expectObservable(e1.pipe(ignoreElements())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      expectObservable(e1.pipe(ignoreElements())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(ignoreElements())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle throw", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("  #  ")
      const e1subs = "  (^!)"
      const expected = "#   "
      expectObservable(e1.pipe(ignoreElements())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
})
import * as index from "rxjs/operators"
import { expect } from "chai"
describe("operators/index", () => {
  it("should export operators", () => {
    expect(index.audit).to.exist
    expect(index.auditTime).to.exist
    expect(index.buffer).to.exist
    expect(index.bufferCount).to.exist
    expect(index.bufferTime).to.exist
    expect(index.bufferToggle).to.exist
    expect(index.bufferWhen).to.exist
    expect(index.catchError).to.exist
    expect(index.combineAll).to.exist
    expect(index.combineLatestAll).to.exist
    expect(index.concatAll).to.exist
    expect(index.concatMap).to.exist
    expect(index.concatMapTo).to.exist
    expect(index.count).to.exist
    expect(index.debounce).to.exist
    expect(index.debounceTime).to.exist
    expect(index.defaultIfEmpty).to.exist
    expect(index.delay).to.exist
    expect(index.delayWhen).to.exist
    expect(index.dematerialize).to.exist
    expect(index.distinct).to.exist
    expect(index.distinctUntilChanged).to.exist
    expect(index.distinctUntilKeyChanged).to.exist
    expect(index.elementAt).to.exist
    expect(index.every).to.exist
    expect(index.exhaust).to.exist
    expect(index.exhaustAll).to.exist
    expect(index.exhaustMap).to.exist
    expect(index.expand).to.exist
    expect(index.filter).to.exist
    expect(index.finalize).to.exist
    expect(index.find).to.exist
    expect(index.findIndex).to.exist
    expect(index.first).to.exist
    expect(index.groupBy).to.exist
    expect(index.ignoreElements).to.exist
    expect(index.isEmpty).to.exist
    expect(index.last).to.exist
    expect(index.map).to.exist
    expect(index.mapTo).to.exist
    expect(index.materialize).to.exist
    expect(index.max).to.exist
    expect(index.mergeAll).to.exist
    expect(index.mergeMap).to.exist
    expect(index.flatMap).to.exist
    expect(index.mergeMap).to.exist
    expect(index.mergeMapTo).to.exist
    expect(index.mergeScan).to.exist
    expect(index.min).to.exist
    expect(index.multicast).to.exist
    expect(index.observeOn).to.exist
    expect(index.pairwise).to.exist
    expect(index.partition).to.exist
    expect(index.pluck).to.exist
    expect(index.publish).to.exist
    expect(index.publishBehavior).to.exist
    expect(index.publishLast).to.exist
    expect(index.publishReplay).to.exist
    expect(index.reduce).to.exist
    expect(index.repeat).to.exist
    expect(index.repeatWhen).to.exist
    expect(index.retry).to.exist
    expect(index.retryWhen).to.exist
    expect(index.refCount).to.exist
    expect(index.sample).to.exist
    expect(index.sampleTime).to.exist
    expect(index.scan).to.exist
    expect(index.sequenceEqual).to.exist
    expect(index.share).to.exist
    expect(index.shareReplay).to.exist
    expect(index.single).to.exist
    expect(index.skip).to.exist
    expect(index.skipLast).to.exist
    expect(index.skipUntil).to.exist
    expect(index.skipWhile).to.exist
    expect(index.startWith).to.exist
    expect(index.switchAll).to.exist
    expect(index.switchScan).to.exist
    expect(index.switchMap).to.exist
    expect(index.switchMapTo).to.exist
    expect(index.take).to.exist
    expect(index.takeLast).to.exist
    expect(index.takeUntil).to.exist
    expect(index.takeWhile).to.exist
    expect(index.tap).to.exist
    expect(index.throttle).to.exist
    expect(index.throttleTime).to.exist
    expect(index.timeInterval).to.exist
    expect(index.timeout).to.exist
    expect(index.timeoutWith).to.exist
    expect(index.timestamp).to.exist
    expect(index.toArray).to.exist
    expect(index.window).to.exist
    expect(index.windowCount).to.exist
    expect(index.windowTime).to.exist
    expect(index.windowToggle).to.exist
    expect(index.windowWhen).to.exist
    expect(index.withLatestFrom).to.exist
    expect(index.zipAll).to.exist
  })
})
import { isEmpty, mergeMap } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {isEmpty} */
describe("isEmpty", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should return true if source is empty", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -----|   ")
      const e1subs = "  ^----!   "
      const expected = "-----(T|)"
      expectObservable(e1.pipe(isEmpty())).toBe(expected, { T: true })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return false if source emits element", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--|")
      const e1subs = "     ^--!   "
      const expected = "   ---(F|)"
      expectObservable(e1.pipe(isEmpty())).toBe(expected, { F: false })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if source raises error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --#")
      const e1subs = "  ^-!"
      const expected = "--#"
      expectObservable(e1.pipe(isEmpty())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not complete if source never emits", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(isEmpty())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return true if source is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "(T|)"
      expectObservable(e1.pipe(isEmpty())).toBe(expected, { T: true })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -----------a--b--|")
      const e1subs = "  ^-----!           "
      const expected = "-------           "
      const unsub = "   ------!           "
      expectObservable(e1.pipe(isEmpty()), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -----------a--b--|")
      const e1subs = "  ^-----!           "
      const expected = "-------           "
      const unsub = "   ------!           "
      const result = e1.pipe(
        mergeMap(x => of(x)),
        isEmpty(),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
})
import { TestScheduler } from "rxjs/testing"
import { last, mergeMap } from "rxjs/operators"
import { EmptyError, of, from, Observable } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {last} */
describe("last", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should take the last value of an observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a----b--c--|   ")
      const e1subs = "  ^------------!   "
      const expected = "-------------(c|)"
      expectObservable(e1.pipe(last())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should error on nothing sent but completed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^----|")
      const e1subs = "     ^----!"
      const expected = "   -----#"
      expectObservable(e1.pipe(last())).toBe(expected, null, new EmptyError())
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should error on empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      expectObservable(e1.pipe(last())).toBe(expected, null, new EmptyError())
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should go on forever on never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(last())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow undefined as a default value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -----a--a---a-|   ")
      const e1subs = "  ^-------------!   "
      const expected = "--------------(U|)"
      expectObservable(e1.pipe(last(value => value === "b", undefined))).toBe(
        expected,
        { U: undefined }
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return last element matches with predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--a--b--|   ")
      const e1subs = "  ^-------------!   "
      const expected = "--------------(b|)"
      expectObservable(e1.pipe(last(value => value === "b"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--|")
      const e1subs = "  ^------!       "
      const expected = "--------       "
      const unsub = "   -------!       "
      expectObservable(e1.pipe(last()), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--|")
      const e1subs = "  ^------!       "
      const expected = "--------       "
      const unsub = "   -------!       "
      const result = e1.pipe(
        mergeMap(x => of(x)),
        last(),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return a default value if no element found", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "(a|)"
      expectObservable(e1.pipe(last(null, "a"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not return default value if an element is found", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a---^---b---c---d---|   ")
      const e1subs = "      ^---------------!   "
      const expected = "    ----------------(d|)"
      expectObservable(e1.pipe(last(null, "x"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error when predicate throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^---b---c---d---e--|")
      const e1subs = "     ^-------!           "
      const expected = "   --------#           "
      const predicate = function (x: string) {
        if (x === "c") {
          throw "error"
        } else {
          return false
        }
      }
      expectObservable(e1.pipe(last(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should support type guards without breaking previous behavior", () => {
    // tslint:disable no-unused-variable
    // type guards with interfaces and classes
    {
      interface Bar {
        bar?: string
      }
      interface Baz {
        baz?: number
      }
      class Foo implements Bar, Baz {
        constructor(public bar: string = "name", public baz: number = 42) {}
      }
      const isBar = (x: any): x is Bar => x && (x as Bar).bar !== undefined
      const isBaz = (x: any): x is Baz => x && (x as Baz).baz !== undefined
      const foo: Foo = new Foo()
      of(foo)
        .pipe(last())
        .subscribe(x => x.baz) // x is Foo
      of(foo)
        .pipe(last(foo => foo.bar === "name"))
        .subscribe(x => x.baz) // x is still Foo
      of(foo)
        .pipe(last(isBar))
        .subscribe(x => x.bar) // x is Bar!
      const foobar: Bar = new Foo() // type is the interface, not the class
      of(foobar)
        .pipe(last())
        .subscribe(x => x.bar) // x is Bar
      of(foobar)
        .pipe(last(foobar => foobar.bar === "name"))
        .subscribe(x => x.bar) // x is still Bar
      of(foobar)
        .pipe(last(isBaz))
        .subscribe(x => x.baz) // x is Baz!
      const barish = { bar: "quack", baz: 42 } // type can quack like a Bar
      of(barish)
        .pipe(last())
        .subscribe(x => x.baz) // x is still { bar: string; baz: number; }
      of(barish)
        .pipe(last(x => x.bar === "quack"))
        .subscribe(x => x.bar) // x is still { bar: string; baz: number; }
      of(barish)
        .pipe(last(isBar))
        .subscribe(x => x.bar) // x is Bar!
    }
    // type guards with primitive types
    {
      const xs: Observable<string | number> = from([1, "aaa", 3, "bb"])
      // This type guard will narrow a `string | number` to a string in the examples below
      const isString = (x: string | number): x is string =>
        typeof x === "string"
      // missing predicate preserves the type
      xs.pipe(last()).subscribe(x => x) // x is still string | number
      // null predicate preserves the type
      xs.pipe(last(null)).subscribe(x => x) // x is still string | number
      // undefined predicate preserves the type
      xs.pipe(last(undefined)).subscribe(x => x) // x is still string | number
      // After the type guard `last` predicates, the type is narrowed to string
      xs.pipe(last(isString)).subscribe(s => s.length) // s is string
      // boolean predicates preserve the type
      xs.pipe(last(x => typeof x === "string")).subscribe(x => x) // x is still string | number
    }
    // tslint:disable enable
  })
})
import { expect } from "chai"
import { map, tap, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of, Observable, identity } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
// function shortcuts
const addDrama = (x: number | string) => x + "!"
/** @test {map} */
describe("map", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should map multiple values", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --1--2--3--|")
      const e1subs = "  ^----------!"
      const expected = "--x--y--z--|"
      const result = e1.pipe(map(x => 10 * +x))
      expectObservable(result).toBe(expected, { x: 10, y: 20, z: 30 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should map one value", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const values = { x: 42 }
      const e1 = cold(" --x--|", values)
      const e1subs = "  ^----!"
      const expected = "--y--|"
      const result = e1.pipe(map(addDrama))
      expectObservable(result).toBe(expected, { y: "42!" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should map multiple values", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --1--2--3--|")
      const e1subs = "  ^----------!"
      const expected = "--x--y--z--|"
      const result = e1.pipe(map(addDrama))
      expectObservable(result).toBe(expected, { x: "1!", y: "2!", z: "3!" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should propagate errors from map function", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const values = { x: 42 }
      const e1 = cold(" --x--|", values)
      const e1subs = "  ^-!   "
      const expected = "--#   "
      const result = e1.pipe(
        map((x: any) => {
          throw "too bad"
        })
      )
      expectObservable(result).toBe(expected, null, "too bad")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should propagate errors from observable that emits only errors", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      const result = e1.pipe(map(identity))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should propagate errors from observable that emit values", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const values = { a: 1, b: 2 }
      const e1 = cold(" --a--b--#", values, "too bad")
      const e1subs = "  ^-------!"
      const expected = "--x--y--#"
      const result = e1.pipe(map(addDrama))
      expectObservable(result).toBe(expected, { x: "1!", y: "2!" }, "too bad")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not map an empty observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      let invoked = 0
      const result = e1.pipe(
        map((x: any) => {
          invoked++
          return x
        }),
        tap({
          complete() {
            expect(invoked).to.equal(0)
          },
        })
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --1--2--3--|")
      const e1subs = "  ^-----!     "
      const expected = "--x--y-     "
      const unsub = "   ------!     "
      const result = e1.pipe(map(addDrama))
      expectObservable(result, unsub).toBe(expected, { x: "1!", y: "2!" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should map with index", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-5-^-4--3---2----1--|")
      const e1subs = "   ^----------------!"
      const expected = " --a--b---c----d--|"
      const values = { a: 5, b: 14, c: 23, d: 32 }
      let invoked = 0
      const result = e1.pipe(
        map((x: string, index: number) => {
          invoked++
          return parseInt(x) + 1 + index * 10
        }),
        tap({
          complete() {
            expect(invoked).to.equal(4)
          },
        })
      )
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should map with index until completed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-5-^-4--3---2----1--|")
      const e1subs = "   ^----------------!"
      const expected = " --a--b---c----d--|"
      const values = { a: 5, b: 14, c: 23, d: 32 }
      let invoked = 0
      const result = e1.pipe(
        map((x: string, index: number) => {
          invoked++
          return parseInt(x) + 1 + index * 10
        }),
        tap({
          complete() {
            expect(invoked).to.equal(4)
          },
        })
      )
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should map with index until an error occurs", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-5-^-4--3---2----1--#", undefined, "too bad")
      const e1subs = "   ^----------------!"
      const expected = " --a--b---c----d--#"
      const values = { a: 5, b: 14, c: 23, d: 32 }
      let invoked = 0
      const result = e1.pipe(
        map((x: string, index: number) => {
          invoked++
          return parseInt(x) + 1 + index * 10
        }),
        tap({
          error() {
            expect(invoked).to.equal(4)
          },
        })
      )
      expectObservable(result).toBe(expected, values, "too bad")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should map using a custom thisArg", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-5-^-4--3---2----1--|")
      const e1subs = "   ^----------------!"
      const expected = " --a--b---c----d--|"
      const values = { a: 46, b: 55, c: 64, d: 73 }
      const foo = {
        value: 42,
      }
      const result = e1.pipe(
        map(function (this: typeof foo, x: string, index: number) {
          expect(this).to.equal(foo)
          return parseInt(x) + foo.value + index * 10
        }, foo)
      )
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should map twice", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-0----1-^-2---3--4-5--6--7-8-|")
      const e1subs = "        ^--------------------!"
      const expected = "      --a---b--c-d--e--f-g-|"
      const values = { a: 2, b: 3, c: 4, d: 5, e: 6, f: 7, g: 8 }
      let invoked1 = 0
      let invoked2 = 0
      const result = e1.pipe(
        map((x: string) => {
          invoked1++
          return parseInt(x) * 2
        }),
        map((x: number) => {
          invoked2++
          return x / 2
        }),
        tap({
          complete() {
            expect(invoked1).to.equal(7)
            expect(invoked2).to.equal(7)
          },
        })
      )
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should do multiple maps using a custom thisArg", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --1--2--3--4--|")
      const e1subs = "  ^-------------!"
      const expected = "--a--b--c--d--|"
      const values = { a: 11, b: 14, c: 17, d: 20 }
      class Filterer {
        selector1 = (x: string) => parseInt(x) + 2
        selector2 = (x: string) => parseInt(x) * 3
      }
      const filterer = new Filterer()
      const result = e1.pipe(
        map(function (this: any, x) {
          return this.selector1(x)
        }, filterer),
        map(function (this: any, x) {
          return this.selector2(x)
        }, filterer),
        map(function (this: any, x) {
          return this.selector1(x)
        }, filterer)
      )
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chain when unsubscribed explicitly", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --1--2--3--|")
      const e1subs = "  ^-----!     "
      const expected = "--x--y-     "
      const unsub = "   ------!     "
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        map(addDrama),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected, { x: "1!", y: "2!" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(map(identity), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { mapTo, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of, Observable } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {mapTo} */
describe("mapTo", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should map multiple values", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --1--2--3--|")
      const e1subs = "  ^----------!"
      const expected = "--a--a--a--|"
      expectObservable(e1.pipe(mapTo("a"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should map one value", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --7--|")
      const e1subs = "  ^----!"
      const expected = "--y--|"
      expectObservable(e1.pipe(mapTo("y"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --1--2--3--|")
      const e1subs = "  ^-----!     "
      const expected = "--x--x-     "
      const unsub = "   ------!     "
      expectObservable(e1.pipe(mapTo("x")), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should propagate errors from observable that emits only errors", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --#", undefined, "too bad")
      const e1subs = "  ^-!"
      const expected = "--#"
      expectObservable(e1.pipe(mapTo(1))).toBe(expected, null, "too bad")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should propagate errors from observable that emit values, then errors", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --1--2--#", undefined, "too bad")
      const e1subs = "  ^-------!"
      const expected = "--x--x--#"
      expectObservable(e1.pipe(mapTo("x"))).toBe(expected, undefined, "too bad")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not map an empty observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      expectObservable(e1.pipe(mapTo(-1))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should map twice", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-0----1-^-2---3--4-5--6--7-8-|")
      const e1subs = "        ^--------------------!"
      const expected = "      --h---h--h-h--h--h-h-|"
      // prettier-ignore
      const result = e1.pipe(
        mapTo(-1),
        mapTo('h')
      );
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chain when unsubscribed explicitly", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --1--2--3--|")
      const e1subs = "  ^-----!     "
      const expected = "--x--x-     "
      const unsub = "   ------!     "
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        mapTo("x"),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(mapTo(0), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { materialize, map, mergeMap, take } from "rxjs/operators"
import { Notification, of, Observable } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {materialize} */
describe("materialize", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should materialize an Observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --x--y--z--|   ")
      const e1subs = "  ^----------!   "
      const expected = "--a--b--c--(d|)"
      const values = { a: "{x}", b: "{y}", c: "{z}", d: "|" }
      const result = e1.pipe(
        materialize(),
        map((x: Notification<string>) => {
          if (x.kind === "C") {
            return "|"
          } else {
            return "{" + x.value + "}"
          }
        })
      )
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should materialize a happy stream", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|   ")
      const e1subs = "  ^----------!   "
      const expected = "--w--x--y--(z|)"
      const expectedValue = {
        w: Notification.createNext("a"),
        x: Notification.createNext("b"),
        y: Notification.createNext("c"),
        z: Notification.createComplete(),
      }
      expectObservable(e1.pipe(materialize())).toBe(expected, expectedValue)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should materialize a sad stream", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--#   ")
      const e1subs = "  ^----------!   "
      const expected = "--w--x--y--(z|)"
      const expectedValue = {
        w: Notification.createNext("a"),
        x: Notification.createNext("b"),
        y: Notification.createNext("c"),
        z: Notification.createError("error"),
      }
      expectObservable(e1.pipe(materialize())).toBe(expected, expectedValue)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^-----!     "
      const expected = "--w--x-     "
      const unsub = "   ------!     "
      const expectedValue = {
        w: Notification.createNext("a"),
        x: Notification.createNext("b"),
      }
      expectObservable(e1.pipe(materialize()), unsub).toBe(
        expected,
        expectedValue
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^-----!     "
      const expected = "--w--x-     "
      const unsub = "   ------!     "
      const expectedValue = {
        w: Notification.createNext("a"),
        x: Notification.createNext("b"),
      }
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        materialize(),
        mergeMap((x: Notification<string>) => of(x))
      )
      expectObservable(result, unsub).toBe(expected, expectedValue)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should materialize stream that does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(materialize())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should materialize stream that does not emit", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----|   ")
      const e1subs = "  ^---!   "
      const expected = "----(x|)"
      expectObservable(e1.pipe(materialize())).toBe(expected, {
        x: Notification.createComplete(),
      })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should materialize empty stream", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "(x|)"
      expectObservable(e1.pipe(materialize())).toBe(expected, {
        x: Notification.createComplete(),
      })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should materialize stream that throws", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "(x|)"
      expectObservable(e1.pipe(materialize())).toBe(expected, {
        x: Notification.createError("error"),
      })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(materialize(), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { max, mergeMap, skip, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of, range } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {max} */
describe("max", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should find the max of values of an observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|   ", { a: 42, b: -1, c: 3 })
      const e1subs = "  ^----------!   "
      const expected = "-----------(x|)"
      expectObservable(e1.pipe(max())).toBe(expected, { x: 42 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should be never when source is never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(max())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should be zero when source is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      expectObservable(e1.pipe(max())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should be never when source doesn't complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--x--^--y--")
      const e1subs = "     ^-----"
      const expected = "   ------"
      expectObservable(e1.pipe(max())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should complete when source doesn't have values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^---|")
      const e1subs = "   ^---!"
      const expected = " ----|"
      expectObservable(e1.pipe(max())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should max the unique value of an observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^--y--|   ", { y: 42 })
      const e1subs = "   ^-----!   "
      const expected = " ------(w|)"
      expectObservable(e1.pipe(max())).toBe(expected, { w: 42 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should max the values of an ongoing hot observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^-b--c--d--|   ", { a: 42, b: -1, c: 0, d: 6 })
      const e1subs = "    ^----------!   "
      const expected = "  -----------(x|)"
      expectObservable(e1.pipe(max())).toBe(expected, { x: 6 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|", { a: 42, b: -1, c: 0 })
      const e1subs = "  ^-----!     "
      const expected = "-------     "
      const unsub = "   ------!     "
      expectObservable(e1.pipe(max()), unsub).toBe(expected, { x: 42 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|", { a: 42, b: -1, c: 0 })
      const e1subs = "  ^-----!     "
      const expected = "-------     "
      const unsub = "   ------!     "
      const result = e1.pipe(
        mergeMap((x: number) => of(x)),
        max(),
        mergeMap((x: number) => of(x))
      )
      expectObservable(result, unsub).toBe(expected, { x: 42 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should max a range() source observable", done => {
    range(1, 10000)
      .pipe(max())
      .subscribe({
        next: (value: number) => {
          expect(value).to.equal(10000)
        },
        error: () => {
          done(new Error("should not be called"))
        },
        complete: () => {
          done()
        },
      })
  })
  it("should max a range().pipe(skip(1)) source observable", done => {
    range(1, 10)
      .pipe(skip(1), max())
      .subscribe({
        next: (value: number) => {
          expect(value).to.equal(10)
        },
        error: () => {
          done(new Error("should not be called"))
        },
        complete: () => {
          done()
        },
      })
  })
  it("should max a range().pipe(take(1)) source observable", done => {
    range(1, 10)
      .pipe(take(1), max())
      .subscribe({
        next: (value: number) => {
          expect(value).to.equal(1)
        },
        error: () => {
          done(new Error("should not be called"))
        },
        complete: () => {
          done()
        },
      })
  })
  it("should work with error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^--y--z--#", { x: 1, y: 2, z: 3 }, "too bad")
      const e1subs = "   ^--------!"
      const expected = " ---------#"
      expectObservable(e1.pipe(max())).toBe(expected, null, "too bad")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work with throw", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      expectObservable(e1.pipe(max())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a constant predicate on an empty hot observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^---|")
      const e1subs = "   ^---!"
      const expected = " ----|"
      const predicate = function <T>() {
        return 42
      }
      expectObservable(e1.pipe(max(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a constant predicate on an never hot observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^----")
      const e1subs = "   ^----"
      const expected = " -----"
      const predicate = function <T>() {
        return 42
      }
      expectObservable(e1.pipe(max(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a constant predicate on a simple hot observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^-a-|   ", { a: 1 })
      const e1subs = "   ^---!   "
      const expected = " ----(w|)"
      const predicate = function () {
        return 42
      }
      expectObservable(e1.pipe(max(predicate))).toBe(expected, { w: 1 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a reverse predicate on observable with many values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-a-^-b--c--d-|   ", { a: 42, b: -1, c: 0, d: 666 })
      const e1subs = "   ^---------!   "
      const expected = " ----------(w|)"
      const predicate = function <T>(x: T, y: T) {
        return x > y ? -1 : 1
      }
      expectObservable(e1.pipe(max(predicate))).toBe(expected, { w: -1 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a predicate for string on observable with many values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-a-^-b--c--d-|   ")
      const e1subs = "   ^---------!   "
      const expected = " ----------(w|)"
      const predicate = function <T>(x: T, y: T) {
        return x > y ? -1 : 1
      }
      expectObservable(e1.pipe(max(predicate))).toBe(expected, { w: "b" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a constant predicate on observable that throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1-^---#")
      const e1subs = "   ^---!"
      const expected = " ----#"
      const predicate = () => {
        return 42
      }
      expectObservable(e1.pipe(max(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a predicate that throws, on observable with many values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1-^-2--3--|")
      const e1subs = "   ^----!   "
      const expected = " -----#   "
      const predicate = function (x: string, y: string) {
        if (y === "3") {
          throw "error"
        }
        return x > y ? -1 : 1
      }
      expectObservable(e1.pipe(max(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
})
import { merge } from "rxjs/operators"
import { queueScheduler, of } from "rxjs"
import { expect } from "chai"
describe("merge (legacy)", () => {
  it("should merge an immediately-scheduled source with an immediately-scheduled second", done => {
    const a = of(1, 2, 3, queueScheduler)
    const b = of(4, 5, 6, 7, 8, queueScheduler)
    const r = [1, 2, 4, 3, 5, 6, 7, 8]
    a.pipe(merge(b, queueScheduler)).subscribe({
      next: val => {
        expect(val).to.equal(r.shift())
      },
      error: x => {
        done(new Error("should not be called"))
      },
      complete: () => {
        done()
      },
    })
  })
})
import { expect } from "chai"
import { mergeAll, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { throwError, from, of, queueScheduler, Observable } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {mergeAll} */
describe("mergeAll", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should merge a hot observable of cold observables", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    --a---b--c---d--|      ")
        const xsubs = "   --^---------------!      "
        const y = cold("           ----e---f--g---|")
        const ysubs = "   ---------^--------------!"
        const e1 = hot("  --x------y-------|       ", { x: x, y: y })
        const e1subs = "  ^----------------!       "
        const expected = "----a---b--c-e-d-f--g---|"
        expectObservable(e1.pipe(mergeAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should merge all observables in an observable", () => {
    testScheduler.run(({ expectObservable }) => {
      // prettier-ignore
      const e1 = from([
        of('a'),
        of('b'),
        of('c')
      ]);
      const expected = "(abc|)"
      expectObservable(e1.pipe(mergeAll())).toBe(expected)
    })
  })
  it("should throw if any child observable throws", () => {
    testScheduler.run(({ expectObservable }) => {
      // prettier-ignore
      const e1 = from([
        of('a'),
        throwError(() => ('error')),
        of('c')
      ]);
      const expected = "(a#)"
      expectObservable(e1.pipe(mergeAll())).toBe(expected)
    })
  })
  it("should handle merging a hot observable of observables", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    a---b---c---|   ")
        const xsubs = "   --^-----------!   "
        const y = cold("       d---e---f---|")
        const ysubs = "   -----^-----------!"
        const e1 = hot("  --x--y--|         ", { x: x, y: y })
        const e1subs = "  ^-------!         "
        const expected = "--a--db--ec--f---|"
        expectObservable(e1.pipe(mergeAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should merge one cold Observable at a time with parameter concurrency=1", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    a---b---c---|            ")
        const xsubs = "   --^-----------!            "
        const y = cold("                d---e---f---|")
        const ysubs = "   --------------^-----------!"
        const e1 = hot("  --x--y--|                  ", { x: x, y: y })
        const e1subs = "  ^-------!                  "
        const expected = "--a---b---c---d---e---f---|"
        expectObservable(e1.pipe(mergeAll(1))).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should merge two cold Observables at a time with parameter concurrency=2", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    a---b---c---|        ")
        const xsubs = "   --^-----------!        "
        const y = cold("       d---e---f---|     ")
        const ysubs = "   -----^-----------!     "
        const z = cold("                --g---h-|")
        const zsubs = "   --------------^-------!"
        const e1 = hot("  --x--y--z--|           ", { x: x, y: y, z: z })
        const e1subs = "  ^----------!           "
        const expected = "--a--db--ec--f--g---h-|"
        expectObservable(e1.pipe(mergeAll(2))).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(z.subscriptions).toBe(zsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should merge one hot Observable at a time with parameter concurrency=1", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const x = hot("   ---a---b---c---|          ")
      const xsubs = "   --^------------!          "
      const y = hot("   -------------d---e---f---|")
      const ysubs = "   ---------------^---------!"
      const e1 = hot("  --x--y--|                 ", { x: x, y: y })
      const e1subs = "  ^-------!                 "
      const expected = "---a---b---c-----e---f---|"
      expectObservable(e1.pipe(mergeAll(1))).toBe(expected)
      expectSubscriptions(x.subscriptions).toBe(xsubs)
      expectSubscriptions(y.subscriptions).toBe(ysubs)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should merge two hot Observables at a time with parameter concurrency=2", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const x = hot("   i--a---b---c---|        ")
      const xsubs = "   --^------------!        "
      const y = hot("   -i-i--d---e---f---|     ")
      const ysubs = "   -----^------------!     "
      const z = hot("   --i--i--i--i-----g---h-|")
      const zsubs = "   ---------------^-------!"
      const e1 = hot("  --x--y--z--|            ", { x: x, y: y, z: z })
      const e1subs = "  ^----------!            "
      const expected = "---a--db--ec--f--g---h-|"
      expectObservable(e1.pipe(mergeAll(2))).toBe(expected)
      expectSubscriptions(x.subscriptions).toBe(xsubs)
      expectSubscriptions(y.subscriptions).toBe(ysubs)
      expectSubscriptions(z.subscriptions).toBe(zsubs)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle merging a hot observable of observables, outer unsubscribed early", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    a---b---c---|   ")
        const xsubs = "   --^---------!     "
        const y = cold("       d---e---f---|")
        const ysubs = "   -----^------!     "
        const e1 = hot("  --x--y--|         ", { x: x, y: y })
        const e1subs = "  ^-------!         "
        const expected = "--a--db--ec--     "
        const unsub = "   ------------!     "
        expectObservable(e1.pipe(mergeAll()), unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    a---b---c---|   ")
        const xsubs = "   --^---------!     "
        const y = cold("       d---e---f---|")
        const ysubs = "   -----^------!     "
        const e1 = hot("  --x--y--|         ", { x: x, y: y })
        const e1subs = "  ^-------!         "
        const expected = "--a--db--ec--     "
        const unsub = "   ------------!     "
        const result = e1.pipe(
          mergeMap(x => of(x)),
          mergeAll(),
          mergeMap(x => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should merge parallel emissions", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    ----a----b----c---|")
        const xsubs = "   --^-----------------!"
        const y = cold("       -d----e----f---|")
        const ysubs = "   -----^--------------!"
        const e1 = hot("  --x--y--|            ", { x: x, y: y })
        const e1subs = "  ^-------!            "
        const expected = "------(ad)-(be)-(cf)|"
        expectObservable(e1.pipe(mergeAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should merge empty and empty", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    |      ")
        const xsubs = "   --(^!)   "
        const y = cold("       |   ")
        const ysubs = "   -----(^!)"
        const e1 = hot("  --x--y--|", { x: x, y: y })
        const e1subs = "  ^-------!"
        const expected = "--------|"
        expectObservable(e1.pipe(mergeAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should merge three empties", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    |         ")
        const xsubs = "   --(^!)      "
        const y = cold("       |      ")
        const ysubs = "   -----(^!)   "
        const z = cold("         |    ")
        const zsubs = "   -------(^!) "
        const e1 = hot("  --x--y-z---|", { x: x, y: y, z: z })
        const e1subs = "  ^----------!"
        const expected = "-----------|"
        expectObservable(e1.pipe(mergeAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(z.subscriptions).toBe(zsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should merge never and empty", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    -      ")
        const xsubs = "   --^      "
        const y = cold("       |   ")
        const ysubs = "   -----(^!)"
        const e1 = hot("  --x--y--|", { x: x, y: y })
        const e1subs = "  ^-------!"
        const expected = "---------"
        expectObservable(e1.pipe(mergeAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should merge never and never", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    -      ")
        const xsubs = "   --^      "
        const y = cold("       -   ")
        const ysubs = "   -----^   "
        const e1 = hot("  --x--y--|", { x: x, y: y })
        const e1subs = "  ^-------!"
        const expected = "---------"
        expectObservable(e1.pipe(mergeAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should merge empty and throw", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    |      ")
        const xsubs = "   --(^!)   "
        const y = cold("       #   ")
        const ysubs = "   -----(^!)"
        const e1 = hot("  --x--y--|", { x: x, y: y })
        const e1subs = "  ^----!   "
        const expected = "-----#   "
        expectObservable(e1.pipe(mergeAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should merge never and throw", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    -      ")
        const xsubs = "   --^--!   "
        const y = cold("       #   ")
        const ysubs = "   -----(^!)"
        const e1 = hot("  --x--y--|", { x: x, y: y })
        const e1subs = "  ^----!   "
        const expected = "-----#   "
        expectObservable(e1.pipe(mergeAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should merge empty and eventual error", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    |         ")
        const xsubs = "   --(^!)      "
        const y = cold("       ------#")
        const ysubs = "   -----^-----!"
        const e1 = hot("  --x--y--|   ", { x: x, y: y })
        const e1subs = "  ^-------!   "
        const expected = "-----------#"
        expectObservable(e1.pipe(mergeAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should merge never and eventual error", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    -         ")
        const xsubs = "   --^--------!"
        const y = cold("       ------#")
        const ysubs = "   -----^-----!"
        const e1 = hot("  --x--y--|   ", { x: x, y: y })
        const e1subs = "  ^-------!   "
        const expected = "-----------#"
        expectObservable(e1.pipe(mergeAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should take an empty source and return empty too", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      expectObservable(e1.pipe(mergeAll())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should take a never source and return never too", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(mergeAll())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should take a throw source and return throw too", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      expectObservable(e1.pipe(mergeAll())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle merging a hot observable of non-overlapped observables", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    a-b---------|                 ")
        const xsubs = "   --^-----------!                 "
        const y = cold("              c-d-e-f-|           ")
        const ysubs = "   ------------^-------!           "
        const z = cold("                       g-h-i-j-k-|")
        const zsubs = "   ---------------------^---------!"
        const e1 = hot("  --x---------y--------z--------| ", {
          x: x,
          y: y,
          z: z,
        })
        const e1subs = "  ^-----------------------------! "
        const expected = "--a-b-------c-d-e-f--g-h-i-j-k-|"
        expectObservable(e1.pipe(mergeAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(z.subscriptions).toBe(zsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should raise error if inner observable raises error", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    a-b---------|                 ")
        const xsubs = "   --^-----------!                 "
        const y = cold("              c-d-e-f-#           ")
        const ysubs = "   ------------^-------!           "
        const z = cold("                       g-h-i-j-k-|")
        const zsubs: string[] = []
        const e1 = hot("  --x---------y--------z--------| ", {
          x: x,
          y: y,
          z: z,
        })
        const e1subs = "  ^-------------------!           "
        const expected = "--a-b-------c-d-e-f-#           "
        expectObservable(e1.pipe(mergeAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(z.subscriptions).toBe(zsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should raise error if outer observable raises error", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    a-b---------|      ")
        const xsubs = "   --^-----------!      "
        const y = cold("              c-d-e-f-|")
        const ysubs = "   ------------^---!    "
        const e1 = hot("  --x---------y---#    ", { x: x, y: y })
        const e1subs = "  ^---------------!    "
        const expected = "--a-b-------c-d-#    "
        expectObservable(e1.pipe(mergeAll())).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should merge all promises in an observable", done => {
    const e1 = from([
      new Promise<string>(res => {
        res("a")
      }),
      new Promise<string>(res => {
        res("b")
      }),
      new Promise<string>(res => {
        res("c")
      }),
      new Promise<string>(res => {
        res("d")
      }),
    ])
    const expected = ["a", "b", "c", "d"]
    const res: string[] = []
    e1.pipe(mergeAll()).subscribe({
      next: x => {
        res.push(x)
      },
      error: () => {
        done(new Error("should not be called"))
      },
      complete: () => {
        expect(res).to.deep.equal(expected)
        done()
      },
    })
  })
  it("should raise error when promise rejects", done => {
    const error = "error"
    const e1 = from([
      new Promise<string>(res => {
        res("a")
      }),
      new Promise<string>((res: any, rej) => {
        rej(error)
      }),
      new Promise<string>(res => {
        res("c")
      }),
      new Promise<string>(res => {
        res("d")
      }),
    ])
    const res: string[] = []
    e1.pipe(mergeAll()).subscribe({
      next: x => {
        res.push(x)
      },
      error: err => {
        expect(res.length).to.equal(1)
        expect(err).to.equal("error")
        done()
      },
      complete: () => {
        done(new Error("should not be called"))
      },
    })
  })
  it("should finalize generators when merged if the subscription ends", () => {
    const iterable = {
      finalized: false,
      next() {
        return { value: "duck", done: false }
      },
      return() {
        this.finalized = true
      },
      [Symbol.iterator]() {
        return this
      },
    }
    const results: string[] = []
    const iterableObservable = from<string>(iterable as any)
    of(iterableObservable)
      .pipe(mergeAll(), take(3))
      .subscribe({
        next: x => results.push(x),
        complete: () => results.push("GOOSE!"),
      })
    expect(results).to.deep.equal(["duck", "duck", "duck", "GOOSE!"])
    expect(iterable.finalized).to.be.true
  })
  it("should merge two observables", done => {
    const a = of(1, 2, 3)
    const b = of(4, 5, 6, 7, 8)
    const r = [1, 2, 3, 4, 5, 6, 7, 8]
    of(a, b)
      .pipe(mergeAll())
      .subscribe({
        next: val => {
          expect(val).to.equal(r.shift())
        },
        complete: done,
      })
  })
  it("should merge two immediately-scheduled observables", done => {
    const a = of(1, 2, 3, queueScheduler)
    const b = of(4, 5, 6, 7, 8, queueScheduler)
    const r = [1, 2, 4, 3, 5, 6, 7, 8]
    of(a, b, queueScheduler)
      .pipe(mergeAll())
      .subscribe({
        next: val => {
          expect(val).to.equal(r.shift())
        },
        complete: done,
      })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    of(synchronousObservable)
      .pipe(mergeAll(), take(3))
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { mergeMap, map, delay, take } from "rxjs/operators"
import { asapScheduler, defer, Observable, from, of, timer } from "rxjs"
import { asInteropObservable } from "../helpers/interop-helper"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {mergeMap} */
describe("mergeMap", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should map-and-flatten each item to an Observable", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const values = { x: 10, y: 30, z: 50 }
        const x = cold("    x-x-x|             ", values)
        //                        y-y-y|
        //                           z-z-z|
        const xsubs = [
          "               --^----!             ",
          "               --------^----!       ",
          "               -----------^----!    ",
        ]
        const e1 = hot("  --1-----3--5--------|")
        const e1subs = "  ^-------------------!"
        const expected = "--x-x-x-y-yzyz-z----|"
        const result = e1.pipe(mergeMap(value => x.pipe(map(i => i * +value))))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should support the deprecated resultSelector", () => {
    const results: Array<number[]> = []
    of(1, 2, 3)
      .pipe(
        mergeMap(
          x => of(x, x + 1, x + 2),
          (a, b, i, ii) => [a, b, i, ii]
        )
      )
      .subscribe({
        next(value) {
          results.push(value)
        },
        error(err) {
          throw err
        },
        complete() {
          expect(results).to.deep.equal([
            [1, 1, 0, 0],
            [1, 2, 0, 1],
            [1, 3, 0, 2],
            [2, 2, 1, 0],
            [2, 3, 1, 1],
            [2, 4, 1, 2],
            [3, 3, 2, 0],
            [3, 4, 2, 1],
            [3, 5, 2, 2],
          ])
        },
      })
  })
  it("should support a void resultSelector (still deprecated)", () => {
    const results: number[] = []
    of(1, 2, 3)
      .pipe(mergeMap(x => of(x, x + 1, x + 2), void 0))
      .subscribe({
        next(value) {
          results.push(value)
        },
        error(err) {
          throw err
        },
        complete() {
          expect(results).to.deep.equal([1, 2, 3, 2, 3, 4, 3, 4, 5])
        },
      })
  })
  it("should support a void resultSelector (still deprecated) and concurrency limit", () => {
    const results: number[] = []
    of(1, 2, 3)
      .pipe(mergeMap(x => of(x, x + 1, x + 2), void 0, 1))
      .subscribe({
        next(value) {
          results.push(value)
        },
        error(err) {
          throw err
        },
        complete() {
          expect(results).to.deep.equal([1, 2, 3, 2, 3, 4, 3, 4, 5])
        },
      })
  })
  it("should mergeMap many regular interval inners", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const a = cold("  ----a---a---a---(a|)                    ")
        const asubs = "   ^---------------!                       "
        const b = cold("      ----b---b---(b|)                    ")
        const bsubs = "   ----^-----------!                       "
        const c = cold("                  ----c---c---c---c---(c|)")
        const csubs = "   ----------------^-------------------!   "
        const d = cold("                          ----(d|)        ")
        const dsubs = "   ------------------------^---!           "
        const e1 = hot("  a---b-----------c-------d-------|       ")
        const e1subs = "  ^-------------------------------!       "
        const expected = "----a---(ab)(ab)(ab)c---c---(cd)c---(c|)"
        const observableLookup: Record<string, Observable<string>> = {
          a: a,
          b: b,
          c: c,
          d: d,
        }
        const source = e1.pipe(mergeMap(value => observableLookup[value]))
        expectObservable(source).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
        expectSubscriptions(c.subscriptions).toBe(csubs)
        expectSubscriptions(d.subscriptions).toBe(dsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should map values to constant resolved promises and merge", done => {
    const source = from([4, 3, 2, 1])
    const project = () => from(Promise.resolve(42))
    const results: number[] = []
    source.pipe(mergeMap(project)).subscribe({
      next: x => {
        results.push(x)
      },
      error: err => {
        done(new Error("Subscriber error handler not supposed to be called."))
      },
      complete: () => {
        expect(results).to.deep.equal([42, 42, 42, 42])
        done()
      },
    })
  })
  it("should map values to constant rejected promises and merge", done => {
    const source = from([4, 3, 2, 1])
    const project = () => from(Promise.reject<number>(42))
    source.pipe(mergeMap(project)).subscribe({
      next: x => {
        done(new Error("Subscriber next handler not supposed to be called."))
      },
      error: err => {
        expect(err).to.equal(42)
        done()
      },
      complete: () => {
        done(
          new Error("Subscriber complete handler not supposed to be called.")
        )
      },
    })
  })
  it("should map values to resolved promises and merge", done => {
    const source = from([4, 3, 2, 1])
    const project = (value: number, index: number) =>
      from(Promise.resolve(value + index))
    const results: number[] = []
    source.pipe(mergeMap(project)).subscribe({
      next: x => {
        results.push(x)
      },
      error: err => {
        done(new Error("Subscriber error handler not supposed to be called."))
      },
      complete: () => {
        expect(results).to.deep.equal([4, 4, 4, 4])
        done()
      },
    })
  })
  it("should map values to rejected promises and merge", done => {
    const source = from([4, 3, 2, 1])
    const project = (value: number, index: number) =>
      from(Promise.reject<string>("" + value + "-" + index))
    source.pipe(mergeMap(project)).subscribe({
      next: x => {
        done(new Error("Subscriber next handler not supposed to be called."))
      },
      error: err => {
        expect(err).to.equal("4-0")
        done()
      },
      complete: () => {
        done(
          new Error("Subscriber complete handler not supposed to be called.")
        )
      },
    })
  })
  it("should mergeMap many outer values to many inner values", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("   ----i---j---k---l---|                        ")
        //                         ----i---j---k---l---|
        //                                 ----i---j---k---l---|
        //                                         ----i---j---k---l---|
        const xsubs = [
          "               -^-------------------!                        ",
          "               ---------^-------------------!                ",
          "               -----------------^-------------------!        ",
          "               -------------------------^-------------------!",
        ]
        const e1 = hot("  -a-------b-------c-------d-------|            ")
        const e1subs = "  ^--------------------------------!            "
        const expected = "-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)k---l---|"
        const result = e1.pipe(mergeMap(() => x))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMap many outer to many inner, complete late", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("   ----i---j---k---l---|                            ")
        //                         ----i---j---k---l---|
        //                                 ----i---j---k---l---|
        //                                         ----i---j---k---l---|
        const xsubs = [
          "               -^-------------------!                            ",
          "               ---------^-------------------!                    ",
          "               -----------------^-------------------!            ",
          "               -------------------------^-------------------!    ",
        ]
        const e1 = hot("  -a-------b-------c-------d-----------------------|")
        const e1subs = "  ^------------------------------------------------!"
        const expected = "-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)k---l-------|"
        const result = e1.pipe(mergeMap(() => x))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMap many outer to many inner, outer never completes", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold(
          "   ----i---j---k---l---|                                  "
        )
        //                         ----i---j---k---l---|
        //                                 ----i---j---k---l---|
        //                                         ----i---j---k---l---|
        //                                                 ----i---j---k---l---|
        //                                                                 ----i--
        const xsubs = [
          "               -^-------------------!                                  ",
          "               ---------^-------------------!                          ",
          "               -----------------^-------------------!                  ",
          "               -------------------------^-------------------!          ",
          "               ---------------------------------^-------------------!  ",
          "               -------------------------------------------------^-----!",
        ]
        const e1 = hot(
          "  -a-------b-------c-------d-------e---------------f------"
        )
        const e1subs =
          "  ^------------------------------------------------------!"
        const expected =
          "-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)(ki)(lj)k---l---i--"
        const unsub =
          "   -------------------------------------------------------!"
        const source = e1.pipe(mergeMap(() => x))
        expectObservable(source, unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold(
          "   ----i---j---k---l---|                                  "
        )
        //                         ----i---j---k---l---|
        //                                 ----i---j---k---l---|
        //                                         ----i---j---k---l---|
        //                                                 ----i---j---k---l---|
        //                                                                 ----i--
        const xsubs = [
          "               -^-------------------!                                  ",
          "               ---------^-------------------!                          ",
          "               -----------------^-------------------!                  ",
          "               -------------------------^-------------------!          ",
          "               ---------------------------------^-------------------!  ",
          "               -------------------------------------------------^-----!",
        ]
        const e1 = hot(
          "  -a-------b-------c-------d-------e---------------f------"
        )
        const e1subs =
          "  ^------------------------------------------------------!"
        const expected =
          "-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)(ki)(lj)k---l---i--"
        const unsub =
          "   -------------------------------------------------------!"
        const source = e1.pipe(
          map(x => x),
          mergeMap(() => x),
          map(x => x)
        )
        expectObservable(source, unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not break unsubscription chains with interop inners when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|           ")
        const xsubs = "   ---------^-----------!                "
        const y = cold("                     ---f---g---h---i--|")
        const ysubs = "   -------------------^-!                "
        const e1 = hot("  ---------x---------y---------|        ")
        const e1subs = "  ^--------------------!                "
        const expected = "-----------a--b--c--d-                "
        const unsub = "   ---------------------!                "
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        // This test manipulates the observable to make it look like an interop
        // observable - an observable from a foreign library. Interop subscribers
        // are treated differently: they are wrapped in a safe subscriber. This
        // test ensures that unsubscriptions are chained all the way to the
        // interop subscriber.
        const result = e1.pipe(
          mergeMap(x => of(x)),
          mergeMap(value => asInteropObservable(observableLookup[value])),
          mergeMap(x => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMap many outer to many inner, inner never completes", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("   ----i---j---k---l-------------------------")
        //                         ----i---j---k---l-----------------
        //                                 ----i---j---k---l---------
        //                                         ----i---j---k---l-
        const xsubs = [
          "               -^-----------------------------------------",
          "               ---------^---------------------------------",
          "               -----------------^-------------------------",
          "               -------------------------^-----------------",
        ]
        const e1 = hot("  -a-------b-------c-------d-------|         ")
        const e1subs = "  ^--------------------------------!         "
        const expected = "-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)k---l-"
        const result = e1.pipe(mergeMap(() => x))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMap many outer to many inner, and inner throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("   ----i---j---k---l-------#   ")
        //                         ----i---j---k---l
        //                                 ----i---j
        //                                         -
        const xsubs = [
          "               -^-----------------------!   ",
          "               ---------^---------------!   ",
          "               -----------------^-------!   ",
          "               -------------------------(^!)",
        ]
        const e1 = hot("  -a-------b-------c-------d   ")
        const e1subs = "  ^------------------------!   "
        const expected = "-----i---j---(ki)(lj)(ki)#   "
        const result = e1.pipe(mergeMap(() => x))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMap many outer to many inner, and outer throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("   ----i---j---k---l---|            ")
        //                         ----i---j---k---l---|
        //                                 ----i---j---k---l
        //                                         ----i---j
        const xsubs = [
          "               -^-------------------!            ",
          "               ---------^-------------------!    ",
          "               -----------------^---------------!",
          "               -------------------------^-------!",
        ]
        const e1 = hot("  -a-------b-------c-------d-------#")
        const e1subs = "  ^--------------------------------!"
        const expected = "-----i---j---(ki)(lj)(ki)(lj)(ki)#"
        const result = e1.pipe(mergeMap(() => x))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMap many outer to many inner, both inner and outer throw", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("   ----i---j---k---l---#            ")
        //                         ----i---j---k
        //                                 ----i
        const xsubs = [
          "               -^-------------------!            ",
          "               ---------^-----------!            ",
          "               -----------------^---!            ",
        ]
        const e1 = hot("  -a-------b-------c-------d-------#")
        const e1subs = "  ^--------------------!            "
        const expected = "-----i---j---(ki)(lj)#            "
        const result = e1.pipe(mergeMap(() => x))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMap to many cold Observable, with parameter concurrency=1", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold(
          "   ----i---j---k---l---|                                        "
        )
        //                                     ----i---j---k---l---|
        //                                                         ----i---j---k---l---|
        const xsubs = [
          "               -^-------------------!                                        ",
          "               ---------------------^-------------------!                    ",
          "               -----------------------------------------^-------------------!",
        ]
        const e1 = hot(
          "  -a-------b-------c---|                                        "
        )
        const e1subs =
          "  ^--------------------!                                        "
        const expected =
          "-----i---j---k---l-------i---j---k---l-------i---j---k---l---|"
        const project = () => x
        const result = e1.pipe(mergeMap(project, 1))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMap to many cold Observable, with parameter concurrency=2", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("   ----i---j---k---l---|                    ")
        //                         ----i---j---k---l---|
        //                                     ----i---j---k---l---|
        const xsubs = [
          "               -^-------------------!                    ",
          "               ---------^-------------------!            ",
          "               ---------------------^-------------------!",
        ]
        const e1 = hot("  -a-------b-------c---|                    ")
        const e1subs = "  ^--------------------!                    "
        const expected = "-----i---j---(ki)(lj)k---(li)j---k---l---|"
        const project = () => x
        const result = e1.pipe(mergeMap(project, 2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMap to many hot Observable, with parameter concurrency=1", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot(
        "   x----i---j---k---l---|                                        "
      )
      const asubs =
        "   -^-------------------!                                        "
      const b = hot(
        "   -x-x-xxxx-x-x-xxxxx-x----i---j---k---l---|                    "
      )
      const bsubs =
        "   ---------------------^-------------------!                    "
      const c = hot(
        "   x-xxxx---x-x-x-x-x-xx--x--x-x--x--xxxx-x-----i---j---k---l---|"
      )
      const csubs =
        "   -----------------------------------------^-------------------!"
      const e1 = hot(
        "  -a-------b-------c---|                                        "
      )
      const e1subs =
        "  ^--------------------!                                        "
      const expected =
        "-----i---j---k---l-------i---j---k---l-------i---j---k---l---|"
      const inners: Record<string, Observable<string>> = { a: a, b: b, c: c }
      const project = (x: string) => inners[x]
      const result = e1.pipe(mergeMap(project, 1))
      expectObservable(result).toBe(expected)
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
      expectSubscriptions(c.subscriptions).toBe(csubs)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should mergeMap to many hot Observable, with parameter concurrency=2", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const x = hot("   x----i---j---k---l---|                    ")
      const xsubs = "   -^-------------------!                    "
      const y = hot("   -x-x-xxxx----i---j---k---l---|            ")
      const ysubs = "   ---------^-------------------!            "
      const z = hot("   x-xxxx---x-x-x-x-x-xx----i---j---k---l---|")
      const zsubs = "   ---------------------^-------------------!"
      const e1 = hot("  -a-------b-------c---|                    ")
      const e1subs = "  ^--------------------!                    "
      const expected = "-----i---j---(ki)(lj)k---(li)j---k---l---|"
      const inners: Record<string, Observable<string>> = { a: x, b: y, c: z }
      const project = (x: string) => inners[x]
      const result = e1.pipe(mergeMap(project, 2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(x.subscriptions).toBe(xsubs)
      expectSubscriptions(y.subscriptions).toBe(ysubs)
      expectSubscriptions(z.subscriptions).toBe(zsubs)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should mergeMap many complex, where all inners are finite", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const a = cold(" -#                                                  ")
        const asubs: string[] = []
        const b = cold("   -#                                                ")
        const bsubs: string[] = []
        const c = cold("        -2--3--4--5------------------6-|             ")
        const csubs = "       --^------------------------------!             "
        const d = cold("              -----------2--3|                       ")
        const dsubs = "       --------^--------------!                       "
        const e = cold("                     -1--------2--3-----4--5--------|")
        const esubs = "       ---------------^------------------------------!"
        const f = cold("                                      --|            ")
        const fsubs = "       --------------------------------^-!            "
        const g = cold("                                            ---1-2|  ")
        const gsubs = "       --------------------------------------^-----!  "
        const e1 = hot("-a-b--^-c-----d------e----------------f-----g|       ")
        const e1subs = "      ^--------------------------------------!       "
        const expected = "    ---2--3--4--5---1--2--3--2--3--6--4--5---1-2--|"
        const observableLookup: Record<string, Observable<string>> = {
          a: a,
          b: b,
          c: c,
          d: d,
          e: e,
          f: f,
          g: g,
        }
        const result = e1.pipe(mergeMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
        expectSubscriptions(c.subscriptions).toBe(csubs)
        expectSubscriptions(d.subscriptions).toBe(dsubs)
        expectSubscriptions(e.subscriptions).toBe(esubs)
        expectSubscriptions(f.subscriptions).toBe(fsubs)
        expectSubscriptions(g.subscriptions).toBe(gsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMap many complex, all inners finite except one", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const a = cold(" -#                                                  ")
        const asubs: string[] = []
        const b = cold("   -#                                                ")
        const bsubs: string[] = []
        const c = cold("        -2--3--4--5------------------6-|             ")
        const csubs = "       --^------------------------------!             "
        const d = cold("              -----------2--3-                       ")
        const dsubs = "       --------^---------------                       "
        const e = cold("                     -1--------2--3-----4--5--------|")
        const esubs = "       ---------------^------------------------------!"
        const f = cold("                                      --|            ")
        const fsubs = "       --------------------------------^-!            "
        const g = cold("                                            ---1-2|  ")
        const gsubs = "       --------------------------------------^-----!  "
        const e1 = hot("-a-b--^-c-----d------e----------------f-----g|       ")
        const e1subs = "      ^--------------------------------------!       "
        const expected = "    ---2--3--4--5---1--2--3--2--3--6--4--5---1-2---"
        const observableLookup: Record<string, Observable<string>> = {
          a: a,
          b: b,
          c: c,
          d: d,
          e: e,
          f: f,
          g: g,
        }
        const result = e1.pipe(mergeMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
        expectSubscriptions(c.subscriptions).toBe(csubs)
        expectSubscriptions(d.subscriptions).toBe(dsubs)
        expectSubscriptions(e.subscriptions).toBe(esubs)
        expectSubscriptions(f.subscriptions).toBe(fsubs)
        expectSubscriptions(g.subscriptions).toBe(gsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMap many complex, inners finite, outer does not complete", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const a = cold(" -#                                                  ")
        const asubs: string[] = []
        const b = cold("   -#                                                ")
        const bsubs: string[] = []
        const c = cold("        -2--3--4--5------------------6-|             ")
        const csubs = "       --^------------------------------!             "
        const d = cold("              -----------2--3|                       ")
        const dsubs = "       --------^--------------!                       "
        const e = cold("                     -1--------2--3-----4--5--------|")
        const esubs = "       ---------------^------------------------------!"
        const f = cold("                                      --|            ")
        const fsubs = "       --------------------------------^-!            "
        const g = cold("                                            ---1-2|  ")
        const gsubs = "       --------------------------------------^-----!  "
        const e1 = hot("-a-b--^-c-----d------e----------------f-----g--------")
        const e1subs = "      ^----------------------------------------------"
        const expected = "    ---2--3--4--5---1--2--3--2--3--6--4--5---1-2---"
        const observableLookup: Record<string, Observable<string>> = {
          a: a,
          b: b,
          c: c,
          d: d,
          e: e,
          f: f,
          g: g,
        }
        const result = e1.pipe(mergeMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
        expectSubscriptions(c.subscriptions).toBe(csubs)
        expectSubscriptions(d.subscriptions).toBe(dsubs)
        expectSubscriptions(e.subscriptions).toBe(esubs)
        expectSubscriptions(f.subscriptions).toBe(fsubs)
        expectSubscriptions(g.subscriptions).toBe(gsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMap many complex, all inners finite, and outer throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const a = cold(" -#                                                  ")
        const asubs: string[] = []
        const b = cold("   -#                                                ")
        const bsubs: string[] = []
        const c = cold("        -2--3--4--5------------------6-|             ")
        const csubs = "       --^------------------------------!             "
        const d = cold("              -----------2--3|                       ")
        const dsubs = "       --------^--------------!                       "
        const e = cold("                     -1--------2--3-----4--5--------|")
        const esubs = "       ---------------^-----------------------!       "
        const f = cold("                                      --|            ")
        const fsubs = "       --------------------------------^-!            "
        const g = cold("                                            ---1-2|  ")
        const gsubs = "       --------------------------------------^!       "
        const e1 = hot("-a-b--^-c-----d------e----------------f-----g#       ")
        const e1subs = "      ^--------------------------------------!       "
        const expected = "    ---2--3--4--5---1--2--3--2--3--6--4--5-#       "
        const observableLookup: Record<string, Observable<string>> = {
          a: a,
          b: b,
          c: c,
          d: d,
          e: e,
          f: f,
          g: g,
        }
        const result = e1.pipe(mergeMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
        expectSubscriptions(c.subscriptions).toBe(csubs)
        expectSubscriptions(d.subscriptions).toBe(dsubs)
        expectSubscriptions(e.subscriptions).toBe(esubs)
        expectSubscriptions(f.subscriptions).toBe(fsubs)
        expectSubscriptions(g.subscriptions).toBe(gsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMap many complex, all inners complete except one throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const a = cold(" -#                                                  ")
        const asubs: string[] = []
        const b = cold("   -#                                                ")
        const bsubs: string[] = []
        const c = cold("        -2--3--4--5------------------6-#             ")
        const csubs = "       --^------------------------------!             "
        const d = cold("              -----------2--3|                       ")
        const dsubs = "       --------^--------------!                       "
        const e = cold("                     -1--------2--3-----4--5--------|")
        const esubs = "       ---------------^-----------------!             "
        const f = cold("                                      --|            ")
        const fsubs = "       --------------------------------^!             "
        const g = cold("                                            ---1-2|  ")
        const gsubs: string[] = []
        const e1 = hot("-a-b--^-c-----d------e----------------f-----g|       ")
        const e1subs = "      ^--------------------------------!             "
        const expected = "    ---2--3--4--5---1--2--3--2--3--6-#             "
        const observableLookup: Record<string, Observable<string>> = {
          a: a,
          b: b,
          c: c,
          d: d,
          e: e,
          f: f,
          g: g,
        }
        const result = e1.pipe(mergeMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
        expectSubscriptions(c.subscriptions).toBe(csubs)
        expectSubscriptions(d.subscriptions).toBe(dsubs)
        expectSubscriptions(e.subscriptions).toBe(esubs)
        expectSubscriptions(f.subscriptions).toBe(fsubs)
        expectSubscriptions(g.subscriptions).toBe(gsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMap many complex, all inners finite, outer is unsubscribed", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const a = cold(" -#                                                  ")
        const asubs: string[] = []
        const b = cold("   -#                                                ")
        const bsubs: string[] = []
        const c = cold("        -2--3--4--5------------------6-|             ")
        const csubs = "       --^---------------------------!                "
        const d = cold("              -----------2--3|                       ")
        const dsubs = "       --------^--------------!                       "
        const e = cold("                     -1--------2--3-----4--5--------|")
        const esubs = "       ---------------^--------------!                "
        const f = cold("                                      --|            ")
        const fsubs: string[] = []
        const g = cold("                                            ---1-2|  ")
        const gsubs: string[] = []
        const e1 = hot("-a-b--^-c-----d------e----------------f-----g|")
        const e1subs = "      ^-----------------------------!                "
        const expected = "    ---2--3--4--5---1--2--3--2--3--                "
        const unsub = "       ------------------------------!                "
        const observableLookup: Record<string, Observable<string>> = {
          a: a,
          b: b,
          c: c,
          d: d,
          e: e,
          f: f,
          g: g,
        }
        const source = e1.pipe(mergeMap(value => observableLookup[value]))
        expectObservable(source, unsub).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
        expectSubscriptions(c.subscriptions).toBe(csubs)
        expectSubscriptions(d.subscriptions).toBe(dsubs)
        expectSubscriptions(e.subscriptions).toBe(esubs)
        expectSubscriptions(f.subscriptions).toBe(fsubs)
        expectSubscriptions(g.subscriptions).toBe(gsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMap many complex, all inners finite, project throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const a = cold(" -#                                                  ")
        const asubs: string[] = []
        const b = cold("   -#                                                ")
        const bsubs: string[] = []
        const c = cold("        -2--3--4--5------------------6-|             ")
        const csubs = "       --^------------!                               "
        const d = cold("              -----------2--3|                       ")
        const dsubs = "       --------^------!                               "
        const e = cold("                     -1--------2--3-----4--5--------|")
        const esubs: string[] = []
        const f = cold("                                      --|            ")
        const fsubs: string[] = []
        const g = cold("                                            ---1-2|  ")
        const gsubs: string[] = []
        const e1 = hot("-a-b--^-c-----d------e----------------f-----g|       ")
        const e1subs = "      ^--------------!                               "
        const expected = "    ---2--3--4--5--#                               "
        const observableLookup: Record<string, Observable<string>> = {
          a: a,
          b: b,
          c: c,
          d: d,
          e: e,
          f: f,
          g: g,
        }
        const source = e1.pipe(
          mergeMap(value => {
            if (value === "e") {
              throw "error"
            }
            return observableLookup[value]
          })
        )
        expectObservable(source).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
        expectSubscriptions(c.subscriptions).toBe(csubs)
        expectSubscriptions(d.subscriptions).toBe(dsubs)
        expectSubscriptions(e.subscriptions).toBe(esubs)
        expectSubscriptions(f.subscriptions).toBe(fsubs)
        expectSubscriptions(g.subscriptions).toBe(gsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  function arrayRepeat<T>(value: T, times: number): T[] {
    const results: T[] = []
    for (let i = 0; i < times; i++) {
      results.push(value)
    }
    return results
  }
  it("should mergeMap many outer to an array for each value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  2-----4--------3--------2-------|")
      const e1subs = "  ^-------------------------------!"
      const expected = "(22)--(4444)---(333)----(22)----|"
      const source = e1.pipe(mergeMap(value => arrayRepeat(value, +value)))
      expectObservable(source).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should mergeMap many outer to inner arrays, and outer throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  2-----4--------3--------2-------#")
      const e1subs = "  ^-------------------------------!"
      const expected = "(22)--(4444)---(333)----(22)----#"
      const source = e1.pipe(mergeMap(value => arrayRepeat(value, +value)))
      expectObservable(source).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should mergeMap many outer to inner arrays, outer gets unsubscribed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  2-----4--------3--------2-------|")
      const e1subs = "  ^------------!                   "
      const expected = "(22)--(4444)--                   "
      const unsub = "   -------------!                   "
      const source = e1.pipe(mergeMap(value => arrayRepeat(value, +value)))
      expectObservable(source, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should mergeMap many outer to inner arrays, project throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  2-----4--------3--------2-------|")
      const e1subs = "  ^--------------!                 "
      const expected = "(22)--(4444)---#                 "
      const source = e1.pipe(
        mergeMap(value => {
          if (value === "3") {
            throw "error"
          }
          return arrayRepeat(value, +value)
        })
      )
      expectObservable(source).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should map and flatten", () => {
    const source = of(1, 2, 3, 4).pipe(mergeMap(x => of(x + "!")))
    const expected = ["1!", "2!", "3!", "4!"]
    let completed = false
    source.subscribe({
      next: x => {
        expect(x).to.equal(expected.shift())
      },
      complete: () => {
        expect(expected.length).to.equal(0)
        completed = true
      },
    })
    expect(completed).to.be.true
  })
  it("should map and flatten an Array", () => {
    const source = of(1, 2, 3, 4).pipe(mergeMap((x): any => [x + "!"]))
    const expected = ["1!", "2!", "3!", "4!"]
    let completed = false
    source.subscribe({
      next: x => {
        expect(x).to.equal(expected.shift())
      },
      complete: () => {
        expect(expected.length).to.equal(0)
        completed = true
      },
    })
    expect(completed).to.be.true
  })
  it("should support nested merges", done => {
    // Added as a failing test when investigating:
    // https://github.com/ReactiveX/rxjs/issues/4071
    const results: (number | string)[] = []
    of(1)
      .pipe(
        mergeMap(() =>
          defer(() => of(2, asapScheduler)).pipe(
            mergeMap(() => defer(() => of(3, asapScheduler)))
          )
        )
      )
      .subscribe({
        next(value: any) {
          results.push(value)
        },
        complete() {
          results.push("done")
        },
      })
    setTimeout(() => {
      expect(results).to.deep.equal([3, "done"])
      done()
    }, 0)
  })
  it("should support nested merges with promises", done => {
    // Added as a failing test when investigating:
    // https://github.com/ReactiveX/rxjs/issues/4071
    const results: (number | string)[] = []
    of(1)
      .pipe(
        mergeMap(() =>
          from(Promise.resolve(2)).pipe(mergeMap(() => Promise.resolve(3)))
        )
      )
      .subscribe({
        next(value) {
          results.push(value)
        },
        complete() {
          results.push("done")
        },
      })
    setTimeout(() => {
      expect(results).to.deep.equal([3, "done"])
      done()
    }, 0)
  })
  it("should support wrapped sources", done => {
    // Added as a failing test when investigating:
    // https://github.com/ReactiveX/rxjs/issues/4095
    const results: (number | string)[] = []
    const wrapped = new Observable<number>(subscriber => {
      const subscription = timer(0, asapScheduler).subscribe(subscriber)
      return () => subscription.unsubscribe()
    })
    wrapped.pipe(mergeMap(() => timer(0, asapScheduler))).subscribe({
      next(value) {
        results.push(value)
      },
      complete() {
        results.push("done")
      },
    })
    setTimeout(() => {
      expect(results).to.deep.equal([0, "done"])
      done()
    }, 0)
  })
  // NOTE: From https://github.com/ReactiveX/rxjs/issues/5436
  it("should properly handle errors from iterables that are processed after some async", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const noXError = new Error("we do not allow x")
      const e1 = cold(" -----a------------b-----|", {
        a: ["o", "o", "o"],
        b: ["o", "x", "o"],
      })
      const e1subs = "  ^-----------------!      "
      const expected = "-----(ooo)--------(o#)   "
      const iterable = function* (data: string[]) {
        for (const d of data) {
          if (d === "x") {
            throw noXError
          }
          yield d
        }
      }
      const result = e1.pipe(
        mergeMap(x => of(x).pipe(delay(0), mergeMap(iterable)))
      )
      expectObservable(result).toBe(expected, undefined, noXError)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        mergeMap(value => of(value)),
        take(3)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { TestScheduler } from "rxjs/testing"
import { mergeMapTo, map, take } from "rxjs/operators"
import { from, of, Observable } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {mergeMapTo} */
describe("mergeMapTo", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should map-and-flatten each item to an Observable", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("    x-x-x|            ")
        //                        x-x-x|
        //                           x-x-x|
        // prettier-ignore
        const xsubs = [
        '               --^----!            ',
        '               --------^----!      ',
        '               -----------^----!   ',
      ];
        const e1 = hot("  --1-----3--5-------|")
        const e1subs = "  ^------------------!"
        const expected = "--x-x-x-x-xxxx-x---|"
        const result = e1.pipe(mergeMapTo(x))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should support the deprecated resultSelector", () => {
    const results: Array<number[]> = []
    of(1, 2, 3)
      .pipe(mergeMapTo(of(4, 5, 6), (a, b, i, ii) => [a, b, i, ii]))
      .subscribe({
        next(value) {
          results.push(value)
        },
        error(err) {
          throw err
        },
        complete() {
          expect(results).to.deep.equal([
            [1, 4, 0, 0],
            [1, 5, 0, 1],
            [1, 6, 0, 2],
            [2, 4, 1, 0],
            [2, 5, 1, 1],
            [2, 6, 1, 2],
            [3, 4, 2, 0],
            [3, 5, 2, 1],
            [3, 6, 2, 2],
          ])
        },
      })
  })
  it("should support a void resultSelector (still deprecated)", () => {
    const results: number[] = []
    of(1, 2, 3)
      .pipe(mergeMapTo(of(4, 5, 6), void 0))
      .subscribe({
        next(value) {
          results.push(value)
        },
        error(err) {
          throw err
        },
        complete() {
          expect(results).to.deep.equal([4, 5, 6, 4, 5, 6, 4, 5, 6])
        },
      })
  })
  it("should mergeMapTo many regular interval inners", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("  ----1---2---3---(4|)                        ")
        //                    ----1---2---3---(4|)
        //                                ----1---2---3---(4|)
        //                                        ----1---2---3---(4|)
        const xsubs = [
          "               ^---------------!                           ",
          "               ----^---------------!                       ",
          "               ----------------^---------------!           ",
          "               ------------------------^---------------!   ",
        ]
        const e1 = hot("  a---b-----------c-------d-------|           ")
        const e1subs = "  ^-------------------------------!           "
        const expected = "----1---(21)(32)(43)(41)2---(31)(42)3---(4|)"
        const result = e1.pipe(mergeMapTo(x))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should map values to constant resolved promises and merge", done => {
    const source = from([4, 3, 2, 1])
    const results: number[] = []
    source.pipe(mergeMapTo(from(Promise.resolve(42)))).subscribe({
      next: x => {
        results.push(x)
      },
      error: () => {
        done(new Error("Subscriber error handler not supposed to be called."))
      },
      complete: () => {
        expect(results).to.deep.equal([42, 42, 42, 42])
        done()
      },
    })
  })
  it("should map values to constant rejected promises and merge", done => {
    const source = from([4, 3, 2, 1])
    source.pipe(mergeMapTo(from(Promise.reject(42)))).subscribe({
      next: () => {
        done(new Error("Subscriber next handler not supposed to be called."))
      },
      error: err => {
        expect(err).to.equal(42)
        done()
      },
      complete: () => {
        done(
          new Error("Subscriber complete handler not supposed to be called.")
        )
      },
    })
  })
  it("should mergeMapTo many outer values to many inner values", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("   ----i---j---k---l---|                        ")
        //                         ----i---j---k---l---|
        //                                 ----i---j---k---l---|
        //                                         ----i---j---k---l---|
        const xsubs = [
          "               -^-------------------!                        ",
          "               ---------^-------------------!                ",
          "               -----------------^-------------------!        ",
          "               -------------------------^-------------------!",
        ]
        const e1 = hot("  -a-------b-------c-------d-------|            ")
        const e1subs = "  ^--------------------------------!            "
        const expected = "-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)k---l---|"
        expectObservable(e1.pipe(mergeMapTo(x))).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMapTo many outer to many inner, complete late", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("   ----i---j---k---l---|                            ")
        //                         ----i---j---k---l---|
        //                                 ----i---j---k---l---|
        //                                         ----i---j---k---l---|
        const xsubs = [
          "               -^-------------------!                            ",
          "               ---------^-------------------!                    ",
          "               -----------------^-------------------!            ",
          "               -------------------------^-------------------!    ",
        ]
        const e1 = hot("  -a-------b-------c-------d-----------------------|")
        const e1subs = "  ^------------------------------------------------!"
        const expected = "-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)k---l-------|"
        expectObservable(e1.pipe(mergeMapTo(x))).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMapTo many outer to many inner, outer never completes", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold(
          "   ----i---j---k---l---|                                  "
        )
        //                         ----i---j---k---l---|
        //                                 ----i---j---k---l---|
        //                                         ----i---j---k---l---|
        //                                                 ----i---j---k---l---|
        //                                                                 ----i--
        const xsubs = [
          "               -^-------------------!                                  ",
          "               ---------^-------------------!                          ",
          "               -----------------^-------------------!                  ",
          "               -------------------------^-------------------!          ",
          "               ---------------------------------^-------------------!  ",
          "               -------------------------------------------------^-----!",
        ]
        const e1 = hot(
          "  -a-------b-------c-------d-------e---------------f------"
        )
        const e1subs =
          "  ^------------------------------------------------------!"
        const expected =
          "-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)(ki)(lj)k---l---i-"
        const unsub =
          "   -------------------------------------------------------!"
        const result = e1.pipe(mergeMapTo(x))
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold(
          "   ----i---j---k---l---|                                  "
        )
        //                         ----i---j---k---l---|
        //                                 ----i---j---k---l---|
        //                                         ----i---j---k---l---|
        //                                                 ----i---j---k---l---|
        //                                                                 ----i--
        const xsubs = [
          "               -^-------------------!                                  ",
          "               ---------^-------------------!                          ",
          "               -----------------^-------------------!                  ",
          "               -------------------------^-------------------!          ",
          "               ---------------------------------^-------------------!  ",
          "               -------------------------------------------------^-----!",
        ]
        const e1 = hot(
          "  -a-------b-------c-------d-------e---------------f------"
        )
        const e1subs =
          "  ^------------------------------------------------------!"
        const expected =
          "-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)(ki)(lj)k---l---i-"
        const unsub =
          "   -------------------------------------------------------!"
        const result = e1.pipe(
          map(x => x),
          mergeMapTo(x),
          map(x => x)
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMapTo many outer to many inner, inner never completes", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("   ----i---j---k---l-                        ")
        //                         ----i---j---k---l-
        //                                 ----i---j---k---l-
        //                                         ----i---j---k---l-
        const xsubs = [
          "               -^-----------------------------------------",
          "               ---------^---------------------------------",
          "               -----------------^-------------------------",
          "               -------------------------^-----------------",
        ]
        const e1 = hot("  -a-------b-------c-------d-------|         ")
        const e1subs = "  ^--------------------------------!         "
        const expected = "-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)k---l-"
        expectObservable(e1.pipe(mergeMapTo(x))).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMapTo many outer to many inner, and inner throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("   ----i---j---k---l-------#        ")
        //                         ----i---j---k---l-------#
        //                                 ----i---j---k---l
        const xsubs = [
          "               -^-----------------------!        ",
          "               ---------^---------------!        ",
          "               -----------------^-------!        ",
          "               -------------------------(^!)     ",
        ]
        const e1 = hot("  -a-------b-------c-------d-------|")
        const e1subs = "  ^------------------------!        "
        const expected = "-----i---j---(ki)(lj)(ki)#        "
        expectObservable(e1.pipe(mergeMapTo(x))).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMapTo many outer to many inner, and outer throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("   ----i---j---k---l---|            ")
        //                         ----i---j---k---l---|
        //                                 ----i---j---k---l
        //                                         ----i---j
        const xsubs = [
          "               -^-------------------!            ",
          "               ---------^-------------------!    ",
          "               -----------------^---------------!",
          "               -------------------------^-------!",
        ]
        const e1 = hot("  -a-------b-------c-------d-------#")
        const e1subs = "  ^--------------------------------!"
        const expected = "-----i---j---(ki)(lj)(ki)(lj)(ki)#"
        expectObservable(e1.pipe(mergeMapTo(x))).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMapTo many outer to many inner, both inner and outer throw", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("   ----i---j---k---l---#            ")
        //                         ----i---j---k
        //                                 ----i
        const xsubs = [
          "               -^-------------------!            ",
          "               ---------^-----------!            ",
          "               -----------------^---!            ",
        ]
        const e1 = hot("  -a-------b-------c-------d-------#")
        const e1subs = "  ^--------------------!            "
        const expected = "-----i---j---(ki)(lj)#            "
        expectObservable(e1.pipe(mergeMapTo(x))).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMapTo many cold Observable, with parameter concurrency=1, without resultSelector", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold(
          "   ----i---j---k---l---|                                        "
        )
        //                                     ----i---j---k---l---|
        //                                                         ----i---j---k---l---|
        const xsubs = [
          "               -^-------------------!                                        ",
          "               ---------------------^-------------------!                    ",
          "               -----------------------------------------^-------------------!",
        ]
        const e1 = hot(
          "  -a-------b-------c---|                                        "
        )
        const e1subs =
          "  ^--------------------!                                        "
        const expected =
          "-----i---j---k---l-------i---j---k---l-------i---j---k---l---|"
        const result = e1.pipe(mergeMapTo(x, 1))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMapTo to many cold Observable, with parameter concurrency=2, without resultSelector", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("   ----i---j---k---l---|                    ")
        //                         ----i---j---k---l---|
        //                                     ----i---j---k---l---|
        const xsubs = [
          "               -^-------------------!                    ",
          "               ---------^-------------------!            ",
          "               ---------------------^-------------------!",
        ]
        const e1 = hot("  -a-------b-------c---|                    ")
        const e1subs = "  ^--------------------!                    "
        const expected = "-----i---j---(ki)(lj)k---(li)j---k---l---|"
        const result = e1.pipe(mergeMapTo(x, 2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mergeMapTo many outer to arrays", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  2-----4--------3--------2-------|")
      const e1subs = "  ^-------------------------------!"
      const expected = "(0123)(0123)---(0123)---(0123)--|"
      const result = e1.pipe(mergeMapTo(["0", "1", "2", "3"]))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should mergeMapTo many outer to inner arrays, and outer throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  2-----4--------3--------2-------#")
      const e1subs = "  ^-------------------------------!"
      const expected = "(0123)(0123)---(0123)---(0123)--#"
      const result = e1.pipe(mergeMapTo(["0", "1", "2", "3"]))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should mergeMapTo many outer to inner arrays, outer gets unsubscribed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  2-----4--------3--------2-------|")
      const e1subs = "  ^------------!                   "
      const expected = "(0123)(0123)--                   "
      const unsub = "   -------------!                   "
      const result = e1.pipe(mergeMapTo(["0", "1", "2", "3"]))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should map and flatten", () => {
    const source = of(1, 2, 3, 4).pipe(mergeMapTo(of("!")))
    const expected = ["!", "!", "!", "!"]
    let completed = false
    source.subscribe({
      next: x => {
        expect(x).to.equal(expected.shift())
      },
      complete: () => {
        expect(expected.length).to.equal(0)
        completed = true
      },
    })
    expect(completed).to.be.true
  })
  it("should map and flatten an Array", () => {
    const source = of(1, 2, 3, 4).pipe(mergeMapTo(["!"]))
    const expected = ["!", "!", "!", "!"]
    let completed = false
    source.subscribe({
      next: x => {
        expect(x).to.equal(expected.shift())
      },
      complete: () => {
        expect(expected.length).to.equal(0)
        completed = true
      },
    })
    expect(completed).to.be.true
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(mergeMapTo(of(0)), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { TestScheduler } from "rxjs/testing"
import { of, defer, EMPTY, NEVER, concat, throwError, Observable } from "rxjs"
import {
  mergeScan,
  delay,
  mergeMap,
  takeWhile,
  startWith,
  take,
} from "rxjs/operators"
import { expect } from "chai"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {mergeScan} */
describe("mergeScan", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should mergeScan things", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--e--f--g--|")
      const e1subs = "     ^--------------------!"
      const expected = "   ---u--v--w--x--y--z--|"
      const values = {
        u: ["b"],
        v: ["b", "c"],
        w: ["b", "c", "d"],
        x: ["b", "c", "d", "e"],
        y: ["b", "c", "d", "e", "f"],
        z: ["b", "c", "d", "e", "f", "g"],
      }
      const result = e1.pipe(
        mergeScan((acc, x) => of(acc.concat(x)), [] as string[])
      )
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle errors", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--#")
      const e1subs = "     ^-----------!"
      const expected = "   ---u--v--w--#"
      const values = {
        u: ["b"],
        v: ["b", "c"],
        w: ["b", "c", "d"],
      }
      const result = e1.pipe(
        mergeScan((acc, x) => of(acc.concat(x)), [] as string[])
      )
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should mergeScan values and be able to asynchronously project them", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^--b--c--d--e--f--g--|")
        const e1subs = "     ^--------------------!"
        const t = time("        --|                ") // t = 2
        //                         --|
        //                            --|
        //                               --|
        //                                  --|
        //                                     --|
        const expected = "   -----u--v--w--x--y--z|"
        const values = {
          u: ["b"],
          v: ["b", "c"],
          w: ["b", "c", "d"],
          x: ["b", "c", "d", "e"],
          y: ["b", "c", "d", "e", "f"],
          z: ["b", "c", "d", "e", "f", "g"],
        }
        const result = e1.pipe(
          mergeScan(
            (acc, x) => of(acc.concat(x)).pipe(delay(t)),
            [] as string[]
          )
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not stop ongoing async projections when source completes", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^--b--c--d--e--f--g--|     ")
        const e1subs = "     ^--------------------!     "
        const t = time("        -----|") //          acc = []; x = 'b'; acc.concat(x) = ['b']; t = 5
        //                         -----|             acc = []; x = 'c'; acc.concat(x) = ['c']
        //                            -----|          acc = ['b']; x = 'd'; acc.concat(x) = ['b', 'd']
        //                               -----|       acc = ['c']; x = 'e'; acc.concat(x) = ['c', 'e']
        //                                  -----|    acc = ['b', 'd']; x = 'f'; acc.concat(x) = ['b', 'd', 'f']
        //                                     -----| acc = ['c', 'e']; x = 'g'; acc.concat(x) = ['c', 'e', 'g']
        const expected = "   --------u--v--w--x--y--(z|)"
        const values = {
          u: ["b"],
          v: ["c"],
          w: ["b", "d"],
          x: ["c", "e"],
          y: ["b", "d", "f"],
          z: ["c", "e", "g"],
        }
        const result = e1.pipe(
          mergeScan(
            (acc, x) => of(acc.concat(x)).pipe(delay(t)),
            [] as string[]
          )
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should interrupt ongoing async projections when result is unsubscribed early", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^--b--c--d--e--f--g--|")
        const e1subs = "     ^---------------!     "
        const t = time("        -----|") // acc = []; x = 'b'; acc.concat(x) = ['b']; t = 5
        //                         -----|    acc = []; x = 'c'; acc.concat(x) = ['c']
        //                            -----| acc = ['b']; x = 'd'; acc.concat(x) = ['b', 'd']
        const expected = "   --------u--v--w--     "
        const unsub = "      ----------------!     "
        const values = {
          u: ["b"],
          v: ["c"],
          w: ["b", "d"],
        }
        const result = e1.pipe(
          mergeScan(
            (acc, x) => of(acc.concat(x)).pipe(delay(t)),
            [] as string[]
          )
        )
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("--a--^--b--c--d--e--f--g--|")
        const e1subs = "     ^---------------!     "
        const t = time("        -----|") // acc = []; x = 'b'; acc.concat(x) = ['b']; t = 5
        //                         -----|    acc = []; x = 'c'; acc.concat(x) = ['c']
        //                            -----| acc = ['b']; x = 'd'; acc.concat(x) = ['b', 'd']
        const expected = "   --------u--v--w--     "
        const unsub = "      ----------------!     "
        const values = {
          u: ["b"],
          v: ["c"],
          w: ["b", "d"],
        }
        const result = e1.pipe(
          mergeMap(x => of(x)),
          mergeScan(
            (acc, x) => of(acc.concat(x)).pipe(delay(t)),
            [] as string[]
          ),
          mergeMap(x => of(x))
        )
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = concat(
      defer(() => {
        sideEffects.push(1)
        return of(1)
      }),
      defer(() => {
        sideEffects.push(2)
        return of(2)
      }),
      defer(() => {
        sideEffects.push(3)
        return of(3)
      })
    )
    of(null)
      .pipe(
        mergeScan(() => synchronousObservable, 0),
        takeWhile(x => x != 2) // unsubscribe at the second side-effect
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([1, 2])
  })
  it("should handle errors in the projection function", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--e--f--g--|")
      const e1subs = "     ^--------!"
      const expected = "   ---u--v--#"
      const values = {
        u: ["b"],
        v: ["b", "c"],
      }
      const result = e1.pipe(
        mergeScan((acc, x) => {
          if (x === "d") {
            throw new Error("bad!")
          }
          return of(acc.concat(x))
        }, [] as string[])
      )
      expectObservable(result).toBe(expected, values, new Error("bad!"))
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should propagate errors from the projected Observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--e--f--g--|")
      const e1subs = "     ^--!"
      const expected = "   ---#"
      const result = e1.pipe(
        mergeScan(() => throwError(() => new Error("bad!")), [])
      )
      expectObservable(result).toBe(expected, undefined, new Error("bad!"))
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle an empty projected Observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--e--f--g--|")
      const e1subs = "     ^--------------------!"
      const expected = "   ---------------------|"
      const result = e1.pipe(mergeScan(() => EMPTY, []))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a never projected Observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--e--f--g--|")
      const e1subs = "     ^--------------------!"
      const expected = "   ----------------------"
      const result = e1.pipe(mergeScan(() => NEVER, []))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("handle empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      const result = e1.pipe(
        mergeScan((acc, x) => of(acc.concat(x)), [] as string[])
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("handle never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      const result = e1.pipe(
        mergeScan((acc, x) => of(acc.concat(x)), [] as string[])
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("handle throw", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      const result = e1.pipe(
        mergeScan((acc, x) => of(acc.concat(x)), [] as string[])
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should mergeScan unsubscription", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--e--f--g--|")
      const e1subs = "     ^-------------!       "
      const expected = "   ---u--v--w--x--       "
      const unsub = "      --------------!       "
      const values = {
        u: ["b"],
        v: ["b", "c"],
        w: ["b", "c", "d"],
        x: ["b", "c", "d", "e"],
      }
      const result = e1.pipe(
        mergeScan((acc, x) => of(acc.concat(x)), [] as string[])
      )
      expectObservable(result, unsub).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should mergeScan projects cold Observable with single concurrency", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const inner = [
          cold("            --d--e--f--|                      "),
          cold("                       --g--h--i--|           "),
          cold("                                  --j--k--l--|"),
        ]
        const xsubs = "   --^----------!                      "
        const ysubs = "   -------------^----------!           "
        const zsubs = "   ------------------------^----------!"
        const e1 = hot("  --0--1--2--|                        ")
        const e1subs = "  ^----------!                        "
        const expected = "--x-d--e--f--f-g--h--i--i-j--k--l--|"
        const result = e1.pipe(
          mergeScan((acc, x) => inner[+x].pipe(startWith(acc)), "x", 1)
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(inner[0].subscriptions).toBe(xsubs)
        expectSubscriptions(inner[1].subscriptions).toBe(ysubs)
        expectSubscriptions(inner[2].subscriptions).toBe(zsubs)
      }
    )
  })
  it("should not emit accumulator if inner completes without value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--e--f--g--|")
      const e1subs = "     ^--------------------!"
      const expected = "   ---------------------|"
      const result = e1.pipe(mergeScan(() => EMPTY, ["1"]))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not emit accumulator if inner completes without value after source completes", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const x = cold("        -----|   ")
        //                         -----|
        // prettier-ignore
        const xsubs = [
        '                  ---^----!   ',
        '                  ------^----!',
      ];
        const e1 = hot("--a--^--b--c--|  ")
        const e1subs = "     ^--------!  "
        const expected = "   -----------|"
        const result = e1.pipe(mergeScan(() => x, "1"))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
      }
    )
  })
  it("should mergeScan projects hot Observable with single concurrency", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const inner = [
        hot("           --d--e--f--|                 "),
        hot("           ----g----h----i----|         "),
        hot("           ------j------k-------l------|"),
      ]
      const xsubs = "   ---^-------!                 "
      const ysubs = "   -----------^-------!         "
      const zsubs = "   -------------------^--------!"
      const e1 = hot("  ---0---1---2---|             ")
      const e1subs = "  ^--------------!             "
      const expected = "---x-e--f--f--i----i-l------|"
      const result = e1.pipe(
        mergeScan((acc, x) => inner[+x].pipe(startWith(acc)), "x", 1)
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(inner[0].subscriptions).toBe(xsubs)
      expectSubscriptions(inner[1].subscriptions).toBe(ysubs)
      expectSubscriptions(inner[2].subscriptions).toBe(zsubs)
    })
  })
  it("should mergeScan projects cold Observable with dual concurrency", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const inner = [
          cold("              ---d---e---f---|               "),
          cold("                   ---g---h---i---|          "),
          cold("                             ---j---k---l---|"),
        ]
        const xsubs = "   ----^--------------!               "
        const ysubs = "   ---------^--------------!          "
        const zsubs = "   -------------------^--------------!"
        const e1 = hot("  ----0----1----2----|               ")
        const e1subs = "  ^------------------!               "
        const expected = "----x--d-d-eg--fh--hi-j---k---l---|"
        const result = e1.pipe(
          mergeScan((acc, x) => inner[+x].pipe(startWith(acc)), "x", 2)
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(inner[0].subscriptions).toBe(xsubs)
        expectSubscriptions(inner[1].subscriptions).toBe(ysubs)
        expectSubscriptions(inner[2].subscriptions).toBe(zsubs)
      }
    )
  })
  it("should mergeScan projects hot Observable with dual concurrency", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const inner = [
        hot("           --d--e--f-----|              "),
        hot("           ----g----h------i----|       "),
        hot("           ------j--------k-----l------|"),
      ]
      const xsubs = "   ---^----------!              "
      const ysubs = "   -------^-------------!       "
      const zsubs = "   --------------^-------------!"
      const e1 = hot("  ---0---1---2---|             ")
      const e1subs = "  ^--------------!             "
      const expected = "---x-e-efh----hki----l------|"
      const result = e1.pipe(
        mergeScan((acc, x) => inner[+x].pipe(startWith(acc)), "x", 2)
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(inner[0].subscriptions).toBe(xsubs)
      expectSubscriptions(inner[1].subscriptions).toBe(ysubs)
      expectSubscriptions(inner[2].subscriptions).toBe(zsubs)
    })
  })
  it("should pass current index to accumulator", () => {
    const recorded: number[] = []
    const e1 = of("a", "b", "c", "d")
    e1.pipe(
      mergeScan((acc, x, index) => {
        recorded.push(index)
        return of(index)
      }, 0)
    ).subscribe()
    expect(recorded).to.deep.equal([0, 1, 2, 3])
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        mergeScan((acc, value) => of(value), 0),
        take(3)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { mergeWith, map, mergeAll, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { queueScheduler, of, Observable } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {merge} */
describe("merge operator", () => {
  let rxTestScheduler: TestScheduler
  beforeEach(() => {
    rxTestScheduler = new TestScheduler(observableMatcher)
  })
  it("should handle merging two hot observables", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a-----b-----c----|")
      const e1subs = "  ^------------------!"
      const e2 = hot("-----d-----e-----f---|")
      const e2subs = "  ^--------------------!"
      const expected = "--a--d--b--e--c--f---|"
      const result = e1.pipe(mergeWith(e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should merge a source with a second", done => {
    const a = of(1, 2, 3)
    const b = of(4, 5, 6, 7, 8)
    const r = [1, 2, 3, 4, 5, 6, 7, 8]
    a.pipe(mergeWith(b)).subscribe({
      next: val => {
        expect(val).to.equal(r.shift())
      },
      error: () => {
        done(new Error("should not be called"))
      },
      complete: () => {
        done()
      },
    })
  })
  it("should merge cold and cold", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---a-----b-----c----|")
      const e1subs = "  ^-------------------!"
      const e2 = cold(" ------x-----y-----z----|")
      const e2subs = "  ^----------------------!"
      const expected = "---a--x--b--y--c--z----|"
      const result = e1.pipe(mergeWith(e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should merge hot and hot", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---a---^-b-----c----|")
      const e1subs = "       ^------------!"
      const e2 = hot("-----x-^----y-----z----|")
      const e2subs = "       ^---------------!"
      const expected = "     --b--y--c--z----|"
      const result = e1.pipe(mergeWith(e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should merge hot and cold", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("---a-^---b-----c----|")
        const e1subs = "     ^--------------!"
        const e2 = cold("    --x-----y-----z----|")
        const e2subs = "     ^------------------!"
        const expected = "   --x-b---y-c---z----|"
        const result = e1.pipe(mergeWith(e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should merge parallel emissions", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---a----b----c----|")
      const e1subs = "  ^-----------------!"
      const e2 = hot("  ---x----y----z----|")
      const e2subs = "  ^-----------------!"
      const expected = "---(ax)-(by)-(cz)-|"
      const result = e1.pipe(mergeWith(e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a-----b-----c----|  ")
      const e1subs = "  ^---------!           "
      const e2 = hot("  -----d-----e-----f---|")
      const e2subs = "  ^---------!           "
      const expected = "--a--d--b--           "
      const unsub = "   ----------!           "
      const result = e1.pipe(mergeWith(e2))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a-----b-----c----|  ")
      const e1subs = "  ^---------!           "
      const e2 = hot("  -----d-----e-----f---|")
      const e2subs = "  ^---------!           "
      const expected = "--a--d--b--           "
      const unsub = "   ----------!           "
      const result = e1.pipe(
        map(x => x),
        mergeWith(e2),
        map(x => x)
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should merge empty and empty", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("|   ")
      const e1subs = " (^!)"
      const e2 = cold("|   ")
      const e2subs = " (^!)"
      const result = e1.pipe(mergeWith(e2))
      expectObservable(result).toBe("|")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should merge three empties", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("|")
      const e1subs = " (^!)"
      const e2 = cold("|")
      const e2subs = " (^!)"
      const e3 = cold("|")
      const e3subs = " (^!)"
      const result = e1.pipe(mergeWith(e2, e3))
      expectObservable(result).toBe("|")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
      expectSubscriptions(e3.subscriptions).toBe(e3subs)
    })
  })
  it("should merge never and empty", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("-")
      const e1subs = " ^"
      const e2 = cold("|")
      const e2subs = " (^!)"
      const result = e1.pipe(mergeWith(e2))
      expectObservable(result).toBe("-")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should merge never and never", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("-")
      const e1subs = " ^"
      const e2 = cold("-")
      const e2subs = " ^"
      const result = e1.pipe(mergeWith(e2))
      expectObservable(result).toBe("-")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should merge empty and throw", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("|")
      const e1subs = " (^!)"
      const e2 = cold("#")
      const e2subs = " (^!)"
      const result = e1.pipe(mergeWith(e2))
      expectObservable(result).toBe("#")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should merge hot and throw", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot(" --a--b--c--|")
        const e1subs = "(^!)"
        const e2 = cold("#")
        const e2subs = "(^!)"
        const result = e1.pipe(mergeWith(e2))
        expectObservable(result).toBe("#")
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should merge never and throw", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("-")
      const e1subs = " (^!)"
      const e2 = cold("#")
      const e2subs = " (^!)"
      const result = e1.pipe(mergeWith(e2))
      expectObservable(result).toBe("#")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should merge empty and eventual error", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" |")
        const e1subs = "  (^!)    "
        const e2 = hot("  -------#")
        const e2subs = "  ^------!"
        const expected = "-------#"
        const result = e1.pipe(mergeWith(e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should merge hot and error", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^------!    "
      const e2 = hot("  -------#    ")
      const e2subs = "  ^------!    "
      const expected = "--a--b-#    "
      const result = e1.pipe(mergeWith(e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should merge never and error", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --------")
      const e1subs = "  ^------!"
      const e2 = hot("  -------#")
      const e2subs = "  ^------!"
      const expected = "-------#"
      const result = e1.pipe(mergeWith(e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
})
describe("mergeAll operator", () => {
  it("should merge two observables", done => {
    const a = of(1, 2, 3)
    const b = of(4, 5, 6, 7, 8)
    const r = [1, 2, 3, 4, 5, 6, 7, 8]
    of(a, b)
      .pipe(mergeAll())
      .subscribe({
        next: val => {
          expect(val).to.equal(r.shift())
        },
        complete: done,
      })
  })
  it("should merge two immediately-scheduled observables", done => {
    const a = of(1, 2, 3, queueScheduler)
    const b = of(4, 5, 6, 7, 8, queueScheduler)
    const r = [1, 2, 4, 3, 5, 6, 7, 8]
    of(a, b, queueScheduler)
      .pipe(mergeAll())
      .subscribe({
        next: val => {
          expect(val).to.equal(r.shift())
        },
        complete: done,
      })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(mergeWith(of(0)), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { min, skip, take, mergeMap } from "rxjs/operators"
import { range, of } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {min} */
describe("min", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should min the values of an observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b--c--|", { a: 42, b: -1, c: 3 })
      const subs = "      ^----------!"
      const expected = "  -----------(x|)"
      expectObservable((<any>source).pipe(min())).toBe(expected, { x: -1 })
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should be never when source is never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable((<any>e1).pipe(min())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should be zero when source is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |")
      const e1subs = "  (^!)"
      const expected = "|"
      expectObservable((<any>e1).pipe(min())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should be never when source doesn't complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--x--^--y--")
      const e1subs = "     ^     "
      const expected = "   ------"
      expectObservable((<any>e1).pipe(min())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should be completes when source doesn't have values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^---|")
      const e1subs = "   ^---!"
      const expected = " ----|"
      expectObservable((<any>e1).pipe(min())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should min the unique value of an observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^--y--|", { y: 42 })
      const e1subs = "   ^-----!"
      const expected = " ------(w|)"
      expectObservable((<any>e1).pipe(min())).toBe(expected, { w: 42 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should min the values of an ongoing hot observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^-b--c--d--|", { a: 42, b: -1, c: 0, d: 666 })
      const subs = "      ^----------!"
      const expected = "  -----------(x|)"
      expectObservable((<any>e1).pipe(min())).toBe(expected, { x: -1 })
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should min a range() source observable", done => {
    range(1, 10000)
      .pipe(min())
      .subscribe({
        next: value => {
          expect(value).to.equal(1)
        },
        error: () => {
          done(new Error("should not be called"))
        },
        complete: done,
      })
  })
  it("should min a range().skip(1) source observable", done => {
    range(1, 10)
      .pipe(skip(1), min())
      .subscribe({
        next: value => {
          expect(value).to.equal(2)
        },
        error: () => {
          done(new Error("should not be called"))
        },
        complete: done,
      })
  })
  it("should min a range().take(1) source observable", done => {
    range(1, 10)
      .pipe(take(1), min())
      .subscribe({
        next: value => {
          expect(value).to.equal(1)
        },
        error: () => {
          done(new Error("should not be called"))
        },
        complete: done,
      })
  })
  it("should work with error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^--y--z--#", { x: 1, y: 2, z: 3 }, "too bad")
      const e1subs = "   ^--------!"
      const expected = " ---------#"
      expectObservable((<any>e1).pipe(min())).toBe(expected, null, "too bad")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work with throw", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #")
      const e1subs = "  (^!)"
      const expected = "#"
      expectObservable((<any>e1).pipe(min())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a constant predicate on an empty hot observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^---|")
      const e1subs = "   ^---!"
      const expected = " ----|"
      const predicate = function <T>(x: T, y: T) {
        return 42
      }
      expectObservable((<any>e1).pipe(min(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a constant predicate on an never hot observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^----")
      const e1subs = "   ^----"
      const expected = " -----"
      const predicate = function <T>(x: T, y: T) {
        return 42
      }
      expectObservable((<any>e1).pipe(min(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a constant predicate on a simple hot observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^-a-|", { a: 1 })
      const e1subs = "   ^---!"
      const expected = " ----(w|)"
      const predicate = () => {
        return 42
      }
      expectObservable((<any>e1).pipe(min(predicate))).toBe(expected, { w: 1 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^-a-b-c-d-e-f-g-|")
      const unsub = "    -------!         "
      const e1subs = "   ^------!         "
      const expected = " --------         "
      const predicate = () => {
        return 42
      }
      expectObservable((<any>e1).pipe(min(predicate)), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^-a-b-c-d-e-f-g-|")
      const e1subs = "   ^------!         "
      const expected = " --------         "
      const unsub = "    -------!         "
      const predicate = function () {
        return 42
      }
      const result = (<any>e1).pipe(
        mergeMap((x: string) => of(x)),
        min(predicate),
        mergeMap((x: number) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a reverse predicate on observable with many values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-a-^-b--c--d-|", { a: 42, b: -1, c: 0, d: 666 })
      const e1subs = "   ^---------!"
      const expected = " ----------(w|)"
      const predicate = function <T>(x: T, y: T) {
        return x > y ? -1 : 1
      }
      expectObservable((<any>e1).pipe(min(predicate))).toBe(expected, {
        w: 666,
      })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a predicate for string on observable with many values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-a-^-b--c--d-|")
      const e1subs = "   ^---------!"
      const expected = " ----------(w|)"
      const predicate = function <T>(x: T, y: T) {
        return x > y ? -1 : 1
      }
      expectObservable((<any>e1).pipe(min(predicate))).toBe(expected, {
        w: "d",
      })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a constant predicate on observable that throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1-^---#")
      const e1subs = "   ^---!"
      const expected = " ----#"
      const predicate = () => {
        return 42
      }
      expectObservable((<any>e1).pipe(min(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a predicate that throws, on observable with many values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1-^-2--3--|")
      const e1subs = "   ^----!   "
      const expected = " -----#   "
      const predicate = function (x: string, y: string) {
        if (y === "3") {
          throw "error"
        }
        return x > y ? -1 : 1
      }
      expectObservable((<any>e1).pipe(min(predicate))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
})
import { expect } from "chai"
import {
  multicast,
  tap,
  mergeMapTo,
  takeLast,
  mergeMap,
  refCount,
  retry,
  repeat,
  switchMap,
  map,
  take,
} from "rxjs/operators"
import {
  Subject,
  ReplaySubject,
  of,
  ConnectableObservable,
  zip,
  concat,
  Subscription,
  Observable,
  from,
} from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {multicast} */
describe("multicast", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should mirror a simple source Observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --1-2---3-4--5-|")
      const e1subs = "  ^--------------!"
      const expected = "--1-2---3-4--5-|"
      const result = e1.pipe(
        multicast(() => new Subject<string>())
      ) as ConnectableObservable<string>
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      result.connect()
    })
  })
  it("should accept Subjects", done => {
    const expected = [1, 2, 3, 4]
    const connectable = of(1, 2, 3, 4).pipe(
      multicast(new Subject<number>())
    ) as ConnectableObservable<number>
    connectable.subscribe({
      next: x => {
        expect(x).to.equal(expected.shift())
      },
      error: () => {
        done(new Error("should not be called"))
      },
      complete: () => {
        done()
      },
    })
    connectable.connect()
  })
  it("should multicast a ConnectableObservable", done => {
    const expected = [1, 2, 3, 4]
    const source = new Subject<number>()
    const connectable = source.pipe(
      multicast(new Subject<number>())
    ) as ConnectableObservable<number>
    const replayed = connectable.pipe(
      multicast(new ReplaySubject<number>())
    ) as ConnectableObservable<number>
    connectable.connect()
    replayed.connect()
    source.next(1)
    source.next(2)
    source.next(3)
    source.next(4)
    source.complete()
    replayed
      .pipe(
        tap({
          next(x) {
            expect(x).to.equal(expected.shift())
          },
          complete() {
            expect(expected.length).to.equal(0)
          },
        })
      )
      .subscribe({ error: done, complete: done })
  })
  it("should accept Subject factory functions", done => {
    const expected = [1, 2, 3, 4]
    const connectable = of(1, 2, 3, 4).pipe(
      multicast(() => new Subject<number>())
    ) as ConnectableObservable<number>
    connectable.subscribe({
      next: x => {
        expect(x).to.equal(expected.shift())
      },
      error: () => {
        done(new Error("should not be called"))
      },
      complete: () => {
        done()
      },
    })
    connectable.connect()
  })
  it("should accept a multicast selector and connect to a hot source for each subscriber", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const subjectFactory = () => new Subject<string>()
      const selector = (x: Observable<string>) =>
        zip(x, x).pipe(map(([a, b]) => (parseInt(a) + parseInt(b)).toString()))
      const e1 = hot("         -1-2-3----4-|")
      // prettier-ignore
      const e1subs = [
        '                      ^-----------!',
        '                      ----^-------!',
        '                      --------^---!',
      ];
      const multicasted = e1.pipe(multicast(subjectFactory, selector))
      const subscriber1 = hot("a|           ").pipe(mergeMapTo(multicasted))
      const expected1 = "      -2-4-6----8-|"
      const subscriber2 = hot("----b|       ").pipe(mergeMapTo(multicasted))
      const expected2 = "      -----6----8-|"
      const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(multicasted))
      const expected3 = "      ----------8-|"
      expectObservable(subscriber1).toBe(expected1)
      expectObservable(subscriber2).toBe(expected2)
      expectObservable(subscriber3).toBe(expected3)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should accept a multicast selector and connect to a cold source for each subscriber", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const subjectFactory = () => new Subject<string>()
        const selector = (x: Observable<string>) =>
          zip(x, x).pipe(
            map(([a, b]) => (parseInt(a) + parseInt(b)).toString())
          )
        const e1 = cold("        -1-2-3----4-|        ")
        //                           -1-2-3----4-|
        //                               -1-2-3----4-|
        const e1subs = [
          "                      ^-----------!        ",
          "                      ----^-----------!    ",
          "                      --------^-----------!",
        ]
        const multicasted = e1.pipe(multicast(subjectFactory, selector))
        const subscriber1 = hot("a|                   ").pipe(
          mergeMapTo(multicasted)
        )
        const expected1 = "      -2-4-6----8-|        "
        const subscriber2 = hot("----b|               ").pipe(
          mergeMapTo(multicasted)
        )
        const expected2 = "      -----2-4-6----8-|    "
        const subscriber3 = hot("--------c|           ").pipe(
          mergeMapTo(multicasted)
        )
        const expected3 = "      ---------2-4-6----8-|"
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should accept a multicast selector and respect the subject's messaging semantics", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const subjectFactory = () => new ReplaySubject<string>(1)
        const selector = (x: Observable<string>) =>
          concat(x, x.pipe(takeLast(1)))
        const e1 = cold("        -1-2-3----4-|           ")
        //                                   (4|)
        //                           -1-2-3----4-|
        //                                       (4|)
        //                               -1-2-3----4-|
        //                                           (4|)
        const e1subs = [
          "                      ^-----------!           ",
          "                      ----^-----------!       ",
          "                      --------^-----------!   ",
        ]
        const multicasted = e1.pipe(multicast(subjectFactory, selector))
        const subscriber1 = hot("a|                      ").pipe(
          mergeMapTo(multicasted)
        )
        const expected1 = "      -1-2-3----4-(4|)        "
        const subscriber2 = hot("----b|                  ").pipe(
          mergeMapTo(multicasted)
        )
        const expected2 = "      -----1-2-3----4-(4|)    "
        const subscriber3 = hot("--------c|              ").pipe(
          mergeMapTo(multicasted)
        )
        const expected3 = "      ---------1-2-3----4-(4|)"
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should do nothing if connect is not called, despite subscriptions", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --1-2---3-4--5-|")
      const e1subs: string[] = []
      const expected = "----------------"
      const multicasted = e1.pipe(multicast(() => new Subject<string>()))
      expectObservable(multicasted).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should multicast the same values to multiple observers", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = cold("        -1-2-3----4-|")
        const e1subs = "         ^-----------!"
        const multicasted = e1.pipe(
          multicast(() => new Subject<string>())
        ) as ConnectableObservable<string>
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(multicasted))
        const expected1 = "      -1-2-3----4-|"
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(multicasted))
        const expected2 = "      -----3----4-|"
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(multicasted))
        const expected3 = "      ----------4-|"
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        multicasted.connect()
      }
    )
  })
  it("should multicast an error from the source to multiple observers", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = cold("        -1-2-3----4-#")
        const e1subs = "         ^-----------!"
        const multicasted = e1.pipe(
          multicast(() => new Subject<string>())
        ) as ConnectableObservable<string>
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(multicasted))
        const expected1 = "      -1-2-3----4-#"
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(multicasted))
        const expected2 = "      -----3----4-#"
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(multicasted))
        const expected3 = "      ----------4-#"
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        multicasted.connect()
      }
    )
  })
  it("should multicast the same values to multiple observers, but is unsubscribed explicitly and early", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = cold("        -1-2-3----4-|")
        const e1subs = "         ^--------!   "
        const multicasted = e1.pipe(
          multicast(() => new Subject<string>())
        ) as ConnectableObservable<string>
        const unsub = "          ---------u   "
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(multicasted))
        const expected1 = "      -1-2-3----   "
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(multicasted))
        const expected2 = "      -----3----   "
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(multicasted))
        const expected3 = "      ----------   "
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        // Set up unsubscription action
        let connection: Subscription
        expectObservable(
          hot(unsub).pipe(
            tap(() => {
              connection.unsubscribe()
            })
          )
        ).toBe(unsub)
        connection = multicasted.connect()
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const project = (x: string) => of(x)
        const subjectFactory = () => new Subject<string>()
        const e1 = cold("        -1-2-3----4-|")
        const e1subs = "         ^--------!   "
        const multicasted = e1.pipe(
          mergeMap(project),
          multicast(subjectFactory)
        ) as ConnectableObservable<string>
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(multicasted))
        const expected1 = "      -1-2-3----   "
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(multicasted))
        const expected2 = "      -----3----   "
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(multicasted))
        const expected3 = "      ----------   "
        const unsub = "          ---------u   "
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        // Set up unsubscription action
        let connection: Subscription
        expectObservable(
          hot(unsub).pipe(
            tap(() => {
              connection.unsubscribe()
            })
          )
        ).toBe(unsub)
        connection = multicasted.connect()
      }
    )
  })
  it("should multicast an empty source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const multicasted = e1.pipe(
        multicast(() => new Subject<string>())
      ) as ConnectableObservable<string>
      const expected = "|   "
      expectObservable(multicasted).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      multicasted.connect()
    })
  })
  it("should multicast a never source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const multicasted = e1.pipe(
        multicast(() => new Subject<string>())
      ) as ConnectableObservable<string>
      const expected = "-"
      expectObservable(multicasted).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      multicasted.connect()
    })
  })
  it("should multicast a throw source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const multicasted = e1.pipe(
        multicast(() => new Subject<string>())
      ) as ConnectableObservable<string>
      const expected = "#   "
      expectObservable(multicasted).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      multicasted.connect()
    })
  })
  describe("with refCount() and subject factory", () => {
    it("should connect when first subscriber subscribes", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const subjectFactory = () => new Subject<string>()
          const e1 = cold("           -1-2-3----4-|")
          const e1subs = "         ---^-----------!"
          const multicasted = e1.pipe(multicast(subjectFactory), refCount())
          const subscriber1 = hot("---a|           ").pipe(
            mergeMapTo(multicasted)
          )
          const expected1 = "      ----1-2-3----4-|"
          const subscriber2 = hot("-------b|       ").pipe(
            mergeMapTo(multicasted)
          )
          const expected2 = "      --------3----4-|"
          const subscriber3 = hot("-----------c|   ").pipe(
            mergeMapTo(multicasted)
          )
          const expected3 = "      -------------4-|"
          expectObservable(subscriber1).toBe(expected1)
          expectObservable(subscriber2).toBe(expected2)
          expectObservable(subscriber3).toBe(expected3)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should disconnect when last subscriber unsubscribes", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const subjectFactory = () => new Subject<string>()
          const e1 = cold("           -1-2-3----4-|")
          const e1subs = "         ---^--------!   "
          const multicasted = e1.pipe(multicast(subjectFactory), refCount())
          const subscriber1 = hot("---a|           ").pipe(
            mergeMapTo(multicasted)
          )
          const expected1 = "      ----1-2-3--     "
          const unsub1 = "         ----------!     "
          const subscriber2 = hot("-------b|       ").pipe(
            mergeMapTo(multicasted)
          )
          const expected2 = "      --------3----   "
          const unsub2 = "         ------------!   "
          expectObservable(subscriber1, unsub1).toBe(expected1)
          expectObservable(subscriber2, unsub2).toBe(expected2)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should be retryable when cold source is synchronous", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const subjectFactory = () => new Subject<string>()
          const e1 = cold("   (123#)          ")
          const multicasted = e1.pipe(multicast(subjectFactory), refCount())
          const subscribe1 = "s               "
          const expected1 = " (123123123123#) "
          const subscribe2 = "-s              "
          const expected2 = " -(123123123123#)"
          const e1subs = [
            "                 (^!)            ",
            "                 (^!)            ",
            "                 (^!)            ",
            "                 (^!)            ",
            "                 -(^!)           ",
            "                 -(^!)           ",
            "                 -(^!)           ",
            "                 -(^!)           ",
          ]
          expectObservable(
            hot(subscribe1).pipe(
              tap(() => {
                expectObservable(multicasted.pipe(retry(3))).toBe(expected1)
              })
            )
          ).toBe(subscribe1)
          expectObservable(
            hot(subscribe2).pipe(
              tap(() => {
                expectObservable(multicasted.pipe(retry(3))).toBe(expected2)
              })
            )
          ).toBe(subscribe2)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should be retryable with ReplaySubject and cold source is synchronous", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const subjectFactory = () => new ReplaySubject(1)
          const e1 = cold("   (123#)          ")
          const multicasted = e1.pipe(multicast(subjectFactory), refCount())
          const subscribe1 = "s               "
          const expected1 = " (123123123123#) "
          const subscribe2 = "-s              "
          const expected2 = " -(123123123123#)"
          const e1subs = [
            "                 (^!)            ",
            "                 (^!)            ",
            "                 (^!)            ",
            "                 (^!)            ",
            "                 -(^!)           ",
            "                 -(^!)           ",
            "                 -(^!)           ",
            "                 -(^!)           ",
          ]
          expectObservable(
            hot(subscribe1).pipe(
              tap(() => {
                expectObservable(multicasted.pipe(retry(3))).toBe(expected1)
              })
            )
          ).toBe(subscribe1)
          expectObservable(
            hot(subscribe2).pipe(
              tap(() => {
                expectObservable(multicasted.pipe(retry(3))).toBe(expected2)
              })
            )
          ).toBe(subscribe2)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should be repeatable when cold source is synchronous", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const subjectFactory = () => new Subject<string>()
          const e1 = cold("   (123|)             ")
          const multicasted = e1.pipe(multicast(subjectFactory), refCount())
          const subscribe1 = "s                  "
          const expected1 = " (123123123123123|) "
          const subscribe2 = "-s                 "
          const expected2 = " -(123123123123123|)"
          const e1subs = [
            "                 (^!)               ",
            "                 (^!)               ",
            "                 (^!)               ",
            "                 (^!)               ",
            "                 (^!)               ",
            "                 -(^!)              ",
            "                 -(^!)              ",
            "                 -(^!)              ",
            "                 -(^!)              ",
            "                 -(^!)              ",
          ]
          expectObservable(
            hot(subscribe1).pipe(
              tap(() => {
                expectObservable(multicasted.pipe(repeat(5))).toBe(expected1)
              })
            )
          ).toBe(subscribe1)
          expectObservable(
            hot(subscribe2).pipe(
              tap(() => {
                expectObservable(multicasted.pipe(repeat(5))).toBe(expected2)
              })
            )
          ).toBe(subscribe2)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should be repeatable with ReplaySubject and cold source is synchronous", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const subjectFactory = () => new ReplaySubject(1)
          const e1 = cold("   (123|)             ")
          const multicasted = e1.pipe(multicast(subjectFactory), refCount())
          const subscribe1 = "s                  "
          const expected1 = " (123123123123123|) "
          const subscribe2 = "-s                 "
          const expected2 = " -(123123123123123|)"
          const e1subs = [
            "                 (^!)               ",
            "                 (^!)               ",
            "                 (^!)               ",
            "                 (^!)               ",
            "                 (^!)               ",
            "                 -(^!)              ",
            "                 -(^!)              ",
            "                 -(^!)              ",
            "                 -(^!)              ",
            "                 -(^!)              ",
          ]
          expectObservable(
            hot(subscribe1).pipe(
              tap(() => {
                expectObservable(multicasted.pipe(repeat(5))).toBe(expected1)
              })
            )
          ).toBe(subscribe1)
          expectObservable(
            hot(subscribe2).pipe(
              tap(() => {
                expectObservable(multicasted.pipe(repeat(5))).toBe(expected2)
              })
            )
          ).toBe(subscribe2)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should be retryable", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const subjectFactory = () => new Subject<string>()
          const e1 = cold("   -1-2-3----4-#                        ")
          //                              -1-2-3----4-#
          //                                          -1-2-3----4-#
          const e1subs = [
            "                 ^-----------!                        ",
            "                 ------------^-----------!            ",
            "                 ------------------------^-----------!",
          ]
          const multicasted = e1.pipe(multicast(subjectFactory), refCount())
          const subscribe1 = "s------------------------------------"
          const expected1 = " -1-2-3----4--1-2-3----4--1-2-3----4-#"
          const subscribe2 = "----s--------------------------------"
          const expected2 = " -----3----4--1-2-3----4--1-2-3----4-#"
          expectObservable(
            hot(subscribe1).pipe(
              tap(() => {
                expectObservable(multicasted.pipe(retry(2))).toBe(expected1)
              })
            )
          ).toBe(subscribe1)
          expectObservable(
            hot(subscribe2).pipe(
              tap(() => {
                expectObservable(multicasted.pipe(retry(2))).toBe(expected2)
              })
            )
          ).toBe(subscribe2)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should be retryable using a ReplaySubject", () => {
      testScheduler.run(
        ({ cold, time, expectObservable, expectSubscriptions }) => {
          const subjectFactory = () => new ReplaySubject(1)
          const e1 = cold("        -1-2-3----4-#                        ")
          const e1subs = [
            "                      ^-----------!                        ",
            "                      ------------^-----------!            ",
            "                      ------------------------^-----------!",
          ]
          const multicasted = e1.pipe(multicast(subjectFactory), refCount())
          const expected1 = "      -1-2-3----4--1-2-3----4--1-2-3----4-#"
          const subscribe2 = time("----|                                ")
          const expected2 = "      ----23----4--1-2-3----4--1-2-3----4-#"
          expectObservable(multicasted.pipe(retry(2))).toBe(expected1)
          testScheduler.schedule(
            () => expectObservable(multicasted.pipe(retry(2))).toBe(expected2),
            subscribe2
          )
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should be repeatable", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const subjectFactory = () => new Subject()
          const e1 = cold("   -1-2-3----4-|                        ")
          const e1subs = [
            "                 ^-----------!                        ",
            "                 ------------^-----------!            ",
            "                 ------------------------^-----------!",
          ]
          const multicasted = e1.pipe(multicast(subjectFactory), refCount())
          const subscribe1 = "s------------------------------------"
          const expected1 = " -1-2-3----4--1-2-3----4--1-2-3----4-|"
          const subscribe2 = "----s--------------------------------"
          const expected2 = " -----3----4--1-2-3----4--1-2-3----4-|"
          expectObservable(
            hot(subscribe1).pipe(
              tap(() => {
                expectObservable(multicasted.pipe(repeat(3))).toBe(expected1)
              })
            )
          ).toBe(subscribe1)
          expectObservable(
            hot(subscribe2).pipe(
              tap(() => {
                expectObservable(multicasted.pipe(repeat(3))).toBe(expected2)
              })
            )
          ).toBe(subscribe2)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should be repeatable using a ReplaySubject", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const subjectFactory = () => new ReplaySubject(1)
          const e1 = cold("   -1-2-3----4-|                        ")
          const e1subs = [
            "                 ^-----------!                        ",
            "                 ------------^-----------!            ",
            "                 ------------------------^-----------!",
          ]
          const multicasted = e1.pipe(multicast(subjectFactory), refCount())
          const subscribe1 = "s------------------------------------"
          const expected1 = " -1-2-3----4--1-2-3----4--1-2-3----4-|"
          const subscribe2 = "----s--------------------------------"
          const expected2 = " ----23----4--1-2-3----4--1-2-3----4-|"
          expectObservable(
            hot(subscribe1).pipe(
              tap(() => {
                expectObservable(multicasted.pipe(repeat(3))).toBe(expected1)
              })
            )
          ).toBe(subscribe1)
          expectObservable(
            hot(subscribe2).pipe(
              tap(() => {
                expectObservable(multicasted.pipe(repeat(3))).toBe(expected2)
              })
            )
          ).toBe(subscribe2)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
  })
  it("should multicast one observable to multiple observers", done => {
    const results1: number[] = []
    const results2: number[] = []
    let subscriptions = 0
    const source = new Observable<number>(observer => {
      subscriptions++
      observer.next(1)
      observer.next(2)
      observer.next(3)
      observer.next(4)
      observer.complete()
    })
    const connectable = source.pipe(
      multicast(() => {
        return new Subject<number>()
      })
    ) as ConnectableObservable<number>
    connectable.subscribe(x => {
      results1.push(x)
    })
    connectable.subscribe(x => {
      results2.push(x)
    })
    expect(results1).to.deep.equal([])
    expect(results2).to.deep.equal([])
    connectable.connect()
    expect(results1).to.deep.equal([1, 2, 3, 4])
    expect(results2).to.deep.equal([1, 2, 3, 4])
    expect(subscriptions).to.equal(1)
    done()
  })
  it("should remove all subscribers from the subject when disconnected", () => {
    const subject = new Subject<number>()
    const expected = [1, 2, 3, 4]
    let i = 0
    const source = from([1, 2, 3, 4]).pipe(
      multicast(subject)
    ) as ConnectableObservable<number>
    source.subscribe(x => {
      expect(x).to.equal(expected[i++])
    })
    source.connect()
    expect(subject.observers.length).to.equal(0)
  })
  describe("when given a subject factory", () => {
    it("should allow you to reconnect by subscribing again", done => {
      const expected = [1, 2, 3, 4]
      let i = 0
      const source = of(1, 2, 3, 4).pipe(
        multicast(() => new Subject<number>())
      ) as ConnectableObservable<number>
      source.subscribe({
        next: x => {
          expect(x).to.equal(expected[i++])
        },
        complete: () => {
          i = 0
          source.subscribe({
            next: x => {
              expect(x).to.equal(expected[i++])
            },
            complete: done,
          })
          source.connect()
        },
      })
      source.connect()
    })
    it("should not throw ObjectUnsubscribedError when used in a switchMap", done => {
      const source = of(1, 2, 3).pipe(
        multicast(() => new Subject<number>()),
        refCount()
      )
      const expected = ["a1", "a2", "a3", "b1", "b2", "b3", "c1", "c2", "c3"]
      of("a", "b", "c")
        .pipe(switchMap(letter => source.pipe(map(n => String(letter + n)))))
        .subscribe({
          next: x => {
            expect(x).to.equal(expected.shift())
          },
          error: () => {
            done(new Error("should not be called"))
          },
          complete: () => {
            expect(expected.length).to.equal(0)
            done()
          },
        })
    })
  })
  describe("when given a subject", () => {
    it("should not throw ObjectUnsubscribedError when used in a switchMap", done => {
      const source = of(1, 2, 3).pipe(
        multicast(new Subject<number>()),
        refCount()
      )
      const expected = ["a1", "a2", "a3"]
      of("a", "b", "c")
        .pipe(switchMap(letter => source.pipe(map(n => String(letter + n)))))
        .subscribe({
          next: x => {
            expect(x).to.equal(expected.shift())
          },
          error: () => {
            done(new Error("should not be called"))
          },
          complete: () => {
            expect(expected.length).to.equal(0)
            done()
          },
        })
    })
  })
})
import { observeOn, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { expect } from "chai"
import { of, Observable, queueScheduler } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {observeOn} */
describe("observeOn", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should observe on specified scheduler", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--|")
      const e1subs = "  ^-------!"
      const expected = "--a--b--|"
      expectObservable(e1.pipe(observeOn(testScheduler))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should observe after specified delay", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("    --a----b-|   ")
        const e1subs = "    ^--------!   "
        const delay = time("  ---|       ")
        //                         ---|
        //                           ---|
        const expected = "  -----a----b-|"
        expectObservable(e1.pipe(observeOn(testScheduler, delay))).toBe(
          expected
        )
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should observe when source raises error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--#")
      const e1subs = "  ^----!"
      const expected = "--a--#"
      expectObservable(e1.pipe(observeOn(testScheduler))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should observe when source is empty", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -----|")
      const e1subs = "  ^----!"
      const expected = "-----|"
      expectObservable(e1.pipe(observeOn(testScheduler))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should observe when source does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -----")
      const e1subs = "  ^----"
      const expected = "-----"
      expectObservable(e1.pipe(observeOn(testScheduler))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--|")
      const e1subs = "  ^---!    "
      const expected = "--a--    "
      const unsub = "   ----!    "
      const result = e1.pipe(observeOn(testScheduler))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when the result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--|")
      const e1subs = "  ^---!    "
      const expected = "--a--    "
      const unsub = "   ----!    "
      const result = e1.pipe(
        mergeMap(x => of(x)),
        observeOn(testScheduler),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(observeOn(queueScheduler), take(3))
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { TestScheduler } from "rxjs/testing"
import { onErrorResumeNext, take, finalize, tap } from "rxjs/operators"
import { concat, throwError, of, Observable } from "rxjs"
import { asInteropObservable } from "../helpers/interop-helper"
import { observableMatcher } from "../helpers/observableMatcher"
describe("onErrorResumeNext", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should continue observable sequence with next observable", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--b--#        ")
        const e1subs = "  ^-------!        "
        const e2 = cold("         --c--d--|")
        const e2subs = "  --------^-------!"
        const expected = "--a--b----c--d--|"
        expectObservable(e1.pipe(onErrorResumeNext(e2))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should continue with hot observables", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--#        ")
      const e1subs = "  ^-------!        "
      const e2 = hot("  -----x----c--d--|")
      const e2subs = "  --------^-------!"
      const expected = "--a--b----c--d--|"
      expectObservable(e1.pipe(onErrorResumeNext(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should continue with array of multiple observables that throw errors", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--b--#                     ")
        const e1subs = "  ^-------!                     "
        const e2 = [
          cold("                  --c--d--#             "),
          cold("                          --e--#        "),
          cold("                               --f--g--|"),
        ]
        const e2subs = [
          "               --------^-------!",
          "               ----------------^----!",
          "               ---------------------^-------!",
        ]
        const expected = "--a--b----c--d----e----f--g--|"
        expectObservable(e1.pipe(onErrorResumeNext(e2))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2[0].subscriptions).toBe(e2subs[0])
        expectSubscriptions(e2[1].subscriptions).toBe(e2subs[1])
        expectSubscriptions(e2[2].subscriptions).toBe(e2subs[2])
      }
    )
  })
  it("should continue with multiple observables that throw errors", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--b--#                     ")
        const e1subs = "  ^-------!                     "
        const e2 = cold("         --c--d--#             ")
        const e2subs = "  --------^-------!             "
        const e3 = cold("                 --e--#        ")
        const e3subs = "  ----------------^----!        "
        const e4 = cold("                      --f--g--|")
        const e4subs = "  ---------------------^-------!"
        const expected = "--a--b----c--d----e----f--g--|"
        expectObservable(e1.pipe(onErrorResumeNext(e2, e3, e4))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
        expectSubscriptions(e3.subscriptions).toBe(e3subs)
        expectSubscriptions(e4.subscriptions).toBe(e4subs)
      }
    )
  })
  it("should continue with multiple observables that don't throw error", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--b--|                     ")
        const e1subs = "  ^-------!                     "
        const e2 = cold("         --c--d--|             ")
        const e2subs = "  --------^-------!             "
        const e3 = cold("                 --e--|        ")
        const e3subs = "  ----------------^----!        "
        const e4 = cold("                      --f--g--|")
        const e4subs = "  ---------------------^-------!"
        const expected = "--a--b----c--d----e----f--g--|"
        expectObservable(e1.pipe(onErrorResumeNext(e2, e3, e4))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
        expectSubscriptions(e3.subscriptions).toBe(e3subs)
        expectSubscriptions(e4.subscriptions).toBe(e4subs)
      }
    )
  })
  it("should continue after empty observable", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  |                     ")
        const e1subs = "  (^!)                  "
        const e2 = cold(" --c--d--|             ")
        const e2subs = "  ^-------!             "
        const e3 = cold("         --e--#        ")
        const e3subs = "  --------^----!        "
        const e4 = cold("              --f--g--|")
        const e4subs = "  -------------^-------!"
        const expected = "--c--d----e----f--g--|"
        expectObservable(e1.pipe(onErrorResumeNext(e2, e3, e4))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
        expectSubscriptions(e3.subscriptions).toBe(e3subs)
        expectSubscriptions(e4.subscriptions).toBe(e4subs)
      }
    )
  })
  it("should not complete with observable that does not complete", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--b--| ")
        const e1subs = "  ^-------! "
        const e2 = cold("         --")
        const e2subs = "  --------^-"
        const expected = "--a--b----"
        expectObservable(e1.pipe(onErrorResumeNext(e2))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should not continue when source observable does not complete", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--")
        const e1subs = "  ^----"
        const e2 = cold("-b--c-")
        const e2subs: string[] = []
        const expected = "--a--"
        expectObservable(e1.pipe(onErrorResumeNext(e2))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should complete observable when next observable throws", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--b--#        ")
        const e1subs = "  ^-------!        "
        const e2 = cold("         --c--d--#")
        const e2subs = "  --------^-------!"
        const expected = "--a--b----c--d--|"
        expectObservable(e1.pipe(onErrorResumeNext(e2))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    throwError(() => new Error("Some error"))
      .pipe(onErrorResumeNext(synchronousObservable), take(3))
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
  it("should unsubscribe from an interop observable upon explicit unsubscription", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --a--b--#       ")
        const e1subs = "  ^-------!       "
        const e2 = cold("         --c--d--")
        const e2subs = "  --------^---!   "
        const unsub = "   ------------!   "
        const expected = "--a--b----c--   "
        // This test manipulates the observable to make it look like an interop
        // observable - an observable from a foreign library. Interop subscribers
        // are treated differently: they are wrapped in a safe subscriber. This
        // test ensures that unsubscriptions are chained all the way to the
        // interop subscriber.
        expectObservable(
          e1.pipe(onErrorResumeNext(asInteropObservable(e2))),
          unsub
        ).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should work with promise", done => {
    const expected = [1, 2]
    const source = concat(
      of(1),
      throwError(() => "meh")
    )
    source.pipe(onErrorResumeNext(Promise.resolve(2))).subscribe({
      next: x => {
        expect(expected.shift()).to.equal(x)
      },
      error: () => {
        done(new Error("should not be called"))
      },
      complete: () => {
        expect(expected).to.be.empty
        done()
      },
    })
  })
  it("should skip invalid sources and move on", () => {
    const results: any[] = []
    of(1)
      .pipe(onErrorResumeNext([2, 3, 4], { notValid: "LOL" } as any, of(5, 6)))
      .subscribe({
        next: value => results.push(value),
        complete: () => results.push("complete"),
      })
    expect(results).to.deep.equal([1, 2, 3, 4, 5, 6, "complete"])
  })
  it("should call finalize after each sync observable", () => {
    const results: any[] = []
    of(1)
      .pipe(
        finalize(() => results.push("finalize 1")),
        onErrorResumeNext(
          of(2).pipe(finalize(() => results.push("finalize 2"))),
          of(3).pipe(finalize(() => results.push("finalize 3"))),
          of(4).pipe(finalize(() => results.push("finalize 4")))
        )
      )
      .subscribe({
        next: value => results.push(value),
        complete: () => results.push("complete"),
      })
    expect(results).to.deep.equal([
      1,
      "finalize 1",
      2,
      "finalize 2",
      3,
      "finalize 3",
      4,
      "finalize 4",
      "complete",
    ])
  })
  it("should not subscribe to the next source until after the previous is finalized.", () => {
    const results: any[] = []
    of(1)
      .pipe(
        tap({
          subscribe: () => results.push("subscribe 1"),
          finalize: () => results.push("finalize 1"),
        }),
        onErrorResumeNext(
          of(2).pipe(
            tap({
              subscribe: () => results.push("subscribe 2"),
              finalize: () => results.push("finalize 2"),
            })
          ),
          of(3).pipe(
            tap({
              subscribe: () => results.push("subscribe 3"),
              finalize: () => results.push("finalize 3"),
            })
          ),
          of(4).pipe(
            tap({
              subscribe: () => results.push("subscribe 4"),
              finalize: () => results.push("finalize 4"),
            })
          )
        )
      )
      .subscribe({
        next: value => results.push(value),
        complete: () => results.push("complete"),
      })
    expect(results).to.deep.equal([
      "subscribe 1",
      1,
      "finalize 1",
      "subscribe 2",
      2,
      "finalize 2",
      "subscribe 3",
      3,
      "finalize 3",
      "subscribe 4",
      4,
      "finalize 4",
      "complete",
    ])
  })
})
import { TestScheduler } from "rxjs/testing"
import { pairwise, take } from "rxjs/operators"
import { Subject, Observable } from "rxjs"
import { expect } from "chai"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {pairwise} */
describe("pairwise operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should group consecutive emissions as arrays of two", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b-c----d--e---|")
      const e1subs = "  ^------------------!"
      const expected = "-----u-v----w--x---|"
      const values = {
        u: ["a", "b"],
        v: ["b", "c"],
        w: ["c", "d"],
        x: ["d", "e"],
      }
      expectObservable(e1.pipe(pairwise())).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should pairwise things", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--e--f--g--|")
      const e1subs = "     ^--------------------!"
      const expected = "   ------v--w--x--y--z--|"
      const values = {
        v: ["b", "c"],
        w: ["c", "d"],
        x: ["d", "e"],
        y: ["e", "f"],
        z: ["f", "g"],
      }
      expectObservable(e1.pipe(pairwise())).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not emit on single-element streams", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b----|")
      const e1subs = "     ^-------!"
      const expected = "   --------|"
      expectObservable(e1.pipe(pairwise())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle mid-stream throw", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--e--#")
      const e1subs = "     ^--------------!"
      const expected = "   ------v--w--x--#"
      const values = {
        v: ["b", "c"],
        w: ["c", "d"],
        x: ["d", "e"],
      }
      expectObservable(e1.pipe(pairwise())).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      expectObservable(e1.pipe(pairwise())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(pairwise())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle throw", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      expectObservable(e1.pipe(pairwise())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should be recursively re-enterable", () => {
    const results = new Array<[string, string]>()
    const subject = new Subject<string>()
    subject.pipe(pairwise(), take(3)).subscribe(pair => {
      results.push(pair)
      subject.next("c")
    })
    subject.next("a")
    subject.next("b")
    expect(results).to.deep.equal([
      ["a", "b"],
      ["b", "c"],
      ["c", "c"],
    ])
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(pairwise(), take(2)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { TestScheduler } from "rxjs/internal/testing/TestScheduler"
import { pluck, map, mergeMap, take } from "rxjs/operators"
import { of, Observable } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {pluck} */
describe("pluck", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should dematerialize an Observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const inputs = {
        a: "{v:1}",
        b: "{v:2}",
        c: "{v:3}",
      }
      const e1 = cold(" --a--b--c--|", inputs)
      const e1subs = "  ^----------!"
      const expected = "--x--y--z--|"
      const result = e1.pipe(
        map(x => ({ v: x.charAt(3) })),
        pluck("v")
      )
      expectObservable(result).toBe(expected, { x: "1", y: "2", z: "3" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work for one array", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const inputs = { x: ["abc"] }
      const e1 = cold(" --x--|", inputs)
      const e1subs = "  ^----!"
      const expected = "--y--|"
      const result = e1.pipe(pluck(0))
      expectObservable(result).toBe(expected, { y: "abc" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work for one object", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const inputs = { x: { prop: 42 } }
      const e1 = cold(" --x--|", inputs)
      const e1subs = "  ^----!"
      const expected = "--y--|"
      const result = e1.pipe(pluck("prop"))
      expectObservable(result).toBe(expected, { y: 42 })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work for multiple objects", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const inputs = {
        a: { prop: "1" },
        b: { prop: "2" },
        c: { prop: "3" },
        d: { prop: "4" },
        e: { prop: "5" },
      }
      const e1 = cold(" --a-b--c-d---e-|", inputs)
      const e1subs = "  ^--------------!"
      const expected = "--1-2--3-4---5-|"
      const result = e1.pipe(pluck("prop"))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work with deep nested properties", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const inputs = {
        a: { a: { b: { c: "1" } } },
        b: { a: { b: { c: "2" } } },
        c: { a: { b: { c: "3" } } },
        d: { a: { b: { c: "4" } } },
        e: { a: { b: { c: "5" } } },
      }
      const e1 = cold(" --a-b--c-d---e-|", inputs)
      const e1subs = "  ^--------------!"
      const expected = "--1-2--3-4---5-|"
      const result = e1.pipe(pluck("a", "b", "c"))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work with edge cases of deep nested properties", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const inputs = {
        a: { i: { j: { k: 1 } } },
        b: { i: { j: 2 } },
        c: { i: { k: { k: 3 } } },
        d: {},
        e: { i: { j: { k: 5 } } },
      }
      const e1 = cold(" --a-b--c-d---e-|", inputs)
      const e1subs = "  ^--------------!"
      const expected = "--v-w--x-y---z-|"
      const values: { [key: string]: number | undefined } = {
        v: 1,
        w: undefined,
        x: undefined,
        y: undefined,
        z: 5,
      }
      const result = e1.pipe(pluck("i", "j", "k"))
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should throw an error if not property is passed", () => {
    expect(() => {
      of({ prop: 1 }, { prop: 2 }).pipe(pluck())
    }).to.throw(Error, "list of properties cannot be empty.")
  })
  it("should propagate errors from observable that emits only errors", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      const result = e1.pipe(pluck("whatever"))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should propagate errors from observable that emit values", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const inputs = { a: { prop: "1" }, b: { prop: "2" } }
      const e1 = cold(" --a--b--#", inputs, "too bad")
      const e1subs = "  ^-------!"
      const expected = "--1--2--#"
      const result = e1.pipe(pluck("prop"))
      expectObservable(result).toBe(expected, undefined, "too bad")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not pluck an empty observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      const result = e1.pipe(pluck("whatever"))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a--b--c--|", { a: { prop: "1" }, b: { prop: "2" } })
      const e1subs = "  ^-----!     "
      const expected = "--1--2-     "
      const unsub = "   ------!     "
      const result = e1.pipe(pluck("prop"))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should pluck twice", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const inputs = {
        a: { a: { b: { c: "1" } } },
        b: { a: { b: { c: "2" } } },
        c: { a: { b: { c: "3" } } },
        d: { a: { b: { c: "4" } } },
        e: { a: { b: { c: "5" } } },
      }
      const e1 = cold(" --a-b--c-d---e-|", inputs)
      const e1subs = "  ^--------------!"
      const expected = "--1-2--3-4---5-|"
      const result = e1.pipe(pluck("a", "b"), pluck("c"))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chain when unsubscribed explicitly", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const inputs = { a: { prop: "1" }, b: { prop: "2" } }
      const e1 = cold(" --a--b--c--|", inputs)
      const e1subs = "  ^-----!     "
      const expected = "--1--2-     "
      const unsub = "   ------!     "
      const result = e1.pipe(
        mergeMap(x => of(x)),
        pluck("prop"),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should support symbols", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const sym = Symbol("sym")
      const inputs = { x: { [sym]: "abc" } }
      const e1 = cold(" --x--|", inputs)
      const e1subs = "  ^----!"
      const expected = "--y--|"
      const result = e1.pipe(pluck(sym))
      expectObservable(result).toBe(expected, { y: "abc" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break on null values", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const inputs = { x: null }
      const e1 = cold(" --x--|", inputs)
      const e1subs = "  ^----!"
      const expected = "--y--|"
      const result = e1.pipe(pluck("prop"))
      expectObservable(result).toBe(expected, { y: undefined })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(pluck("whatever"), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import {
  publish,
  zip,
  mergeMapTo,
  mergeMap,
  tap,
  refCount,
  retry,
  repeat,
} from "rxjs/operators"
import { ConnectableObservable, of, Subscription, Observable, pipe } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {publish} */
describe("publish operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should mirror a simple source Observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--1-2---3-4--5-|")
      const sourceSubs = " ^--------------!"
      const published = source.pipe(publish()) as ConnectableObservable<any>
      const expected = "   --1-2---3-4--5-|"
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      published.connect()
    })
  })
  it("should return a ConnectableObservable-ish", () => {
    const source = of(1).pipe(publish()) as ConnectableObservable<number>
    expect(typeof (<any>source)._subscribe === "function").to.be.true
    expect(typeof (<any>source).getSubject === "function").to.be.true
    expect(typeof source.connect === "function").to.be.true
    expect(typeof source.refCount === "function").to.be.true
  })
  it("should do nothing if connect is not called, despite subscriptions", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--1-2---3-4--5-|")
      const sourceSubs: string[] = []
      const published = source.pipe(publish())
      const expected = "   -               "
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should multicast the same values to multiple observers", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("   -1-2-3----4-|")
        const sourceSubs = "    ^-----------!"
        const published = source.pipe(
          publish()
        ) as ConnectableObservable<string>
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
        const expected1 = "      -1-2-3----4-|"
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
        const expected2 = "      -----3----4-|"
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
        const expected3 = "      ----------4-|"
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        published.connect()
      }
    )
  })
  it("should accept selectors", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("     -1-2-3----4-|")
      const sourceSubs = [
        "                      ^-----------!",
        "                      ----^-------!",
        "                      --------^---!",
      ]
      const published = source.pipe(
        publish(x =>
          x.pipe(zip(x, (a, b) => (parseInt(a) + parseInt(b)).toString()))
        )
      )
      const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
      const expected1 = "      -2-4-6----8-|"
      const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
      const expected2 = "      -----6----8-|"
      const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
      const expected3 = "      ----------8-|"
      expectObservable(subscriber1).toBe(expected1)
      expectObservable(subscriber2).toBe(expected2)
      expectObservable(subscriber3).toBe(expected3)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should multicast an error from the source to multiple observers", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-3----4-#")
        const sourceSubs = "     ^-----------!"
        const published = source.pipe(
          publish()
        ) as ConnectableObservable<string>
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
        const expected1 = "      -1-2-3----4-#"
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
        const expected2 = "      -----3----4-#"
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
        const expected3 = "      ----------4-#"
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        published.connect()
      }
    )
  })
  it("should multicast the same values to multiple observers, but is unsubscribed explicitly and early", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-3----4-|")
        const sourceSubs = "     ^--------!   "
        const published = source.pipe(
          publish()
        ) as ConnectableObservable<string>
        const unsub = "          ---------u   "
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
        const expected1 = "      -1-2-3----   "
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
        const expected2 = "      -----3----   "
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
        const expected3 = "      ----------   "
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        // Set up unsubscription action
        let connection: Subscription
        expectObservable(
          hot(unsub).pipe(
            tap(() => {
              connection.unsubscribe()
            })
          )
        ).toBe(unsub)
        connection = published.connect()
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-3----4-|")
        const sourceSubs = "     ^--------!   "
        const published = source.pipe(
          mergeMap(x => of(x)),
          publish()
        ) as ConnectableObservable<any>
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
        const expected1 = "      -1-2-3----   "
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
        const expected2 = "      -----3----   "
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
        const expected3 = "      ----------   "
        const unsub = "          ---------u   "
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        // Set up unsubscription action
        let connection: Subscription
        expectObservable(
          hot(unsub).pipe(
            tap(() => {
              connection.unsubscribe()
            })
          )
        ).toBe(unsub)
        connection = published.connect()
      }
    )
  })
  describe("with refCount()", () => {
    it("should connect when first subscriber subscribes", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("       -1-2-3----4-|")
          const sourceSubs = "     ---^-----------!"
          const replayed = source.pipe(publish(), refCount())
          const subscriber1 = hot("---a|           ").pipe(mergeMapTo(replayed))
          const expected1 = "      ----1-2-3----4-|"
          const subscriber2 = hot("-------b|       ").pipe(mergeMapTo(replayed))
          const expected2 = "      --------3----4-|"
          const subscriber3 = hot("-----------c|   ").pipe(mergeMapTo(replayed))
          const expected3 = "      -------------4-|"
          expectObservable(subscriber1).toBe(expected1)
          expectObservable(subscriber2).toBe(expected2)
          expectObservable(subscriber3).toBe(expected3)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        }
      )
    })
    it("should disconnect when last subscriber unsubscribes", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("       -1-2-3----4-|")
          const sourceSubs = "     ---^--------!   "
          const replayed = source.pipe(publish(), refCount())
          const subscriber1 = hot("---a|           ").pipe(mergeMapTo(replayed))
          const unsub1 = "         ----------!     "
          const expected1 = "      ----1-2-3--     "
          const subscriber2 = hot("-------b|       ").pipe(mergeMapTo(replayed))
          const unsub2 = "         ------------!   "
          const expected2 = "      --------3----   "
          expectObservable(subscriber1, unsub1).toBe(expected1)
          expectObservable(subscriber2, unsub2).toBe(expected2)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        }
      )
    })
    it("should NOT be retryable", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("   -1-2-3----4-#")
          const sourceSubs = "    ^-----------!"
          const published = source.pipe(publish(), refCount(), retry(3))
          const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
          const expected1 = "      -1-2-3----4-#"
          const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
          const expected2 = "      -----3----4-#"
          const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
          const expected3 = "      ----------4-#"
          expectObservable(subscriber1).toBe(expected1)
          expectObservable(subscriber2).toBe(expected2)
          expectObservable(subscriber3).toBe(expected3)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        }
      )
    })
    it("should NOT be repeatable", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("    -1-2-3----4-|")
          const sourceSubs = "     ^-----------!"
          const published = source.pipe(publish(), refCount(), repeat(3))
          const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
          const expected1 = "      -1-2-3----4-|"
          const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
          const expected2 = "      -----3----4-|"
          const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
          const expected3 = "      ----------4-|"
          expectObservable(subscriber1).toBe(expected1)
          expectObservable(subscriber2).toBe(expected2)
          expectObservable(subscriber3).toBe(expected3)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        }
      )
    })
  })
  it("should emit completed when subscribed after completed", done => {
    const results1: number[] = []
    const results2: number[] = []
    let subscriptions = 0
    const source = new Observable<number>(observer => {
      subscriptions++
      observer.next(1)
      observer.next(2)
      observer.next(3)
      observer.next(4)
      observer.complete()
    })
    const connectable = source.pipe(publish()) as ConnectableObservable<number>
    connectable.subscribe(x => {
      results1.push(x)
    })
    expect(results1).to.deep.equal([])
    expect(results2).to.deep.equal([])
    connectable.connect()
    expect(results1).to.deep.equal([1, 2, 3, 4])
    expect(results2).to.deep.equal([])
    expect(subscriptions).to.equal(1)
    connectable.subscribe({
      next: x => {
        results2.push(x)
      },
      error: x => {
        done(new Error("should not be called"))
      },
      complete: () => {
        expect(results2).to.deep.equal([])
        done()
      },
    })
  })
  it("should multicast an empty source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("|   ")
      const sourceSubs = " (^!)"
      const published = source.pipe(publish()) as ConnectableObservable<string>
      const expected = "   |   "
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      published.connect()
    })
  })
  it("should multicast a never source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("-")
      const sourceSubs = " ^"
      const published = source.pipe(publish()) as ConnectableObservable<string>
      const expected = "   -"
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      published.connect()
    })
  })
  it("should multicast a throw source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("#   ")
      const sourceSubs = " (^!)"
      const published = source.pipe(publish()) as ConnectableObservable<string>
      const expected = "   #   "
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      published.connect()
    })
  })
  it("should multicast one observable to multiple observers", done => {
    const results1: number[] = []
    const results2: number[] = []
    let subscriptions = 0
    const source = new Observable<number>(observer => {
      subscriptions++
      observer.next(1)
      observer.next(2)
      observer.next(3)
      observer.next(4)
      observer.complete()
    })
    const connectable = source.pipe(publish()) as ConnectableObservable<number>
    connectable.subscribe(x => {
      results1.push(x)
    })
    connectable.subscribe(x => {
      results2.push(x)
    })
    expect(results1).to.deep.equal([])
    expect(results2).to.deep.equal([])
    connectable.connect()
    expect(results1).to.deep.equal([1, 2, 3, 4])
    expect(results2).to.deep.equal([1, 2, 3, 4])
    expect(subscriptions).to.equal(1)
    done()
  })
  it("should be referentially-transparent", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source1 = cold("-1-2-3-4-5-|")
      const source1Subs = " ^----------!"
      const expected1 = "   -1-2-3-4-5-|"
      const source2 = cold("-6-7-8-9-0-|")
      const source2Subs = " ^----------!"
      const expected2 = "   -6-7-8-9-0-|"
      // Calls to the _operator_ must be referentially-transparent.
      const partialPipeLine = pipe(publish())
      // The non-referentially-transparent publishing occurs within the _operator function_
      // returned by the _operator_ and that happens when the complete pipeline is composed.
      const published1 = source1.pipe(
        partialPipeLine
      ) as ConnectableObservable<any>
      const published2 = source2.pipe(
        partialPipeLine
      ) as ConnectableObservable<any>
      expectObservable(published1).toBe(expected1)
      expectSubscriptions(source1.subscriptions).toBe(source1Subs)
      expectObservable(published2).toBe(expected2)
      expectSubscriptions(source2.subscriptions).toBe(source2Subs)
      published1.connect()
      published2.connect()
    })
  })
})
import { expect } from "chai"
import {
  publishBehavior,
  mergeMapTo,
  tap,
  mergeMap,
  refCount,
  retry,
  repeat,
} from "rxjs/operators"
import { ConnectableObservable, of, Subscription, Observable, pipe } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {publishBehavior} */
describe("publishBehavior operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should mirror a simple source Observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--1-2---3-4--5-|")
      const sourceSubs = " ^--------------!"
      const published = source.pipe(
        publishBehavior("0")
      ) as ConnectableObservable<string>
      const expected = "   0-1-2---3-4--5-|"
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      published.connect()
    })
  })
  it("should return a ConnectableObservable-ish", () => {
    const source = of(1).pipe(
      publishBehavior(1)
    ) as ConnectableObservable<number>
    expect(typeof (<any>source)._subscribe === "function").to.be.true
    expect(typeof (<any>source).getSubject === "function").to.be.true
    expect(typeof source.connect === "function").to.be.true
    expect(typeof source.refCount === "function").to.be.true
  })
  it("should only emit default value if connect is not called, despite subscriptions", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--1-2---3-4--5-|")
      const sourceSubs: string[] = []
      const published = source.pipe(publishBehavior("0"))
      const expected = "   0               "
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should multicast the same values to multiple observers", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("   -1-2-3----4-| ")
        const sourceSubs = "    ^-----------! "
        const published = source.pipe(
          publishBehavior("0")
        ) as ConnectableObservable<string>
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
        const expected1 = "      01-2-3----4-|"
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
        const expected2 = "      ----23----4-|"
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
        const expected3 = "      --------3-4-|"
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        published.connect()
      }
    )
  })
  it("should multicast an error from the source to multiple observers", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-3----4-#")
        const sourceSubs = "     ^-----------!"
        const published = source.pipe(
          publishBehavior("0")
        ) as ConnectableObservable<string>
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
        const expected1 = "      01-2-3----4-#"
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
        const expected2 = "      ----23----4-#"
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
        const expected3 = "      --------3-4-#"
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        published.connect()
      }
    )
  })
  it("should multicast the same values to multiple observers, but is unsubscribed explicitly and early", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-3----4-|")
        const sourceSubs = "     ^--------!   "
        const published = source.pipe(
          publishBehavior("0")
        ) as ConnectableObservable<string>
        const unsub = "          ---------u   "
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
        const expected1 = "      01-2-3----   "
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
        const expected2 = "      ----23----   "
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
        const expected3 = "      --------3-   "
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        // Set up unsubscription action
        let connection: Subscription
        expectObservable(
          hot(unsub).pipe(
            tap(() => {
              connection.unsubscribe()
            })
          )
        ).toBe(unsub)
        connection = published.connect()
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("   -1-2-3----4-|")
        const sourceSubs = "    ^--------!   "
        const published = source.pipe(
          mergeMap(x => of(x)),
          publishBehavior("0")
        ) as ConnectableObservable<string>
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
        const expected1 = "      01-2-3----   "
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
        const expected2 = "      ----23----   "
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
        const expected3 = "      --------3-   "
        const unsub = "          ---------u   "
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        // Set up unsubscription action
        let connection: Subscription
        expectObservable(
          hot(unsub).pipe(
            tap(() => {
              connection.unsubscribe()
            })
          )
        ).toBe(unsub)
        connection = published.connect()
      }
    )
  })
  describe("with refCount()", () => {
    it("should connect when first subscriber subscribes", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("       -1-2-3----4-|")
          const sourceSubs = "     ---^-----------!"
          const replayed = source.pipe(publishBehavior("0"), refCount())
          const subscriber1 = hot("---a|           ").pipe(mergeMapTo(replayed))
          const expected1 = "      ---01-2-3----4-|"
          const subscriber2 = hot("-------b|       ").pipe(mergeMapTo(replayed))
          const expected2 = "      -------23----4-|"
          const subscriber3 = hot("-----------c|   ").pipe(mergeMapTo(replayed))
          const expected3 = "      -----------3-4-|"
          expectObservable(subscriber1).toBe(expected1)
          expectObservable(subscriber2).toBe(expected2)
          expectObservable(subscriber3).toBe(expected3)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        }
      )
    })
    it("should disconnect when last subscriber unsubscribes", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("       -1-2-3----4-|")
          const sourceSubs = "     ---^--------!   "
          const replayed = source.pipe(publishBehavior("0"), refCount())
          const subscriber1 = hot("---a|           ").pipe(mergeMapTo(replayed))
          const unsub1 = "         ----------!     "
          const expected1 = "      ---01-2-3--     "
          const subscriber2 = hot("-------b|       ").pipe(mergeMapTo(replayed))
          const unsub2 = "         ------------!   "
          const expected2 = "      -------23----   "
          expectObservable(subscriber1, unsub1).toBe(expected1)
          expectObservable(subscriber2, unsub2).toBe(expected2)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        }
      )
    })
    it("should NOT be retryable", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("    -1-2-3----4-#")
          const sourceSubs = "     ^-----------!"
          const published = source.pipe(
            publishBehavior("0"),
            refCount(),
            retry(3)
          )
          const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
          const expected1 = "      01-2-3----4-#"
          const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
          const expected2 = "      ----23----4-#"
          const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
          const expected3 = "      --------3-4-#"
          expectObservable(subscriber1).toBe(expected1)
          expectObservable(subscriber2).toBe(expected2)
          expectObservable(subscriber3).toBe(expected3)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        }
      )
    })
    it("should NOT be repeatable", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("    -1-2-3----4-|")
          const sourceSubs = "     ^-----------!"
          const published = source.pipe(
            publishBehavior("0"),
            refCount(),
            repeat(3)
          )
          const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
          const expected1 = "      01-2-3----4-|"
          const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
          const expected2 = "      ----23----4-|"
          const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
          const expected3 = "      --------3-4-|"
          expectObservable(subscriber1).toBe(expected1)
          expectObservable(subscriber2).toBe(expected2)
          expectObservable(subscriber3).toBe(expected3)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        }
      )
    })
  })
  it("should emit completed when subscribed after completed", done => {
    const results1: number[] = []
    const results2: number[] = []
    let subscriptions = 0
    const source = new Observable<number>(observer => {
      subscriptions++
      observer.next(1)
      observer.next(2)
      observer.next(3)
      observer.next(4)
      observer.complete()
    })
    const connectable = source.pipe(
      publishBehavior(0)
    ) as ConnectableObservable<number>
    connectable.subscribe(function (x) {
      results1.push(x)
    })
    expect(results1).to.deep.equal([0])
    expect(results2).to.deep.equal([])
    connectable.connect()
    expect(results1).to.deep.equal([0, 1, 2, 3, 4])
    expect(results2).to.deep.equal([])
    expect(subscriptions).to.equal(1)
    connectable.subscribe({
      next: function (x) {
        results2.push(x)
      },
      error: x => {
        done(new Error("should not be called"))
      },
      complete: () => {
        expect(results2).to.deep.equal([])
        done()
      },
    })
  })
  it("should multicast an empty source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("|   ")
      const sourceSubs = " (^!)"
      const published = source.pipe(
        publishBehavior("0")
      ) as ConnectableObservable<string>
      const expected = "   (0|)"
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      published.connect()
    })
  })
  it("should multicast a never source", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("-")
        const sourceSubs = " ^"
        const published = source.pipe(
          publishBehavior("0")
        ) as ConnectableObservable<string>
        const expected = "   0"
        expectObservable(published).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        published.connect()
      }
    )
  })
  it("should multicast a throw source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("#  ")
      const sourceSubs = " (^!)"
      const published = source.pipe(
        publishBehavior("0")
      ) as ConnectableObservable<string>
      const expected = "   (0#)"
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      published.connect()
    })
  })
  it("should multicast one observable to multiple observers", done => {
    const results1: number[] = []
    const results2: number[] = []
    let subscriptions = 0
    const source = new Observable<number>(observer => {
      subscriptions++
      observer.next(1)
      observer.next(2)
      observer.next(3)
      observer.next(4)
    })
    const connectable = source.pipe(
      publishBehavior(0)
    ) as ConnectableObservable<number>
    connectable.subscribe(x => {
      results1.push(x)
    })
    expect(results1).to.deep.equal([0])
    connectable.connect()
    expect(results2).to.deep.equal([])
    connectable.subscribe(x => {
      results2.push(x)
    })
    expect(results1).to.deep.equal([0, 1, 2, 3, 4])
    expect(results2).to.deep.equal([4])
    expect(subscriptions).to.equal(1)
    done()
  })
  it("should follow the RxJS 4 behavior and emit nothing to observer after completed", done => {
    const results: number[] = []
    const source = new Observable<number>(observer => {
      observer.next(1)
      observer.next(2)
      observer.next(3)
      observer.next(4)
      observer.complete()
    })
    const connectable = source.pipe(
      publishBehavior(0)
    ) as ConnectableObservable<number>
    connectable.connect()
    connectable.subscribe(x => {
      results.push(x)
    })
    expect(results).to.deep.equal([])
    done()
  })
  it("should be referentially-transparent", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source1 = cold("-1-2-3-4-5-|")
      const source1Subs = " ^----------!"
      const expected1 = "   x1-2-3-4-5-|"
      const source2 = cold("-6-7-8-9-0-|")
      const source2Subs = " ^----------!"
      const expected2 = "   x6-7-8-9-0-|"
      // Calls to the _operator_ must be referentially-transparent.
      const partialPipeLine = pipe(publishBehavior("x"))
      // The non-referentially-transparent publishing occurs within the _operator function_
      // returned by the _operator_ and that happens when the complete pipeline is composed.
      const published1 = source1.pipe(
        partialPipeLine
      ) as ConnectableObservable<any>
      const published2 = source2.pipe(
        partialPipeLine
      ) as ConnectableObservable<any>
      expectObservable(published1).toBe(expected1)
      expectSubscriptions(source1.subscriptions).toBe(source1Subs)
      expectObservable(published2).toBe(expected2)
      expectSubscriptions(source2.subscriptions).toBe(source2Subs)
      published1.connect()
      published2.connect()
    })
  })
})
import { expect } from "chai"
import {
  publishLast,
  mergeMapTo,
  tap,
  mergeMap,
  refCount,
  retry,
} from "rxjs/operators"
import { ConnectableObservable, of, Subscription, Observable, pipe } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {publishLast} */
describe("publishLast operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should emit last notification of a simple source Observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--1-2---3-4--5-|   ")
      const sourceSubs = " ^--------------!   "
      const published = source.pipe(
        publishLast()
      ) as ConnectableObservable<string>
      const expected = "   ---------------(5|)"
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      published.connect()
    })
  })
  it("should return a ConnectableObservable-ish", () => {
    const source = of(1).pipe(publishLast()) as ConnectableObservable<number>
    expect(typeof (<any>source)._subscribe === "function").to.be.true
    expect(typeof (<any>source).getSubject === "function").to.be.true
    expect(typeof source.connect === "function").to.be.true
    expect(typeof source.refCount === "function").to.be.true
  })
  it("should do nothing if connect is not called, despite subscriptions", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--1-2---3-4--5-|")
      const sourceSubs: string[] = []
      const published = source.pipe(publishLast())
      const expected = "   -               "
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should multicast the same values to multiple observers", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-3----4-|   ")
        const sourceSubs = "     ^-----------!   "
        const published = source.pipe(
          publishLast()
        ) as ConnectableObservable<string>
        const subscriber1 = hot("a|              ").pipe(mergeMapTo(published))
        const expected1 = "      ------------(4|)"
        const subscriber2 = hot("----b|          ").pipe(mergeMapTo(published))
        const expected2 = "      ------------(4|)"
        const subscriber3 = hot("--------c|      ").pipe(mergeMapTo(published))
        const expected3 = "      ------------(4|)"
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        published.connect()
      }
    )
  })
  it("should multicast an error from the source to multiple observers", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-3----4-#")
        const sourceSubs = "     ^-----------!"
        const published = source.pipe(
          publishLast()
        ) as ConnectableObservable<string>
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
        const expected1 = "      ------------#"
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
        const expected2 = "      ------------#"
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
        const expected3 = "      ------------#"
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        published.connect()
      }
    )
  })
  it("should not cast any values to multiple observers, when source is unsubscribed explicitly and early", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-3----4-|")
        const sourceSubs = "     ^--------!   "
        const published = source.pipe(
          publishLast()
        ) as ConnectableObservable<string>
        const unsub = "          ---------u   "
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
        const expected1 = "      ----------   "
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
        const expected2 = "      ----------   "
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
        const expected3 = "      ----------   "
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        // Set up unsubscription action
        let connection: Subscription
        expectObservable(
          hot(unsub).pipe(
            tap(() => {
              connection.unsubscribe()
            })
          )
        ).toBe(unsub)
        connection = published.connect()
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-3----4-|")
        const sourceSubs = "     ^--------!   "
        const published = source.pipe(
          mergeMap(x => of(x)),
          publishLast()
        ) as ConnectableObservable<string>
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
        const expected1 = "      ----------   "
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
        const expected2 = "      ----------   "
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
        const expected3 = "      ----------   "
        const unsub = "          ---------u   "
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        // Set up unsubscription action
        let connection: Subscription
        expectObservable(
          hot(unsub).pipe(
            tap(() => {
              connection.unsubscribe()
            })
          )
        ).toBe(unsub)
        connection = published.connect()
      }
    )
  })
  describe("with refCount()", () => {
    it("should connect when first subscriber subscribes", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("       -1-2-3----4-|")
          const sourceSubs = "     ---^-----------!"
          const replayed = source.pipe(publishLast(), refCount())
          const subscriber1 = hot("---a|              ").pipe(
            mergeMapTo(replayed)
          )
          const expected1 = "      ---------------(4|)"
          const subscriber2 = hot("-------b|          ").pipe(
            mergeMapTo(replayed)
          )
          const expected2 = "      ---------------(4|)"
          const subscriber3 = hot("-----------c|      ").pipe(
            mergeMapTo(replayed)
          )
          const expected3 = "      ---------------(4|)"
          expectObservable(subscriber1).toBe(expected1)
          expectObservable(subscriber2).toBe(expected2)
          expectObservable(subscriber3).toBe(expected3)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        }
      )
    })
    it("should disconnect when last subscriber unsubscribes", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("       -1-2-3----4-|")
          const sourceSubs = "     ---^--------!   "
          const replayed = source.pipe(publishLast(), refCount())
          const subscriber1 = hot("---a|           ").pipe(mergeMapTo(replayed))
          const unsub1 = "         ----------!     "
          const expected1 = "      -----------     "
          const subscriber2 = hot("-------b|       ").pipe(mergeMapTo(replayed))
          const unsub2 = "         ------------!   "
          const expected2 = "      -------------   "
          expectObservable(subscriber1, unsub1).toBe(expected1)
          expectObservable(subscriber2, unsub2).toBe(expected2)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        }
      )
    })
    it("should NOT be retryable", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("    -1-2-3----4-#")
          const sourceSubs = "     ^-----------!"
          const published = source.pipe(publishLast(), refCount(), retry(3))
          const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
          const expected1 = "      ------------#"
          const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
          const expected2 = "      ------------#"
          const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
          const expected3 = "      ------------#"
          expectObservable(subscriber1).toBe(expected1)
          expectObservable(subscriber2).toBe(expected2)
          expectObservable(subscriber3).toBe(expected3)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        }
      )
    })
  })
  it("should multicast an empty source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("|   ")
      const sourceSubs = " (^!)"
      const published = source.pipe(
        publishLast()
      ) as ConnectableObservable<string>
      const expected = "   |   "
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      published.connect()
    })
  })
  it("should multicast a never source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("-")
      const sourceSubs = " ^"
      const published = source.pipe(
        publishLast()
      ) as ConnectableObservable<string>
      const expected = "   -"
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      published.connect()
    })
  })
  it("should multicast a throw source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("#   ")
      const sourceSubs = " (^!)"
      const published = source.pipe(
        publishLast()
      ) as ConnectableObservable<string>
      const expected = "   #   "
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      published.connect()
    })
  })
  it("should multicast one observable to multiple observers", done => {
    const results1: number[] = []
    const results2: number[] = []
    let subscriptions = 0
    const source = new Observable<number>(observer => {
      subscriptions++
      observer.next(1)
      observer.next(2)
      observer.next(3)
      observer.next(4)
      observer.complete()
    })
    const connectable = source.pipe(
      publishLast()
    ) as ConnectableObservable<number>
    connectable.subscribe(x => {
      results1.push(x)
    })
    connectable.subscribe(x => {
      results2.push(x)
    })
    expect(results1).to.deep.equal([])
    expect(results2).to.deep.equal([])
    connectable.connect()
    expect(results1).to.deep.equal([4])
    expect(results2).to.deep.equal([4])
    expect(subscriptions).to.equal(1)
    done()
  })
  it("should be referentially-transparent", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source1 = cold("-1-2-3-4-5-|   ")
      const source1Subs = " ^----------!   "
      const expected1 = "   -----------(5|)"
      const source2 = cold("-6-7-8-9-0-|   ")
      const source2Subs = " ^----------!   "
      const expected2 = "   -----------(0|)"
      // Calls to the _operator_ must be referentially-transparent.
      const partialPipeLine = pipe(publishLast())
      // The non-referentially-transparent publishing occurs within the _operator function_
      // returned by the _operator_ and that happens when the complete pipeline is composed.
      const published1 = source1.pipe(
        partialPipeLine
      ) as ConnectableObservable<any>
      const published2 = source2.pipe(
        partialPipeLine
      ) as ConnectableObservable<any>
      expectObservable(published1).toBe(expected1)
      expectSubscriptions(source1.subscriptions).toBe(source1Subs)
      expectObservable(published2).toBe(expected2)
      expectSubscriptions(source2.subscriptions).toBe(source2Subs)
      published1.connect()
      published2.connect()
    })
  })
})
import { expect } from "chai"
import {
  throwError,
  ConnectableObservable,
  EMPTY,
  NEVER,
  of,
  Observable,
  Subscription,
  pipe,
} from "rxjs"
import {
  publishReplay,
  mergeMapTo,
  tap,
  mergeMap,
  refCount,
  retry,
  repeat,
  map,
} from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {publishReplay} */
describe("publishReplay operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should mirror a simple source Observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--1-2---3-4--5-|")
      const sourceSubs = " ^--------------!"
      const published = source.pipe(
        publishReplay(1)
      ) as ConnectableObservable<string>
      const expected = "   --1-2---3-4--5-|"
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      published.connect()
    })
  })
  it("should return a ConnectableObservable-ish", () => {
    const source = of(1).pipe(publishReplay()) as ConnectableObservable<number>
    expect(typeof (<any>source)._subscribe === "function").to.be.true
    expect(typeof (<any>source).getSubject === "function").to.be.true
    expect(typeof source.connect === "function").to.be.true
    expect(typeof source.refCount === "function").to.be.true
  })
  it("should do nothing if connect is not called, despite subscriptions", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--1-2---3-4--5-|")
      const sourceSubs: string[] = []
      const published = source.pipe(publishReplay(1))
      const expected = "   -"
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should multicast the same values to multiple observers, bufferSize=1", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-3----4-|")
        const sourceSubs = "     ^-----------!"
        const published = source.pipe(
          publishReplay(1)
        ) as ConnectableObservable<string>
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
        const expected1 = "      -1-2-3----4-|"
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
        const expected2 = "      ----23----4-|"
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
        const expected3 = "      --------3-4-|"
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        published.connect()
      }
    )
  })
  it("should multicast the same values to multiple observers, bufferSize=2", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-----3------4-|")
        const sourceSubs = "     ^-----------------!"
        const published = source.pipe(
          publishReplay(2)
        ) as ConnectableObservable<string>
        const subscriber1 = hot("a|                 ").pipe(
          mergeMapTo(published)
        )
        const expected1 = "      -1-2-----3------4-|"
        const subscriber2 = hot("----b|             ").pipe(
          mergeMapTo(published)
        )
        const expected2 = "      ----(12)-3------4-|"
        const subscriber3 = hot("-----------c|      ").pipe(
          mergeMapTo(published)
        )
        const expected3 = "      -----------(23)-4-|"
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        published.connect()
      }
    )
  })
  it("should multicast an error from the source to multiple observers", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-3----4-#")
        const sourceSubs = "     ^-----------!"
        const published = source.pipe(
          publishReplay(1)
        ) as ConnectableObservable<string>
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
        const expected1 = "      -1-2-3----4-#"
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
        const expected2 = "      ----23----4-#"
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
        const expected3 = "      --------3-4-#"
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        published.connect()
      }
    )
  })
  it("should multicast the same values to multiple observers, but is unsubscribed explicitly and early", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-3----4-|")
        const sourceSubs = "     ^--------!   "
        const published = source.pipe(
          publishReplay(1)
        ) as ConnectableObservable<string>
        const unsub = "          ---------u   "
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
        const expected1 = "      -1-2-3----   "
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
        const expected2 = "      ----23----   "
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
        const expected3 = "      --------3-   "
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        // Set up unsubscription action
        let connection: Subscription
        expectObservable(
          hot(unsub).pipe(
            tap(() => {
              connection.unsubscribe()
            })
          )
        ).toBe(unsub)
        connection = published.connect()
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-3----4-|")
        const sourceSubs = "     ^--------!   "
        const published = source.pipe(
          mergeMap(x => of(x)),
          publishReplay(1)
        ) as ConnectableObservable<string>
        const subscriber1 = hot("a|           ").pipe(mergeMapTo(published))
        const expected1 = "      -1-2-3----   "
        const subscriber2 = hot("----b|       ").pipe(mergeMapTo(published))
        const expected2 = "      ----23----   "
        const subscriber3 = hot("--------c|   ").pipe(mergeMapTo(published))
        const expected3 = "      --------3-   "
        const unsub = "          ---------u   "
        expectObservable(subscriber1).toBe(expected1)
        expectObservable(subscriber2).toBe(expected2)
        expectObservable(subscriber3).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        // Set up unsubscription action
        let connection: Subscription
        expectObservable(
          hot(unsub).pipe(
            tap(() => {
              connection.unsubscribe()
            })
          )
        ).toBe(unsub)
        connection = published.connect()
      }
    )
  })
  describe("with refCount()", () => {
    it("should connect when first subscriber subscribes", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("       -1-2-3----4-|")
          const sourceSubs = "     ---^-----------!"
          const replayed = source.pipe(publishReplay(1), refCount())
          const subscriber1 = hot("---a|           ").pipe(mergeMapTo(replayed))
          const expected1 = "      ----1-2-3----4-|"
          const subscriber2 = hot("-------b|       ").pipe(mergeMapTo(replayed))
          const expected2 = "      -------23----4-|"
          const subscriber3 = hot("-----------c|   ").pipe(mergeMapTo(replayed))
          const expected3 = "      -----------3-4-|"
          expectObservable(subscriber1).toBe(expected1)
          expectObservable(subscriber2).toBe(expected2)
          expectObservable(subscriber3).toBe(expected3)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        }
      )
    })
    it("should disconnect when last subscriber unsubscribes", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("       -1-2-3----4-|")
          const sourceSubs = "     ---^--------!   "
          const replayed = source.pipe(publishReplay(1), refCount())
          const subscriber1 = hot("---a|           ").pipe(mergeMapTo(replayed))
          const unsub1 = "         ----------!     "
          const expected1 = "      ----1-2-3--     "
          const subscriber2 = hot("-------b|       ").pipe(mergeMapTo(replayed))
          const unsub2 = "         ------------!   "
          const expected2 = "      -------23----   "
          expectObservable(subscriber1, unsub1).toBe(expected1)
          expectObservable(subscriber2, unsub2).toBe(expected2)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        }
      )
    })
    it("should NOT be retryable", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("    -1-2-3----4-#     ")
          const sourceSubs = "     ^-----------!     "
          const published = source.pipe(publishReplay(1), refCount(), retry(3))
          const subscriber1 = hot("a|                ").pipe(
            mergeMapTo(published)
          )
          const expected1 = "      -1-2-3----4-(444#)"
          const subscriber2 = hot("----b|            ").pipe(
            mergeMapTo(published)
          )
          const expected2 = "      ----23----4-(444#)"
          const subscriber3 = hot("--------c|        ").pipe(
            mergeMapTo(published)
          )
          const expected3 = "      --------3-4-(444#)"
          expectObservable(subscriber1).toBe(expected1)
          expectObservable(subscriber2).toBe(expected2)
          expectObservable(subscriber3).toBe(expected3)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        }
      )
    })
    it("should NOT be repeatable", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("    -1-2-3----4-|    ")
          const sourceSubs = "     ^-----------!    "
          const published = source.pipe(publishReplay(1), refCount(), repeat(3))
          const subscriber1 = hot("a|               ").pipe(
            mergeMapTo(published)
          )
          const expected1 = "      -1-2-3----4-(44|)"
          const subscriber2 = hot("----b|           ").pipe(
            mergeMapTo(published)
          )
          const expected2 = "      ----23----4-(44|)"
          const subscriber3 = hot("--------c|       ").pipe(
            mergeMapTo(published)
          )
          const expected3 = "      --------3-4-(44|)"
          expectObservable(subscriber1).toBe(expected1)
          expectObservable(subscriber2).toBe(expected2)
          expectObservable(subscriber3).toBe(expected3)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        }
      )
    })
  })
  it("should multicast one observable to multiple observers", done => {
    const results1: number[] = []
    const results2: number[] = []
    let subscriptions = 0
    const source = new Observable<number>(observer => {
      subscriptions++
      observer.next(1)
      observer.next(2)
      observer.next(3)
      observer.next(4)
      observer.complete()
    })
    const connectable = source.pipe(
      publishReplay()
    ) as ConnectableObservable<number>
    connectable.subscribe(x => {
      results1.push(x)
    })
    connectable.subscribe(x => {
      results2.push(x)
    })
    expect(results1).to.deep.equal([])
    expect(results2).to.deep.equal([])
    connectable.connect()
    expect(results1).to.deep.equal([1, 2, 3, 4])
    expect(results2).to.deep.equal([1, 2, 3, 4])
    expect(subscriptions).to.equal(1)
    done()
  })
  it("should replay as many events as specified by the bufferSize", done => {
    const results1: number[] = []
    const results2: number[] = []
    let subscriptions = 0
    const source = new Observable<number>(observer => {
      subscriptions++
      observer.next(1)
      observer.next(2)
      observer.next(3)
      observer.next(4)
      observer.complete()
    })
    const connectable = source.pipe(
      publishReplay(2)
    ) as ConnectableObservable<number>
    connectable.subscribe(x => {
      results1.push(x)
    })
    expect(results1).to.deep.equal([])
    expect(results2).to.deep.equal([])
    connectable.connect()
    connectable.subscribe(x => {
      results2.push(x)
    })
    expect(results1).to.deep.equal([1, 2, 3, 4])
    expect(results2).to.deep.equal([3, 4])
    expect(subscriptions).to.equal(1)
    done()
  })
  it("should emit replayed values and resubscribe to the source when reconnected without source completion", () => {
    const results1: number[] = []
    const results2: number[] = []
    let subscriptions = 0
    const source = new Observable<number>(observer => {
      subscriptions++
      observer.next(1)
      observer.next(2)
      observer.next(3)
      observer.next(4)
      // observer.complete();
    })
    const connectable = source.pipe(
      publishReplay(2)
    ) as ConnectableObservable<number>
    const subscription1 = connectable.subscribe(x => {
      results1.push(x)
    })
    expect(results1).to.deep.equal([])
    expect(results2).to.deep.equal([])
    connectable.connect().unsubscribe()
    subscription1.unsubscribe()
    expect(results1).to.deep.equal([1, 2, 3, 4])
    expect(results2).to.deep.equal([])
    expect(subscriptions).to.equal(1)
    const subscription2 = connectable.subscribe(x => {
      results2.push(x)
    })
    connectable.connect().unsubscribe()
    subscription2.unsubscribe()
    expect(results1).to.deep.equal([1, 2, 3, 4])
    expect(results2).to.deep.equal([3, 4, 1, 2, 3, 4])
    expect(subscriptions).to.equal(2)
  })
  it("should emit replayed values plus completed when subscribed after completed", done => {
    const results1: number[] = []
    const results2: number[] = []
    let subscriptions = 0
    const source = new Observable<number>(observer => {
      subscriptions++
      observer.next(1)
      observer.next(2)
      observer.next(3)
      observer.next(4)
      observer.complete()
    })
    const connectable = source.pipe(
      publishReplay(2)
    ) as ConnectableObservable<number>
    connectable.subscribe(x => {
      results1.push(x)
    })
    expect(results1).to.deep.equal([])
    expect(results2).to.deep.equal([])
    connectable.connect()
    expect(results1).to.deep.equal([1, 2, 3, 4])
    expect(results2).to.deep.equal([])
    expect(subscriptions).to.equal(1)
    connectable.subscribe({
      next: x => {
        results2.push(x)
      },
      error: x => {
        done(new Error("should not be called"))
      },
      complete: () => {
        expect(results2).to.deep.equal([3, 4])
        done()
      },
    })
  })
  it("should multicast an empty source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("|  ")
      const sourceSubs = " (^!)"
      const published = source.pipe(
        publishReplay(1)
      ) as ConnectableObservable<string>
      const expected = "   |"
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      published.connect()
    })
  })
  it("should multicast a never source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("-")
      const sourceSubs = " ^"
      const published = source.pipe(
        publishReplay(1)
      ) as ConnectableObservable<string>
      const expected = "   -"
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      published.connect()
    })
  })
  it("should multicast a throw source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("#   ")
      const sourceSubs = " (^!)"
      const published = source.pipe(
        publishReplay(1)
      ) as ConnectableObservable<string>
      const expected = "   #   "
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      published.connect()
    })
  })
  it("should mirror a simple source Observable with selector", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const values = { a: 2, b: 4, c: 6, d: 8 }
      const selector = (observable: Observable<string>) =>
        observable.pipe(map(v => 2 * +v))
      const source = cold("--1-2---3-4---|")
      const sourceSubs = " ^-------------!"
      const published = source.pipe(publishReplay(1, Infinity, selector))
      const expected = "   --a-b---c-d---|"
      expectObservable(published).toBe(expected, values)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should EMIT an error when the selector throws an exception", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const error = "It's broken"
      const selector = () => {
        throw error
      }
      const source = cold("--1-2---3-4---|")
      const published = source.pipe(publishReplay(1, Infinity, selector))
      const expected = "   #              "
      expectObservable(published).toBe(expected, undefined, "It's broken")
    })
  })
  it("should emit an error when the selector returns an Observable that emits an error", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const error = "It's broken"
      const innerObservable = cold("--5-6----#", undefined, error)
      const selector = (observable: Observable<string>) =>
        observable.pipe(mergeMapTo(innerObservable))
      const source = cold("--1--2---3---|")
      const sourceSubs = " ^----------!  "
      const published = source.pipe(publishReplay(1, Infinity, selector))
      const expected = "   ----5-65-6-#  "
      expectObservable(published).toBe(expected, undefined, error)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should terminate immediately when the selector returns an empty Observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const selector = () => EMPTY
      const source = cold("--1--2---3---|")
      const sourceSubs = " (^!)          "
      const published = source.pipe(publishReplay(1, Infinity, selector))
      const expected = "   |             "
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should not emit and should not complete/error when the selector returns never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const selector = () => NEVER
      const source = cold("-")
      const sourceSubs = " ^"
      const published = source.pipe(publishReplay(1, Infinity, selector))
      const expected = "   -"
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should emit error when the selector returns Observable.throw", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const error = "It's broken"
      const selector = () => throwError(() => error)
      const source = cold("--1--2---3---|")
      const sourceSubs = " (^!)          "
      const published = source.pipe(publishReplay(1, Infinity, selector))
      const expected = "   #             "
      expectObservable(published).toBe(expected, undefined, error)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should be referentially-transparent", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source1 = cold("-1-2-3-4-5-|")
        const source1Subs = " ^----------!"
        const expected1 = "   -1-2-3-4-5-|"
        const source2 = cold("-6-7-8-9-0-|")
        const source2Subs = " ^----------!"
        const expected2 = "   -6-7-8-9-0-|"
        // Calls to the _operator_ must be referentially-transparent.
        const partialPipeLine = pipe(publishReplay(1))
        // The non-referentially-transparent publishing occurs within the _operator function_
        // returned by the _operator_ and that happens when the complete pipeline is composed.
        const published1 = source1.pipe(
          partialPipeLine
        ) as ConnectableObservable<any>
        const published2 = source2.pipe(
          partialPipeLine
        ) as ConnectableObservable<any>
        expectObservable(published1).toBe(expected1)
        expectSubscriptions(source1.subscriptions).toBe(source1Subs)
        expectObservable(published2).toBe(expected2)
        expectSubscriptions(source2.subscriptions).toBe(source2Subs)
        published1.connect()
        published2.connect()
      }
    )
  })
})
import { expect } from "chai"
import * as sinon from "sinon"
import { EMPTY, NEVER, of, timer, defer, Observable, throwError } from "rxjs"
import { race, mergeMap, map, finalize, startWith } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {race} */
describe("race operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should race cold and cold", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---a-----b-----c----|   ")
      const e1subs = "  ^-------------------!   "
      const e2 = cold(" ------x-----y-----z----|")
      const e2subs = "  ^--!                    "
      const expected = "---a-----b-----c----|   "
      const result = e1.pipe(race(e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should race cold and cold and accept an Array of Observable argument", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---a-----b-----c----|   ")
      const e1subs = "  ^-------------------!   "
      const e2 = cold(" ------x-----y-----z----|")
      const e2subs = "  ^--!                    "
      const expected = "---a-----b-----c----|   "
      const result = e1.pipe(race([e2]))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should race hot and hot", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---a-----b-----c----|   ")
      const e1subs = "  ^-------------------!   "
      const e2 = hot("  ------x-----y-----z----|")
      const e2subs = "  ^--!                    "
      const expected = "---a-----b-----c----|   "
      const result = e1.pipe(race(e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should race hot and cold", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" ---a-----b-----c----|   ")
        const e1subs = "  ^-------------------!   "
        const e2 = hot("  ------x-----y-----z----|")
        const e2subs = "  ^--!                    "
        const expected = "---a-----b-----c----|   "
        const result = e1.pipe(race(e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should race 2nd and 1st", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ------x-----y-----z----|")
      const e1subs = "  ^--!                    "
      const e2 = cold(" ---a-----b-----c----|   ")
      const e2subs = "  ^-------------------!   "
      const expected = "---a-----b-----c----|   "
      const result = e1.pipe(race(e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should race emit and complete", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" -----|                  ")
        const e1subs = "  ^----!                  "
        const e2 = hot("  ------x-----y-----z----|")
        const e2subs = "  ^----!                  "
        const expected = "-----|                  "
        const result = e1.pipe(race(e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = cold("---a-----b-----c----|   ")
        const e1subs = " ^-----------!           "
        const e2 = hot(" ------x-----y-----z----|")
        const e2subs = "  ^--!                   "
        const expected = "---a-----b---          "
        const unsub = "   ------------!          "
        const result = e1.pipe(race(e2))
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should not break unsubscription chains when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--^--b--c---d-| ")
      const e1subs = "       ^--------!    "
      const e2 = hot("  ---e-^---f--g---h-|")
      const e2subs = "       ^--!    "
      const expected = "     ---b--c---    "
      const unsub = "        ---------!    "
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        race(e2),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should never emit when given non emitting sources", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---|")
      const e2 = cold(" ---|")
      const e1subs = "  ^--!"
      const expected = "---|"
      const source = e1.pipe(race(e2))
      expectObservable(source).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should throw when error occurs mid stream", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---a-----#              ")
      const e1subs = "  ^--------!              "
      const e2 = cold(" ------x-----y-----z----|")
      const e2subs = "  ^--!                    "
      const expected = "---a-----#              "
      const result = e1.pipe(race(e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should throw when error occurs before a winner is found", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---#                    ")
      const e1subs = "  ^--!                    "
      const e2 = cold(" ------x-----y-----z----|")
      const e2subs = "  ^--!                    "
      const expected = "---#                    "
      const result = e1.pipe(race(e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should allow observable emits immediately", done => {
    const e1 = of(true)
    const e2 = timer(200).pipe(map(_ => false))
    e1.pipe(race(e2)).subscribe({
      next: x => {
        expect(x).to.be.true
      },
      error: done,
      complete: done,
    })
  })
  it("should ignore latter observables if a former one emits immediately", () => {
    const onNext = sinon.spy()
    const onSubscribe = sinon.spy() as any
    const e1 = of("a") // Wins the race
    const e2 = defer(onSubscribe) // Should be ignored
    e1.pipe(race(e2)).subscribe(onNext)
    expect(onNext.calledWithExactly("a")).to.be.true
    expect(onSubscribe.called).to.be.false
  })
  it("should ignore latter observables if a former one completes immediately", () => {
    const onComplete = sinon.spy()
    const onSubscribe = sinon.spy() as any
    const e1 = EMPTY // Wins the race
    const e2 = defer(onSubscribe) // Should be ignored
    e1.pipe(race(e2)).subscribe({ complete: onComplete })
    expect(onComplete.calledWithExactly()).to.be.true
    expect(onSubscribe.called).to.be.false
  })
  it("should ignore latter observables if a former one errors immediately", () => {
    const onError = sinon.spy()
    const onSubscribe = sinon.spy() as any
    const e1 = throwError(() => "kaboom") // Wins the race
    const e2 = defer(onSubscribe) // Should be ignored
    e1.pipe(race(e2)).subscribe({ error: onError })
    expect(onError.calledWithExactly("kaboom")).to.be.true
    expect(onSubscribe.called).to.be.false
  })
  it("should unsubscribe former observables if a latter one emits immediately", () => {
    const onNext = sinon.spy()
    const onUnsubscribe = sinon.spy()
    const e1 = NEVER.pipe(finalize(onUnsubscribe)) // Should be unsubscribed
    const e2 = of("b") // Wins the race
    e1.pipe(race(e2)).subscribe(onNext)
    expect(onNext.calledWithExactly("b")).to.be.true
    expect(onUnsubscribe.calledOnce).to.be.true
  })
  it("should unsubscribe from immediately emitting observable on unsubscription", () => {
    const onNext = sinon.spy()
    const onUnsubscribe = sinon.spy()
    const e1 = <Observable<never>>(
      NEVER.pipe(startWith("a"), finalize(onUnsubscribe))
    ) // Wins the race
    const e2 = NEVER // Loses the race
    const subscription = e1.pipe(race(e2)).subscribe(onNext)
    expect(onNext.calledWithExactly("a")).to.be.true
    expect(onUnsubscribe.called).to.be.false
    subscription.unsubscribe()
    expect(onUnsubscribe.calledOnce).to.be.true
  })
})
import { expect } from "chai"
import * as sinon from "sinon"
import { EMPTY, NEVER, of, timer, defer, Observable, throwError } from "rxjs"
import {
  raceWith,
  mergeMap,
  map,
  finalize,
  startWith,
  take,
} from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {raceWith} */
describe("raceWith operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should race cold and cold", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---a-----b-----c----|   ")
      const e1subs = "  ^-------------------!   "
      const e2 = cold(" ------x-----y-----z----|")
      const e2subs = "  ^--!                    "
      const expected = "---a-----b-----c----|   "
      const result = e1.pipe(raceWith(e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should race hot and hot", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---a-----b-----c----|   ")
      const e1subs = "  ^-------------------!   "
      const e2 = hot("  ------x-----y-----z----|")
      const e2subs = "  ^--!                    "
      const expected = "---a-----b-----c----|   "
      const result = e1.pipe(raceWith(e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should race hot and cold", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" ---a-----b-----c----|   ")
        const e1subs = "  ^-------------------!   "
        const e2 = hot("  ------x-----y-----z----|")
        const e2subs = "  ^--!                    "
        const expected = "---a-----b-----c----|   "
        const result = e1.pipe(raceWith(e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should race 2nd and 1st", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ------x-----y-----z----|")
      const e1subs = "  ^--!                    "
      const e2 = cold(" ---a-----b-----c----|   ")
      const e2subs = "  ^-------------------!   "
      const expected = "---a-----b-----c----|   "
      const result = e1.pipe(raceWith(e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should race emit and complete", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" -----|                  ")
        const e1subs = "  ^----!                  "
        const e2 = hot("  ------x-----y-----z----|")
        const e2subs = "  ^----!                  "
        const expected = "-----|                  "
        const result = e1.pipe(raceWith(e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" ---a-----b-----c----|   ")
        const e1subs = "  ^-----------!           "
        const e2 = hot("  ------x-----y-----z----|")
        const e2subs = "  ^--!                    "
        const expected = "---a-----b---           "
        const unsub = "   ------------!           "
        const result = e1.pipe(raceWith(e2))
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should not break unsubscription chains when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--^--b--c---d-| ")
      const e1subs = "       ^--------!    "
      const e2 = hot("  ---e-^---f--g---h-|")
      const e2subs = "       ^--!          "
      const expected = "     ---b--c---    "
      const unsub = "        ---------!    "
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        raceWith(e2),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should never emit when given non emitting sources", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---|")
      const e2 = cold(" ---|")
      const e1subs = "  ^--!"
      const expected = "---|"
      const source = e1.pipe(raceWith(e2))
      expectObservable(source).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should throw when error occurs mid stream", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---a-----#              ")
      const e1subs = "  ^--------!              "
      const e2 = cold(" ------x-----y-----z----|")
      const e2subs = "  ^--!                    "
      const expected = "---a-----#              "
      const result = e1.pipe(raceWith(e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should throw when error occurs before a winner is found", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---#                    ")
      const e1subs = "  ^--!                    "
      const e2 = cold(" ------x-----y-----z----|")
      const e2subs = "  ^--!                    "
      const expected = "---#                    "
      const result = e1.pipe(raceWith(e2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should allow observable emits immediately", done => {
    const e1 = of(true)
    const e2 = timer(200).pipe(map(_ => false))
    e1.pipe(raceWith(e2)).subscribe({
      next: x => {
        expect(x).to.be.true
      },
      error: done,
      complete: done,
    })
  })
  it("should ignore latter observables if a former one emits immediately", () => {
    const onNext = sinon.spy()
    const onSubscribe = sinon.spy() as any
    const e1 = of("a") // Wins the race
    const e2 = defer(onSubscribe) // Should be ignored
    e1.pipe(raceWith(e2)).subscribe(onNext)
    expect(onNext.calledWithExactly("a")).to.be.true
    expect(onSubscribe.called).to.be.false
  })
  it("should ignore latter observables if a former one completes immediately", () => {
    const onComplete = sinon.spy()
    const onSubscribe = sinon.spy() as any
    const e1 = EMPTY // Wins the race
    const e2 = defer(onSubscribe) // Should be ignored
    e1.pipe(raceWith(e2)).subscribe({ complete: onComplete })
    expect(onComplete.calledWithExactly()).to.be.true
    expect(onSubscribe.called).to.be.false
  })
  it("should ignore latter observables if a former one errors immediately", () => {
    const onError = sinon.spy()
    const onSubscribe = sinon.spy() as any
    const e1 = throwError(() => "kaboom") // Wins the race
    const e2 = defer(onSubscribe) // Should be ignored
    e1.pipe(raceWith(e2)).subscribe({ error: onError })
    expect(onError.calledWithExactly("kaboom")).to.be.true
    expect(onSubscribe.called).to.be.false
  })
  it("should unsubscribe former observables if a latter one emits immediately", () => {
    const onNext = sinon.spy()
    const onUnsubscribe = sinon.spy()
    const e1 = NEVER.pipe(finalize(onUnsubscribe)) // Should be unsubscribed
    const e2 = of("b") // Wins the race
    e1.pipe(raceWith(e2)).subscribe(onNext)
    expect(onNext.calledWithExactly("b")).to.be.true
    expect(onUnsubscribe.calledOnce).to.be.true
  })
  it("should unsubscribe from immediately emitting observable on unsubscription", () => {
    const onNext = sinon.spy()
    const onUnsubscribe = sinon.spy()
    const e1 = <Observable<never>>(
      NEVER.pipe(startWith("a"), finalize(onUnsubscribe))
    ) // Wins the race
    const e2 = NEVER // Loses the race
    const subscription = e1.pipe(raceWith(e2)).subscribe(onNext)
    expect(onNext.calledWithExactly("a")).to.be.true
    expect(onUnsubscribe.called).to.be.false
    subscription.unsubscribe()
    expect(onUnsubscribe.calledOnce).to.be.true
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(raceWith(of(0)), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { TestScheduler } from "rxjs/testing"
import { reduce, mergeMap } from "rxjs/operators"
import { range, of } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {reduce} */
describe("reduce", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should reduce", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values = { a: 1, b: 3, c: 5, x: 9 }
      const e1 = hot("  --a--b--c--|   ", values)
      const e1subs = "  ^----------!   "
      const expected = "-----------(x|)"
      const result = e1.pipe(reduce((o, x) => o + x, 0))
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should reduce with seed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--|   ")
      const e1subs = "  ^-------!   "
      const expected = "--------(x|)"
      const result = e1.pipe(reduce((o, x) => o + " " + x, "n"))
      expectObservable(result).toBe(expected, { x: "n a b" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should reduce with a seed of undefined", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--e--f--g--|   ")
      const e1subs = "     ^--------------------!   "
      const expected = "   ---------------------(x|)"
      const result = e1.pipe(
        reduce((o: string | undefined, x) => o + " " + x, undefined)
      )
      expectObservable(result).toBe(expected, { x: "undefined b c d e f g" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should reduce without a seed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--e--f--g--|   ")
      const e1subs = "     ^--------------------!   "
      const expected = "   ---------------------(x|)"
      const result = e1.pipe(reduce((o, x) => o + " " + x))
      expectObservable(result).toBe(expected, { x: "b c d e f g" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should reduce with index without seed", () => {
    const idx = [1, 2, 3, 4, 5]
    range(0, 6)
      .pipe(
        reduce((acc, value, index) => {
          expect(idx.shift()).to.equal(index)
          return value
        })
      )
      .subscribe({
        complete() {
          expect(idx).to.be.empty
        },
      })
  })
  it("should reduce with index with seed", () => {
    const idx = [0, 1, 2, 3, 4, 5]
    range(0, 6)
      .pipe(
        reduce((acc, value, index) => {
          expect(idx.shift()).to.equal(index)
          return value
        }, -1)
      )
      .subscribe({
        complete() {
          expect(idx).to.be.empty
        },
      })
  })
  it("should reduce with seed if source is empty", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^-------|   ")
      const e1subs = "     ^-------!   "
      const expected = "   --------(x|)"
      const result = e1.pipe(reduce((o, x) => o + x, "42"))
      expectObservable(result).toBe(expected, { x: "42" })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if reduce function throws without seed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--|")
      const e1subs = "  ^----!   "
      const expected = "-----#   "
      const result = e1.pipe(
        reduce(() => {
          throw "error"
        })
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--|")
      const e1subs = "  ^-----!  "
      const expected = "-------  "
      const unsub = "   ------!  "
      const result = e1.pipe(reduce((o, x) => o + x))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--|")
      const e1subs = "  ^-----!  "
      const expected = "-------  "
      const unsub = "   ------!  "
      const result = e1.pipe(
        mergeMap(x => of(x)),
        reduce((o, x) => o + x),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if source emits and raises error with seed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--#")
      const e1subs = "  ^-------!"
      const expected = "--------#"
      const result = e1.pipe(reduce((o, x) => o + x, "42"))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if source raises error with seed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----#")
      const e1subs = "  ^---!"
      const expected = "----#"
      const result = e1.pipe(reduce((o, x) => o + x, "42"))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if reduce function throws with seed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--|")
      const e1subs = "  ^-!      "
      const expected = "--#      "
      const result = e1.pipe(
        reduce(() => {
          throw "error"
        }, "n")
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not complete with seed if source emits but does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--")
      const e1subs = "  ^----"
      const expected = "-----"
      const result = e1.pipe(reduce((o, x) => o + x, "n"))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not complete with seed if source never completes", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      const result = e1.pipe(reduce((o, x) => o + x, "n"))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not complete without seed if source emits but does not completes", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--")
      const e1subs = "  ^-------"
      const expected = "--------"
      const result = e1.pipe(reduce((o, x) => o + x))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not complete without seed if source never completes", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      const result = e1.pipe(reduce((o, x) => o + x))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should reduce if source does not emit without seed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^-------|")
      const e1subs = "     ^-------!"
      const expected = "   --------|"
      const result = e1.pipe(reduce((o, x) => o + x))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if source emits and raises error without seed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--#")
      const e1subs = "  ^-------!"
      const expected = "--------#"
      const result = e1.pipe(reduce((o, x) => o + x))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if source raises error without seed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----#")
      const e1subs = "  ^---!"
      const expected = "----#"
      const result = e1.pipe(reduce((o, x) => o + x))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
})
import { expect } from "chai"
import { TestScheduler } from "rxjs/testing"
import { refCount, publish, publishReplay, first } from "rxjs/operators"
import { NEVER, noop, Observable, Subject } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {refCount} */
describe("refCount", () => {
  it("should turn a multicasted Observable an automatically (dis)connecting hot one", () => {
    const testScheduler = new TestScheduler(observableMatcher)
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --1-2---3-4--5-|")
      const e1Subs = "  ^--------------!"
      const expected = "--1-2---3-4--5-|"
      const result = e1.pipe(publish(), refCount())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1Subs)
    })
  })
  it("should count references", () => {
    const connectable = NEVER.pipe(publish())
    const refCounted = connectable.pipe(refCount())
    const sub1 = refCounted.subscribe({
      next: noop,
    })
    const sub2 = refCounted.subscribe({
      next: noop,
    })
    const sub3 = refCounted.subscribe({
      next: noop,
    })
    expect((connectable as any)._refCount).to.equal(3)
    sub1.unsubscribe()
    sub2.unsubscribe()
    sub3.unsubscribe()
  })
  it("should unsub from the source when all other subscriptions are unsubbed", done => {
    let unsubscribeCalled = false
    const connectable = new Observable<boolean>(observer => {
      observer.next(true)
      return () => {
        unsubscribeCalled = true
      }
    }).pipe(publish())
    const refCounted = connectable.pipe(refCount())
    const sub1 = refCounted.subscribe(() => {
      //noop
    })
    const sub2 = refCounted.subscribe(() => {
      //noop
    })
    const sub3 = refCounted.subscribe(() => {
      expect((connectable as any)._refCount).to.equal(1)
    })
    sub1.unsubscribe()
    sub2.unsubscribe()
    sub3.unsubscribe()
    expect((connectable as any)._refCount).to.equal(0)
    expect(unsubscribeCalled).to.be.true
    done()
  })
  it("should not unsubscribe when a subscriber synchronously unsubscribes if other subscribers are present", () => {
    let unsubscribeCalled = false
    const connectable = new Observable<boolean>(observer => {
      observer.next(true)
      return () => {
        unsubscribeCalled = true
      }
    }).pipe(publishReplay(1))
    const refCounted = connectable.pipe(refCount())
    refCounted.subscribe()
    refCounted.subscribe().unsubscribe()
    expect((connectable as any)._refCount).to.equal(1)
    expect(unsubscribeCalled).to.be.false
  })
  it("should not unsubscribe when a subscriber synchronously unsubscribes if other subscribers are present and the source is a Subject", () => {
    const arr: string[] = []
    const subject = new Subject<string>()
    const connectable = subject.pipe(publishReplay(1))
    const refCounted = connectable.pipe(refCount())
    refCounted.subscribe(val => {
      arr.push(val)
    })
    subject.next("the number one")
    refCounted.pipe(first()).subscribe().unsubscribe()
    subject.next("the number two")
    expect((connectable as any)._refCount).to.equal(1)
    expect(arr[0]).to.equal("the number one")
    expect(arr[1]).to.equal("the number two")
  })
})
import { expect } from "chai"
import {
  repeat,
  mergeMap,
  map,
  multicast,
  refCount,
  take,
} from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of, Subject, Observable, timer } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {repeat} */
describe("repeat operator", () => {
  let rxTest: TestScheduler
  beforeEach(() => {
    rxTest = new TestScheduler(observableMatcher)
  })
  it("should resubscribe count number of times", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a--b--|                ")
      const subs = [
        "               ^-------!                ", //
        "               --------^-------!        ",
        "               ----------------^-------!",
      ]
      const expected = "--a--b----a--b----a--b--|"
      expectObservable(e1.pipe(repeat(3))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should resubscribe multiple times", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a--b--|                        ")
      const subs = [
        "               ^-------!                        ",
        "               --------^-------!                ",
        "               ----------------^-------!        ",
        "               ------------------------^-------!",
      ]
      const expected = "--a--b----a--b----a--b----a--b--|"
      expectObservable(e1.pipe(repeat(2), repeat(2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should complete without emit when count is zero", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("--a--b--|")
      const subs: string[] = []
      const expected = "|"
      expectObservable(e1.pipe(repeat(0))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should emit source once when count is one", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a--b--|")
      const subs = "    ^-------!"
      const expected = "--a--b--|"
      expectObservable(e1.pipe(repeat(1))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should repeat until gets unsubscribed", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a--b--|      ")
      const subs = [
        "               ^-------!      ", //
        "               --------^------!",
      ]
      const unsub = "   ---------------!"
      const expected = "--a--b----a--b-"
      expectObservable(e1.pipe(repeat(10)), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should be able to repeat indefinitely until unsubscribed", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a--b--|                                    ")
      const subs = [
        "               ^-------!                                    ",
        "               --------^-------!                            ",
        "               ----------------^-------!                    ",
        "               ------------------------^-------!            ",
        "               --------------------------------^-------!    ",
        "               ----------------------------------------^---!",
      ]
      const unsub = "   --------------------------------------------!"
      const expected = "--a--b----a--b----a--b----a--b----a--b----a--"
      expectObservable(e1.pipe(repeat()), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should not break unsubscription chain when unsubscribed explicitly", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a--b--|                                    ")
      const subs = [
        "               ^-------!                                    ",
        "               --------^-------!                            ",
        "               ----------------^-------!                    ",
        "               ------------------------^-------!            ",
        "               --------------------------------^-------!    ",
        "               ----------------------------------------^---!",
      ]
      const unsub = "   --------------------------------------------!"
      const expected = "--a--b----a--b----a--b----a--b----a--b----a--"
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        repeat(),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should consider negative count as no repeat, and return EMPTY", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("--a--b--|                                    ")
      const expected = "|"
      expectObservable(e1.pipe(repeat(-1))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe([])
    })
  })
  it("should always finalization before starting the next cycle", async () => {
    const results: any[] = []
    const source = new Observable<number>(subscriber => {
      Promise.resolve().then(() => {
        subscriber.next(1)
        Promise.resolve().then(() => {
          subscriber.next(2)
          Promise.resolve().then(() => {
            subscriber.complete()
          })
        })
      })
      return () => {
        results.push("finalizer")
      }
    })
    await source.pipe(repeat(3)).forEach(value => results.push(value))
    expect(results).to.deep.equal([
      1,
      2,
      "finalizer",
      1,
      2,
      "finalizer",
      1,
      2,
      "finalizer",
    ])
  })
  it("should always finalize before starting the next cycle, even when synchronous", () => {
    const results: any[] = []
    const source = new Observable<number>(subscriber => {
      subscriber.next(1)
      subscriber.next(2)
      subscriber.complete()
      return () => {
        results.push("finalizer")
      }
    })
    const subscription = source.pipe(repeat(3)).subscribe({
      next: value => results.push(value),
      complete: () => results.push("complete"),
    })
    expect(subscription.closed).to.be.true
    expect(results).to.deep.equal([
      1,
      2,
      "finalizer",
      1,
      2,
      "finalizer",
      1,
      2,
      "complete",
      "finalizer",
    ])
  })
  it("should not complete when source never completes", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("-")
      const e1subs = "^"
      const expected = "-"
      expectObservable(e1.pipe(repeat(3))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not complete when source does not completes", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("-")
      const unsub = "------------------------------!"
      const subs = " ^-----------------------------!"
      const expected = "-"
      expectObservable(e1.pipe(repeat(3)), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should complete immediately when source does not complete without emit but count is zero", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("-")
      const subs: string[] = []
      const expected = "|"
      expectObservable(e1.pipe(repeat(0))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should complete immediately when source does not complete but count is zero", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("--a--b--")
      const subs: string[] = []
      const expected = "|"
      expectObservable(e1.pipe(repeat(0))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should emit source once and does not complete when source emits but does not complete", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a--b--")
      const subs = ["   ^-------"]
      const expected = "--a--b--"
      expectObservable(e1.pipe(repeat(3))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should complete when source is empty", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("|")
      const e1subs = ["(^!)", "(^!)", "(^!)"]
      const expected = "|"
      expectObservable(e1.pipe(repeat(3))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should complete when source does not emit", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("----|        ")
      const subs = [
        "              ^---!        ", //
        "              ----^---!    ",
        "              --------^---!",
      ]
      const expected = "------------|"
      expectObservable(e1.pipe(repeat(3))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should complete immediately when source does not emit but count is zero", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("----|")
      const subs: string[] = []
      const expected = "|"
      expectObservable(e1.pipe(repeat(0))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should raise error when source raises error", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a--b--#")
      const subs = "    ^-------!"
      const expected = "--a--b--#"
      expectObservable(e1.pipe(repeat(2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should raises error if source throws", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("#")
      const e1subs = "(^!)"
      const expected = "#"
      expectObservable(e1.pipe(repeat(3))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raises error if source throws when repeating infinitely", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("#")
      const e1subs = "(^!)"
      const expected = "#"
      expectObservable(e1.pipe(repeat())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error after first emit succeed", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      let repeated = false
      const e1 = cold("--a--|").pipe(
        map((x: string) => {
          if (repeated) {
            throw "error"
          } else {
            repeated = true
            return x
          }
        })
      )
      const expected = "--a----#"
      expectObservable(e1.pipe(repeat(2))).toBe(expected)
    })
  })
  it("should repeat a synchronous source (multicasted and refCounted) multiple times", done => {
    const expected = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
    of(1, 2, 3)
      .pipe(
        multicast(() => new Subject<number>()),
        refCount(),
        repeat(5)
      )
      .subscribe({
        next: (x: number) => {
          expect(x).to.equal(expected.shift())
        },
        error: x => {
          done(new Error("should not be called"))
        },
        complete: () => {
          expect(expected.length).to.equal(0)
          done()
        },
      })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(repeat(), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
  it("should allow count configuration", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a--b--|                ")
      const subs = [
        "               ^-------!                ", //
        "               --------^-------!        ",
        "               ----------------^-------!",
      ]
      const expected = "--a--b----a--b----a--b--|"
      expectObservable(e1.pipe(repeat({ count: 3 }))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should allow delay time configuration", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a--b--|                ")
      const delay = 3 //       ---|       ---|
      const subs = [
        "               ^-------!                ", //
        "               -----------^-------!        ",
        "               ----------------------^-------!",
      ]
      const expected = "--a--b-------a--b-------a--b--|"
      expectObservable(e1.pipe(repeat({ count: 3, delay }))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should allow delay function configuration", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const expectedCounts = [1, 2, 3]
      const e1 = cold(" --a--b--|                ")
      const delay = 3 //       ---|       ---|
      const subs = [
        "               ^-------!                ", //
        "               -----------^-------!        ",
        "               ----------------------^-------!",
      ]
      const expected = "--a--b-------a--b-------a--b--|"
      expectObservable(
        e1.pipe(
          repeat({
            count: 3,
            delay: count => {
              expect(count).to.equal(expectedCounts.shift())
              return timer(delay)
            },
          })
        )
      ).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should handle delay function throwing", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const expectedCounts = [1, 2, 3]
      const e1 = cold(" --a--b--|                ")
      const delay = 3 //       ---|       ---|
      const subs = [
        "               ^-------!                ", //
        "               -----------^-------!        ",
      ]
      const expected = "--a--b-------a--b--#"
      expectObservable(
        e1.pipe(
          repeat({
            count: 3,
            delay: count => {
              if (count === 2) {
                throw "bad"
              }
              return timer(delay)
            },
          })
        )
      ).toBe(expected, undefined, "bad")
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
})
import { expect } from "chai"
import {
  repeatWhen,
  map,
  mergeMap,
  takeUntil,
  takeWhile,
  take,
} from "rxjs/operators"
import { of, EMPTY, Observable, Subscriber } from "rxjs"
import { SafeSubscriber } from "rxjs/internal/Subscriber"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {repeatWhen} */
describe("repeatWhen operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should handle a source with eventual complete using a hot notifier", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("-1--2--|")
        //                                 -1--2--|
        //                                              -1--2--|
        const subs = [
          "                  ^------!                          ",
          "                  -------------^------!             ",
          "                  --------------------------^------!",
        ]
        const notifier = hot("-------------r------------r-|    ")
        const expected = "    -1--2---------1--2---------1--2--|"
        const result = source.pipe(repeatWhen((notifications: any) => notifier))
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  it("should handle a source with eventual complete using a hot notifier that raises error", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold(" -1--2--|")
        const subs = [
          "                   ^------!                      ",
          "                   -----------^------!           ",
          "                   -------------------^------!   ",
        ]
        const notifier = hot("-----------r-------r---------#")
        const expected = "    -1--2-------1--2----1--2-----#"
        const result = source.pipe(repeatWhen((notifications: any) => notifier))
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  it("should repeat when notified via returned notifier on complete", done => {
    let retried = false
    const expected = [1, 2, 1, 2]
    let i = 0
    try {
      of(1, 2)
        .pipe(
          map((n: number) => {
            return n
          }),
          repeatWhen((notifications: any) =>
            notifications.pipe(
              map((x: any) => {
                if (retried) {
                  throw new Error("done")
                }
                retried = true
                return x
              })
            )
          )
        )
        .subscribe({
          next: (x: any) => {
            expect(x).to.equal(expected[i++])
          },
          error: (err: any) => {
            expect(err).to.be.an("error", "done")
            done()
          },
        })
    } catch (err) {
      done(err)
    }
  })
  it("should not repeat when applying an empty notifier", done => {
    const expected = [1, 2]
    const nexted: number[] = []
    of(1, 2)
      .pipe(
        map((n: number) => {
          return n
        }),
        repeatWhen((notifications: any) => EMPTY)
      )
      .subscribe({
        next: (n: number) => {
          expect(n).to.equal(expected.shift())
          nexted.push(n)
        },
        error: (err: any) => {
          done(new Error("should not be called"))
        },
        complete: () => {
          expect(nexted).to.deep.equal([1, 2])
          done()
        },
      })
  })
  it("should not error when applying an empty synchronous notifier", () => {
    const errors: any[] = []
    // The current Subscriber.prototype.error implementation does nothing for
    // stopped subscribers. This test was written to fail and expose a problem
    // with synchronous notifiers. However, by the time the error occurs the
    // subscriber is stopped, so the test logs errors by both patching the
    // prototype and by using an error callback (for when/if the do-nothing-if-
    // stopped behaviour is fixed).
    const originalSubscribe = Observable.prototype.subscribe
    Observable.prototype.subscribe = function (...args: any[]): any {
      let [subscriber] = args
      if (!(subscriber instanceof Subscriber)) {
        subscriber = new SafeSubscriber(...args)
      }
      subscriber.error = function (err: any): void {
        errors.push(err)
        Subscriber.prototype.error.call(this, err)
      }
      return originalSubscribe.call(this, subscriber)
    }
    of(1, 2)
      .pipe(repeatWhen((notifications: any) => EMPTY))
      .subscribe({ error: err => errors.push(err) })
    Observable.prototype.subscribe = originalSubscribe
    expect(errors).to.deep.equal([])
  })
  it("should not error when applying a non-empty synchronous notifier", () => {
    const errors: any[] = []
    // The current Subscriber.prototype.error implementation does nothing for
    // stopped subscribers. This test was written to fail and expose a problem
    // with synchronous notifiers. However, by the time the error occurs the
    // subscriber is stopped, so the test logs errors by both patching the
    // prototype and by using an error callback (for when/if the do-nothing-if-
    // stopped behaviour is fixed).
    const originalSubscribe = Observable.prototype.subscribe
    Observable.prototype.subscribe = function (...args: any[]): any {
      let [subscriber] = args
      if (!(subscriber instanceof Subscriber)) {
        subscriber = new SafeSubscriber(...args)
      }
      subscriber.error = function (err: any): void {
        errors.push(err)
        Subscriber.prototype.error.call(this, err)
      }
      return originalSubscribe.call(this, subscriber)
    }
    of(1, 2)
      .pipe(repeatWhen((notifications: any) => of(1)))
      .subscribe({ error: err => errors.push(err) })
    Observable.prototype.subscribe = originalSubscribe
    expect(errors).to.deep.equal([])
  })
  it("should apply an empty notifier on an empty source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  |   ")
      const subs = "         (^!)"
      const notifier = cold("|   ")
      const expected = "     |   "
      const result = source.pipe(repeatWhen((notifications: any) => notifier))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should apply a never notifier on an empty source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  |   ")
      const subs = "         (^!)"
      const notifier = cold("-   ")
      const expected = "     -   "
      const result = source.pipe(repeatWhen((notifications: any) => notifier))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should apply an empty notifier on a never source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  -                                         ")
      const unsub = "        -----------------------------------------!"
      const subs = "         ^----------------------------------------!"
      const notifier = cold("|                                         ")
      const expected = "     -                                         "
      const result = source.pipe(repeatWhen((notifications: any) => notifier))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should apply a never notifier on a never source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  -                                         ")
      const unsub = "        -----------------------------------------!"
      const subs = "         ^----------------------------------------!"
      const notifier = cold("-                                        ")
      const expected = "     -                                        "
      const result = source.pipe(repeatWhen((notifications: any) => notifier))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should return an empty observable given a just-throw source and empty notifier", () => {
    testScheduler.run(({ cold, expectObservable }) => {
      const source = cold("  #")
      const notifier = cold("|")
      const expected = "     #"
      const result = source.pipe(repeatWhen((notifications: any) => notifier))
      expectObservable(result).toBe(expected)
    })
  })
  it("should return a error observable given a just-throw source and never notifier", () => {
    testScheduler.run(({ cold, expectObservable }) => {
      const source = cold("  #")
      const notifier = cold("-")
      const expected = "     #"
      const result = source.pipe(repeatWhen((notifications: any) => notifier))
      expectObservable(result).toBe(expected)
    })
  })
  it("should return a never-ending result if the notifier is never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  --a--b--c--|                              ")
      const subs = "         ^----------!                              "
      const notifier = cold("           -                              ")
      const expected = "     --a--b--c---------------------------------"
      const result = source.pipe(repeatWhen((notifications: any) => notifier))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should propagate error thrown from notifierSelector function", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--a--b--c--|")
      const subs = "       ^----------!"
      const expected = "   --a--b--c--#"
      const result = source.pipe(
        repeatWhen(<any>(() => {
          throw "bad!"
        }))
      )
      expectObservable(result).toBe(expected, undefined, "bad!")
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should complete if the notifier only completes", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  --a--b--c--|")
      const subs = "         ^----------!"
      const notifier = cold("           |")
      const expected = "     --a--b--c--|"
      const result = source.pipe(repeatWhen((notifications: any) => notifier))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should mirror a basic cold source with complete, given a never notifier", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  --a--b--c--|")
      const subs = "         ^----------!"
      const notifier = cold("           |")
      const expected = "     --a--b--c--|"
      const result = source.pipe(repeatWhen((notifications: any) => notifier))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should mirror a basic cold source with no termination, given a never notifier", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  --a--b--c---")
      const subs = "         ^-----------"
      const notifier = cold("           |")
      const expected = "     --a--b--c---"
      const result = source.pipe(repeatWhen((notifications: any) => notifier))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should mirror a basic hot source with complete, given a never notifier", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = hot("-a-^--b--c--|")
        const subs = "         ^--------!"
        const notifier = cold("         |")
        const expected = "     ---b--c--|"
        const result = source.pipe(repeatWhen((notifications: any) => notifier))
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  // https://github.com/ReactiveX/rxjs/issues/6523
  it.skip("should handle a host source that completes via operator like take, and a hot notifier", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("  -1--2--3----4--5---|")
      // prettier-ignore
      const ssubs = [
        '                   ^------!            ',
        '                   -------------^----! '
      ];
      const notifier = hot("--------------r--------r---r--r--r---|")
      const nsubs = "       -------^-----------!"
      const expected = "    -1--2----------5---|"
      const result = source.pipe(
        takeWhile(value => value !== "3"),
        repeatWhen(() => notifier)
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(ssubs)
      expectSubscriptions(notifier.subscriptions).toBe(nsubs)
    })
  })
  it("should tear down resources when result is unsubscribed early", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold(" -1--2--|")
        const unsub = "       --------------------!       "
        const subs = [
          "                   ^------!                    ",
          "                   ---------^------!           ",
          "                   -----------------^--!       ",
        ]
        const notifier = hot("---------r-------r---------#")
        const nsubs = "       -------^------------!       "
        const expected = "    -1--2-----1--2----1--       "
        const result = source.pipe(repeatWhen((notifications: any) => notifier))
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(subs)
        expectSubscriptions(notifier.subscriptions).toBe(nsubs)
      }
    )
  })
  it("should not break unsubscription chains when unsubscribed explicitly", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold(" -1--2--|")
        const subs = [
          "                   ^------!                    ",
          "                   ---------^------!           ",
          "                   -----------------^--!       ",
        ]
        const notifier = hot("---------r-------r-------r-#")
        const nsubs = "       -------^------------!       "
        const expected = "    -1--2-----1--2----1--       "
        const unsub = "       --------------------!       "
        const result = source.pipe(
          mergeMap((x: string) => of(x)),
          repeatWhen((notifications: any) => notifier),
          mergeMap((x: string) => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(subs)
        expectSubscriptions(notifier.subscriptions).toBe(nsubs)
      }
    )
  })
  it("should handle a source with eventual error using a dynamic notifier selector which eventually throws", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("-1--2--|")
      const subs = [
        "                  ^------!              ",
        "                  -------^------!       ",
        "                  --------------^------!",
      ]
      const expected = "   -1--2---1--2---1--2--#"
      let invoked = 0
      const result = source.pipe(
        repeatWhen((notifications: any) =>
          notifications.pipe(
            map((err: any) => {
              if (++invoked === 3) {
                throw "error"
              } else {
                return "x"
              }
            })
          )
        )
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should handle a source with eventual error using a dynamic notifier selector which eventually completes", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("-1--2--|")
      const subs = [
        "                  ^------!              ",
        "                  -------^------!       ",
        "                  --------------^------!",
      ]
      const expected = "   -1--2---1--2---1--2--|"
      let invoked = 0
      const result = source.pipe(
        repeatWhen((notifications: any) =>
          notifications.pipe(
            map(() => "x"),
            takeUntil(
              notifications.pipe(
                mergeMap(() => {
                  if (++invoked < 3) {
                    return EMPTY
                  } else {
                    return of("stop!")
                  }
                })
              )
            )
          )
        )
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should always finalize before starting the next cycle, even when synchronous", () => {
    const results: any[] = []
    const source = new Observable<number>(subscriber => {
      subscriber.next(1)
      subscriber.next(2)
      subscriber.complete()
      return () => {
        results.push("finalizer")
      }
    })
    const subscription = source
      .pipe(
        repeatWhen(completions$ =>
          completions$.pipe(takeWhile((_, i) => i < 3))
        )
      )
      .subscribe({
        next: value => results.push(value),
        complete: () => results.push("complete"),
      })
    expect(subscription.closed).to.be.true
    expect(results).to.deep.equal([
      1,
      2,
      "finalizer",
      1,
      2,
      "finalizer",
      1,
      2,
      "finalizer",
      1,
      2,
      "complete",
      "finalizer",
    ])
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        repeatWhen(() => of(0)),
        take(3)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import {
  retry,
  map,
  take,
  mergeMap,
  concat,
  multicast,
  refCount,
} from "rxjs/operators"
import {
  Observable,
  Observer,
  defer,
  range,
  of,
  throwError,
  Subject,
  timer,
  EMPTY,
} from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {retry} */
describe("retry", () => {
  let rxTest: TestScheduler
  beforeEach(() => {
    rxTest = new TestScheduler(observableMatcher)
  })
  it("should handle a basic source that emits next then errors, count=3", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--1-2-3-#")
      const subs = [
        "                  ^-------!                ",
        "                  --------^-------!        ",
        "                  ----------------^-------!",
      ]
      const expected = "   --1-2-3---1-2-3---1-2-3-#"
      const result = source.pipe(retry(2))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should retry a number of times, without error, then complete", done => {
    let errors = 0
    const retries = 2
    new Observable((observer: Observer<number>) => {
      observer.next(42)
      observer.complete()
    })
      .pipe(
        map((x: any) => {
          if (++errors < retries) {
            throw "bad"
          }
          errors = 0
          return x
        }),
        retry(retries)
      )
      .subscribe({
        next(x: number) {
          expect(x).to.equal(42)
        },
        error() {
          expect("this was called").to.be.true
        },
        complete: done,
      })
  })
  it("should retry a number of times, then call error handler", done => {
    let errors = 0
    const retries = 2
    new Observable((observer: Observer<number>) => {
      observer.next(42)
      observer.complete()
    })
      .pipe(
        map(() => {
          errors += 1
          throw "bad"
        }),
        retry(retries - 1)
      )
      .subscribe({
        next() {
          done("shouldn't next")
        },
        error() {
          expect(errors).to.equal(2)
          done()
        },
        complete() {
          done("shouldn't complete")
        },
      })
  })
  it("should retry a number of times, then call error handler (with resetOnSuccess)", done => {
    let errors = 0
    const retries = 2
    new Observable((observer: Observer<number>) => {
      observer.next(42)
      observer.complete()
    })
      .pipe(
        map(() => {
          errors += 1
          throw "bad"
        }),
        retry({ count: retries - 1, resetOnSuccess: true })
      )
      .subscribe({
        next() {
          done("shouldn't next")
        },
        error() {
          expect(errors).to.equal(2)
          done()
        },
        complete() {
          done("shouldn't complete")
        },
      })
  })
  it("should retry a number of times, then call next handler without error, then retry and complete", done => {
    let index = 0
    let errors = 0
    const retries = 2
    defer(() => range(0, 4 - index))
      .pipe(
        mergeMap(() => {
          index++
          if (index === 1 || index === 3) {
            errors++
            return throwError(() => "bad")
          } else {
            return of(42)
          }
        }),
        retry({ count: retries - 1, resetOnSuccess: true })
      )
      .subscribe({
        next(x: number) {
          expect(x).to.equal(42)
        },
        error() {
          done("shouldn't error")
        },
        complete() {
          expect(errors).to.equal(retries)
          done()
        },
      })
  })
  it("should always finalize before starting the next cycle, even when synchronous", () => {
    const results: any[] = []
    const source = new Observable<number>(subscriber => {
      subscriber.next(1)
      subscriber.next(2)
      subscriber.error("bad")
      return () => {
        results.push("finalizer")
      }
    })
    const subscription = source.pipe(retry(3)).subscribe({
      next: value => results.push(value),
      error: err => results.push(err),
    })
    expect(subscription.closed).to.be.true
    expect(results).to.deep.equal([
      1,
      2,
      "finalizer",
      1,
      2,
      "finalizer",
      1,
      2,
      "finalizer",
      1,
      2,
      "bad",
      "finalizer",
    ])
  })
  it("should retry a number of times, then call next handler without error, then retry and error", done => {
    let index = 0
    let errors = 0
    const retries = 2
    defer(() => range(0, 4 - index))
      .pipe(
        mergeMap(() => {
          index++
          if (index === 1 || index === 3) {
            errors++
            return throwError(() => "bad")
          } else {
            return of(42)
          }
        }),
        retry({ count: retries - 1, resetOnSuccess: false })
      )
      .subscribe({
        next(x: number) {
          expect(x).to.equal(42)
        },
        error() {
          expect(errors).to.equal(retries)
          done()
        },
        complete() {
          done("shouldn't complete")
        },
      })
  })
  it("should retry until successful completion", done => {
    let errors = 0
    const retries = 10
    new Observable((observer: Observer<number>) => {
      observer.next(42)
      observer.complete()
    })
      .pipe(
        map((x: any) => {
          if (++errors < retries) {
            throw "bad"
          }
          errors = 0
          return x
        }),
        retry(),
        take(retries)
      )
      .subscribe({
        next(x: number) {
          expect(x).to.equal(42)
        },
        error() {
          expect("this was called").to.be.true
        },
        complete: done,
      })
  })
  it("should handle an empty source", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("|  ")
      const subs = "      (^!)"
      const expected = "   |  "
      const result = source.pipe(retry())
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should handle a never source", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("-")
      const subs = "       ^"
      const expected = "   -"
      const result = source.pipe(retry())
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should return a never observable given an async just-throw source and no count", () => {
    rxTest.run(({ cold, expectObservable }) => {
      const source = cold("-#                                    ") // important that it's not a sync error
      const unsub = "     -------------------------------------!"
      const expected = "  --------------------------------------"
      const result = source.pipe(retry())
      expectObservable(result, unsub).toBe(expected)
    })
  })
  it("should handle a basic source that emits next then completes", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--1--2--^--3--4--5---|")
      const subs = "              ^------------!"
      const expected = "          ---3--4--5---|"
      const result = source.pipe(retry())
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should handle a basic source that emits next but does not complete", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--1--2--^--3--4--5---")
      const subs = "              ^------------"
      const expected = "          ---3--4--5---"
      const result = source.pipe(retry())
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should handle a basic source that emits next then errors, no count", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--1-2-3-#                             ")
      //                           --1-2-3-#
      //                                   --1-2-3-#
      //                                           --1-2-3-#
      //                                                   --1-2-3-#
      const unsub = "      -------------------------------------!"
      const subs = [
        "                  ^-------!                             ",
        "                  --------^-------!                     ",
        "                  ----------------^-------!             ",
        "                  ------------------------^-------!     ",
        "                  --------------------------------^----!",
      ]
      const expected = "   --1-2-3---1-2-3---1-2-3---1-2-3---1-2-"
      const result = source.pipe(retry())
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should handle a source which eventually throws, count=3, and result is unsubscribed early", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--1-2-3-#     ")
      //                           --1-2-3-#
      const unsub = "      -------------!"
      // prettier-ignore
      const subs = [
        '                  ^-------!     ',
        '                  --------^----!',
      ];
      const expected = "   --1-2-3---1-2-"
      const result = source.pipe(retry(3))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should not break unsubscription chain when unsubscribed explicitly", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--1-2-3-#     ")
      //                           --1-2-3-#
      // prettier-ignore
      const subs = [
        '                  ^-------!     ',
        '                  --------^----!',
      ];
      const expected = "   --1-2-3---1-2-"
      const unsub = "      -------------!"
      const result = source.pipe(
        mergeMap((x: string) => of(x)),
        retry(100),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should retry a synchronous source (multicasted and refCounted) multiple times", done => {
    const expected = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
    of(1, 2, 3)
      .pipe(
        concat(throwError(() => "bad!")),
        multicast(() => new Subject<number>()),
        refCount(),
        retry(4)
      )
      .subscribe({
        next(x: number) {
          expect(x).to.equal(expected.shift())
        },
        error(err: any) {
          expect(err).to.equal("bad!")
          expect(expected.length).to.equal(0)
          done()
        },
        complete() {
          done(new Error("should not be called"))
        },
      })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(retry(1), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
  it("should not alter the source when the number of retries is smaller than 1", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--1-2-3-# ")
      const subs = ["      ^-------! "]
      const expected = "   --1-2-3-# "
      const unsub = "      ---------!"
      const result = source.pipe(retry(0))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  describe("with delay config", () => {
    describe("of a number", () => {
      it("should delay the retry by a specified amount of time", () => {
        rxTest.run(({ cold, time, expectSubscriptions, expectObservable }) => {
          const source = cold("---a---b---#")
          const t = time("                ----|")
          const subs = [
            //
            "                  ^----------!",
            "                  ---------------^----------!",
            "                  ------------------------------^----------!",
            "                  ---------------------------------------------^----!",
          ]
          const unsub =
            "      ^-------------------------------------------------!"
          const expected =
            "   ---a---b----------a---b----------a---b----------a--"
          const result = source.pipe(
            retry({
              delay: t,
            })
          )
          expectObservable(result, unsub).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(subs)
        })
      })
      it("should act like a normal retry if delay is set to 0", () => {
        rxTest.run(({ cold, expectSubscriptions, expectObservable }) => {
          const source = cold("---a---b---#")
          const subs = [
            //
            "                  ^----------!",
            "                  -----------^----------!",
            "                  ----------------------^----------!",
            "                  ---------------------------------^----!",
          ]
          const unsub = "      ^-------------------------------------!"
          const expected = "   ---a---b------a---b------a---b------a--"
          const result = source.pipe(
            retry({
              delay: 0,
            })
          )
          expectObservable(result, unsub).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(subs)
        })
      })
      it("should act like a normal retry if delay is less than 0", () => {
        rxTest.run(({ cold, expectSubscriptions, expectObservable }) => {
          const source = cold("---a---b---#")
          const subs = [
            //
            "                  ^----------!",
            "                  -----------^----------!",
            "                  ----------------------^----------!",
            "                  ---------------------------------^----!",
          ]
          const unsub = "      ^-------------------------------------!"
          const expected = "   ---a---b------a---b------a---b------a--"
          const result = source.pipe(
            retry({
              delay: -100,
            })
          )
          expectObservable(result, unsub).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(subs)
        })
      })
      it("should honor count as the max retries", () => {
        rxTest.run(({ cold, time, expectSubscriptions, expectObservable }) => {
          const source = cold("---a---b---#")
          const t = time("                ----|")
          const subs = [
            //
            "                  ^----------!",
            "                  ---------------^----------!",
            "                  ------------------------------^----------!",
          ]
          const expected = "   ---a---b----------a---b----------a---b---#"
          const result = source.pipe(
            retry({
              count: 2,
              delay: t,
            })
          )
          expectObservable(result).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(subs)
        })
      })
    })
    describe("of a function", () => {
      it("should delay the retry with a function that returns a notifier", () => {
        rxTest.run(({ cold, expectSubscriptions, expectObservable }) => {
          const source = cold("---a---b---#")
          const subs = [
            //
            "                  ^----------!",
            "                  ------------^----------!",
            "                  -------------------------^----------!",
            "                  ---------------------------------------^----!",
          ]
          const unsub = "      ^-------------------------------------------!"
          const expected = "   ---a---b-------a---b--------a---b---------a--"
          const result = source.pipe(
            retry({
              delay: (_err, retryCount) => {
                // retryCount will be 1, 2, 3, etc.
                return timer(retryCount)
              },
            })
          )
          expectObservable(result, unsub).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(subs)
        })
      })
      it("should delay the retry with a function that returns a hot observable", () => {
        rxTest.run(({ cold, hot, expectSubscriptions, expectObservable }) => {
          const source = cold(" ---a---b---#")
          const notifier = hot(
            "--------------x----------------x----------------x------"
          )
          const subs = [
            //
            "                   ^----------!",
            "                   --------------^----------!",
            "                   -------------------------------^----------!",
          ]
          const notifierSubs = [
            //
            "                   -----------^--!",
            "                   -------------------------^-----!",
            "                   ------------------------------------------^-!",
          ]
          const unsub = "       ^-------------------------------------------!"
          const expected = "    ---a---b---------a---b------------a---b------"
          const result = source.pipe(
            retry({
              delay: () => notifier,
            })
          )
          expectObservable(result, unsub).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(subs)
          expectSubscriptions(notifier.subscriptions).toBe(notifierSubs)
        })
      })
      it("should complete if the notifier completes", () => {
        rxTest.run(({ cold, expectSubscriptions, expectObservable }) => {
          const source = cold("---a---b---#")
          const subs = [
            //
            "                  ^----------!",
            "                  ------------^----------!",
            "                  -------------------------^----------!",
            "                  ------------------------------------!",
          ]
          const expected = "   ---a---b-------a---b--------a---b---|"
          const result = source.pipe(
            retry({
              delay: (_err, retryCount) => {
                return retryCount <= 2 ? timer(retryCount) : EMPTY
              },
            })
          )
          expectObservable(result).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(subs)
        })
      })
      it("should error if the notifier errors", () => {
        rxTest.run(({ cold, expectSubscriptions, expectObservable }) => {
          const source = cold("---a---b---#")
          const subs = [
            //
            "                  ^----------!",
            "                  ------------^----------!",
            "                  -------------------------^----------!",
            "                  ------------------------------------!",
          ]
          const expected = "   ---a---b-------a---b--------a---b---#"
          const result = source.pipe(
            retry({
              delay: (_err, retryCount) => {
                return retryCount <= 2
                  ? timer(retryCount)
                  : throwError(() => new Error("blah"))
              },
            })
          )
          expectObservable(result).toBe(expected, undefined, new Error("blah"))
          expectSubscriptions(source.subscriptions).toBe(subs)
        })
      })
      it("should error if the delay function throws", () => {
        rxTest.run(({ cold, expectSubscriptions, expectObservable }) => {
          const source = cold("---a---b---#")
          const subs = [
            //
            "                  ^----------!",
            "                  ------------^----------!",
            "                  -------------------------^----------!",
            "                  ------------------------------------!",
          ]
          const expected = "   ---a---b-------a---b--------a---b---#"
          const result = source.pipe(
            retry({
              delay: (_err, retryCount) => {
                if (retryCount <= 2) {
                  return timer(retryCount)
                } else {
                  throw new Error("blah")
                }
              },
            })
          )
          expectObservable(result).toBe(expected, undefined, new Error("blah"))
          expectSubscriptions(source.subscriptions).toBe(subs)
        })
      })
      it("should be usable for exponential backoff", () => {
        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
          const source = cold("---a---#")
          const subs = [
            //
            "                  ^------!",
            "                  ---------^------!",
            "                  --------------------^------!",
            "                  -----------------------------------^------!",
          ]
          const expected = "   ---a--------a----------a--------------a---#"
          const result = source.pipe(
            retry({
              count: 3,
              delay: (_err, retryCount) => timer(2 ** retryCount),
            })
          )
          expectObservable(result).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(subs)
        })
      })
    })
  })
})
import { expect } from "chai"
import { retryWhen, map, mergeMap, takeUntil, take } from "rxjs/operators"
import { of, EMPTY, Observable, throwError } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {retryWhen} */
describe("retryWhen", () => {
  let rxTest: TestScheduler
  beforeEach(() => {
    rxTest = new TestScheduler(observableMatcher)
  })
  it("should handle a source with eventual error using a hot notifier", () => {
    rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {
      const source = cold(" -1--2--#                     ")
      //                                 -1--2--#
      //                                              -1--2--#
      const subs = [
        "                   ^------!                     ",
        "                   -------------^------!        ",
        "                   --------------------------^-!",
      ]
      const notifier = hot("-------------r------------r-|")
      const expected = "    -1--2---------1--2---------1|"
      const result = source.pipe(retryWhen(() => notifier))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should handle a source with eventual error using a hot notifier that raises error", () => {
    rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {
      const source = cold(" -1--2--#                      ")
      //                               -1--2--#
      //                                       -1--2--#
      const subs = [
        "                   ^------!                      ",
        "                   -----------^------!           ",
        "                   -------------------^------!   ",
      ]
      const notifier = hot("-----------r-------r---------#")
      const expected = "    -1--2-------1--2----1--2-----#"
      const result = source.pipe(retryWhen(() => notifier))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should retry when notified via returned notifier on thrown error", done => {
    let retried = false
    const expected = [1, 2, 1, 2]
    let i = 0
    of(1, 2, 3)
      .pipe(
        map((n: number) => {
          if (n === 3) {
            throw "bad"
          }
          return n
        }),
        retryWhen((errors: any) =>
          errors.pipe(
            map((x: any) => {
              expect(x).to.equal("bad")
              if (retried) {
                throw new Error("done")
              }
              retried = true
              return x
            })
          )
        )
      )
      .subscribe({
        next(x: any) {
          expect(x).to.equal(expected[i++])
        },
        error(err: any) {
          expect(err).to.be.an("error", "done")
          done()
        },
      })
  })
  it("should retry when notified and complete on returned completion", done => {
    const expected = [1, 2, 1, 2]
    of(1, 2, 3)
      .pipe(
        map((n: number) => {
          if (n === 3) {
            throw "bad"
          }
          return n
        }),
        retryWhen(() => EMPTY)
      )
      .subscribe({
        next(n: number) {
          expect(n).to.equal(expected.shift())
        },
        error() {
          done(new Error("should not be called"))
        },
        complete() {
          done()
        },
      })
  })
  it("should apply an empty notifier on an empty source", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  |   ")
      const subs = "         (^!)"
      const notifier = cold("|   ")
      const expected = "     |   "
      const result = source.pipe(retryWhen(() => notifier))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should apply a never notifier on an empty source", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  |   ")
      const subs = "         (^!)"
      const notifier = cold("-   ")
      const expected = "     |   "
      const result = source.pipe(retryWhen(() => notifier))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should apply an empty notifier on a never source", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  ------------------------------------------")
      const unsub = "        -----------------------------------------!"
      const subs = "         ^----------------------------------------!"
      const notifier = cold("|                                         ")
      const expected = "     ------------------------------------------"
      const result = source.pipe(retryWhen(() => notifier))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should apply a never notifier on a never source", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  -----------------------------------------")
      const unsub = "        -----------------------------------------!"
      const subs = "         ^----------------------------------------!"
      const notifier = cold("------------------------------------------")
      const expected = "     -----------------------------------------"
      const result = source.pipe(retryWhen(() => notifier))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should return an empty observable given a just-throw source and empty notifier", () => {
    rxTest.run(({ cold, expectObservable }) => {
      const source = cold("  #")
      const notifier = cold("|")
      const expected = "     |"
      const result = source.pipe(retryWhen(() => notifier))
      expectObservable(result).toBe(expected)
    })
  })
  it("should return a never observable given a just-throw source and never notifier", () => {
    rxTest.run(({ cold, expectObservable }) => {
      const source = cold("  #")
      const notifier = cold("-")
      const expected = "     -"
      const result = source.pipe(retryWhen(() => notifier))
      expectObservable(result).toBe(expected)
    })
  })
  it("should hide errors using a never notifier on a source with eventual error", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  --a--b--c--#                              ")
      const subs = "         ^----------!                              "
      const notifier = cold("           -------------------------------")
      const expected = "     --a--b--c---------------------------------"
      const result = source.pipe(retryWhen(() => notifier))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should propagate error thrown from notifierSelector function", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--a--b--c--#")
      const subs = "       ^----------!"
      const expected = "   --a--b--c--#"
      const result = source.pipe(
        retryWhen(() => {
          throw "bad!"
        })
      )
      expectObservable(result).toBe(expected, undefined, "bad!")
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should replace error with complete using an empty notifier on a source with eventual error", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  --a--b--c--#")
      const subs = "         ^----------!"
      const notifier = cold("           |")
      const expected = "     --a--b--c--|"
      const result = source.pipe(retryWhen(() => notifier))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should mirror a basic cold source with complete, given an empty notifier", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  --a--b--c--|")
      const subs = "         ^----------!"
      const notifier = cold("           |")
      const expected = "     --a--b--c--|"
      const result = source.pipe(retryWhen(() => notifier))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should mirror a basic cold source with no termination, given an empty notifier", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  --a--b--c---")
      const subs = "         ^-----------"
      const notifier = cold("           |")
      const expected = "     --a--b--c---"
      const result = source.pipe(retryWhen(() => notifier))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should mirror a basic hot source with complete, given an empty notifier", () => {
    rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {
      const source = hot("-a-^--b--c--|")
      const subs = "         ^--------!"
      const notifier = cold("         |")
      const expected = "     ---b--c--|"
      const result = source.pipe(retryWhen(() => notifier))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should handle a hot source that raises error but eventually completes", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("  -1--2--3----4--5---|                  ")
      const ssubs = [
        "                   ^------!                              ",
        "                   --------------^----!                  ",
      ]
      const notifier = hot("--------------r--------r---r--r--r---|")
      const nsubs = "       -------^-----------!                  "
      const expected = "    -1--2----------5---|                  "
      const result = source.pipe(
        map((x: string) => {
          if (x === "3") {
            throw "error"
          }
          return x
        }),
        retryWhen(() => notifier)
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(ssubs)
      expectSubscriptions(notifier.subscriptions).toBe(nsubs)
    })
  })
  it("should tear down resources when result is unsubscribed early", () => {
    rxTest.run(({ hot, cold, expectObservable, expectSubscriptions }) => {
      const source = cold(" -1--2--#                    ")
      //                             -1--2--#
      //                                     -1--2--#
      const unsub = "       --------------------!       "
      const subs = [
        "                   ^------!                    ",
        "                   ---------^------!           ",
        "                   -----------------^--!       ",
      ]
      const notifier = hot("---------r-------r---------#")
      const nsubs = "       -------^------------!       "
      const expected = "    -1--2-----1--2----1--       "
      const result = source.pipe(retryWhen(() => notifier))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
      expectSubscriptions(notifier.subscriptions).toBe(nsubs)
    })
  })
  it("should not break unsubscription chains when unsubscribed explicitly", () => {
    rxTest.run(({ hot, cold, expectObservable, expectSubscriptions }) => {
      const source = cold(" -1--2--#                    ")
      //                             -1--2--#
      //                                     -1--2--#
      const subs = [
        "                   ^------!                    ",
        "                   ---------^------!           ",
        "                   -----------------^--!       ",
      ]
      const notifier = hot("---------r-------r-------r-#")
      const nsubs = "       -------^------------!       "
      const expected = "    -1--2-----1--2----1--       "
      const unsub = "       --------------------!       "
      const result = source.pipe(
        mergeMap((x: string) => of(x)),
        retryWhen(() => notifier),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
      expectSubscriptions(notifier.subscriptions).toBe(nsubs)
    })
  })
  it("should handle a source with eventual error using a dynamic notifier selector which eventually throws", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("-1--2--#              ")
      //                          -1--2--#
      //                                 -1--2--#
      const subs = [
        "                  ^------!              ",
        "                  -------^------!       ",
        "                  --------------^------!",
      ]
      const expected = "   -1--2---1--2---1--2--#"
      let invoked = 0
      const result = source.pipe(
        retryWhen((errors: any) =>
          errors.pipe(
            map(() => {
              if (++invoked === 3) {
                throw "error"
              } else {
                return "x"
              }
            })
          )
        )
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should handle a source with eventual error using a dynamic notifier selector which eventually completes", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("-1--2--#              ")
      //                          -1--2--#
      //                                 -1--2--#
      const subs = [
        "                  ^------!              ",
        "                  -------^------!       ",
        "                  --------------^------!",
      ]
      const expected = "   -1--2---1--2---1--2--|"
      let invoked = 0
      const result = source.pipe(
        retryWhen((errors: any) =>
          errors.pipe(
            map(() => "x"),
            takeUntil(
              errors.pipe(
                mergeMap(() => {
                  if (++invoked < 3) {
                    return EMPTY
                  } else {
                    return of("stop!")
                  }
                })
              )
            )
          )
        )
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should always finalize before starting the next cycle, even when synchronous", () => {
    const results: any[] = []
    const source = new Observable<number>(subscriber => {
      subscriber.next(1)
      subscriber.next(2)
      subscriber.error("bad")
      return () => {
        results.push("finalizer")
      }
    })
    const subscription = source
      .pipe(
        retryWhen(errors$ =>
          errors$.pipe(
            mergeMap((err, i) => (i < 3 ? of(true) : throwError(() => err)))
          )
        )
      )
      .subscribe({
        next: value => results.push(value),
        error: err => results.push(err),
      })
    expect(subscription.closed).to.be.true
    expect(results).to.deep.equal([
      1,
      2,
      "finalizer",
      1,
      2,
      "finalizer",
      1,
      2,
      "finalizer",
      1,
      2,
      "bad",
      "finalizer",
    ])
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        retryWhen(() => of(0)),
        take(3)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { sample, mergeMap } from "rxjs/operators"
import { Subject, of } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {sample} */
describe("sample", () => {
  let rxTest: TestScheduler
  beforeEach(() => {
    rxTest = new TestScheduler(observableMatcher)
  })
  it("should get samples when the notifier emits", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---a----b---c----------d-----|   ")
      const e1subs = "  ^----------------------------!   "
      const e2 = hot("  -----x----------x---x------x---| ")
      const e2subs = "  ^----------------------------!   "
      const expected = "-----a----------c----------d-|   "
      expectObservable(e1.pipe(sample(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should sample nothing if source has not nexted at all", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("----a-^------------|")
      const e1subs = "      ^------------!"
      const e2 = hot("      -----x-------|")
      const e2subs = "      ^------------!"
      const expected = "    -------------|"
      expectObservable(e1.pipe(sample(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should behave properly when notified by the same observable as the source (issue #2075)", () => {
    const item$ = new Subject<number>()
    const results: number[] = []
    item$.pipe(sample(item$)).subscribe(value => results.push(value))
    item$.next(1)
    item$.next(2)
    item$.next(3)
    expect(results).to.deep.equal([1, 2, 3])
  })
  it("should sample nothing if source has nexted after all notifications, but notifier does not complete", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----a-^------b-----|")
      const e1subs = "        ^------------!"
      const e2 = hot("        -----x--------")
      const e2subs = "        ^------------!"
      const expected = "      -------------|"
      expectObservable(e1.pipe(sample(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not sample when the notifier completes", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----a-^------b----------|")
      const e1subs = "        ^-----------------!"
      const e2 = hot("        -----x-----|       ")
      const e2subs = "        ^----------!       "
      const expected = "      ------------------|"
      expectObservable(e1.pipe(sample(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not complete when the notifier completes, nor should it emit", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----a----b----c----d----e----f----")
      const e1subs = "  ^---------------------------------"
      const e2 = hot("  ------x-|                         ")
      const e2subs = "  ^-------!                         "
      const expected = "------a---------------------------"
      expectObservable(e1.pipe(sample(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should complete only when the source completes, if notifier completes early", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----a----b----c----d----e----f---|")
      const e1subs = "  ^--------------------------------!"
      const e2 = hot("  ------x-|                         ")
      const e2subs = "  ^-------!                         "
      const expected = "------a--------------------------|"
      expectObservable(e1.pipe(sample(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----a-^--b----c----d----e----f----|          ")
      const unsub = "         --------------!                        "
      const e1subs = "        ^-------------!                        "
      const e2 = hot("        -----x----------x----------x----------|")
      const e2subs = "        ^-------------!                        "
      const expected = "      -----b---------                        "
      expectObservable(e1.pipe(sample(e2)), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----a-^--b----c----d----e----f----|          ")
      const e1subs = "        ^-------------!                        "
      const e2 = hot("        -----x----------x----------x----------|")
      const e2subs = "        ^-------------!                        "
      const expected = "      -----b---------                        "
      const unsub = "         --------------!                        "
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        sample(e2),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should only sample when a new value arrives, even if it is the same value", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----a----b----c----c----e----f----|  ")
      const e1subs = "  ^---------------------------------!  "
      const e2 = hot("  ------x-x------xx-x---x----x--------|")
      const e2subs = "  ^---------------------------------!  "
      const expected = "------a--------c------c----e------|  "
      expectObservable(e1.pipe(sample(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise error if source raises error", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----a-^--b----c----d----#                    ")
      const e1subs = "        ^-----------------!                    "
      const e2 = hot("        -----x----------x----------x----------|")
      const e2subs = "        ^-----------------!                    "
      const expected = "      -----b----------d-#                    "
      expectObservable(e1.pipe(sample(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should completes if source does not emits", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  |              ")
      const e2 = hot("  ------x-------|")
      const expected = "|              "
      const e1subs = "  (^!)           "
      const e2subs = "  (^!)           "
      expectObservable(e1.pipe(sample(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise error if source throws immediately", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  #              ")
      const e2 = hot("  ------x-------|")
      const expected = "#              "
      const e1subs = "  (^!)           "
      const e2subs = "  (^!)           "
      expectObservable(e1.pipe(sample(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise error if notification raises error", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a-----|")
      const e2 = hot("  ----#    ")
      const expected = "----#    "
      const e1subs = "  ^---!    "
      const e2subs = "  ^---!    "
      expectObservable(e1.pipe(sample(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not completes if source does not complete", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---------------")
      const e1subs = "  ^--------------"
      const e2 = hot("  ------x-------|")
      const e2subs = "  ^-------------!"
      const expected = "---------------"
      expectObservable(e1.pipe(sample(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should sample only until source completes", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----a----b----c----d-|              ")
      const e1subs = "  ^--------------------!              "
      const e2 = hot("  -----------x----------x------------|")
      const e2subs = "  ^--------------------!              "
      const expected = "-----------b---------|              "
      expectObservable(e1.pipe(sample(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should complete sampling if sample observable completes", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----a----b----c----d-|")
      const e1subs = "  ^--------------------!"
      const e2 = hot("  |                     ")
      const e2subs = "  (^!)                  "
      const expected = "---------------------|"
      expectObservable(e1.pipe(sample(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
})
import { sampleTime, mergeMap } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {sampleTime} */
describe("sampleTime", () => {
  let rxTest: TestScheduler
  beforeEach(() => {
    rxTest = new TestScheduler(observableMatcher)
  })
  it("should get samples on a delay", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions, time }) => {
      const e1 = hot("     a---b-c---------d--e---f-g-h--|")
      const e1subs = "     ^-----------------------------!"
      const expected = "   -------c-------------e------h-|"
      // period            -------!------!------!------!--
      const period = time("-------|                       ")
      expectObservable(e1.pipe(sampleTime(period, rxTest))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should sample nothing if new value has not arrived", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions, time }) => {
      const e1 = hot("  ----a-^--b----c--------------f----|")
      const e1subs = "        ^---------------------------!"
      const expected = "      -----------c----------------|"
      // period               -----------!----------!---------
      const period = time("   -----------|                 ")
      expectObservable(e1.pipe(sampleTime(period, rxTest))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should sample if new value has arrived, even if it is the same value", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions, time }) => {
      const e1 = hot("----a-^--b----c----------c---f----|")
      const e1subs = "      ^---------------------------!"
      const expected = "    -----------c----------c-----|"
      // period             -----------!----------!---------
      const period = time(" -----------|                 ")
      expectObservable(e1.pipe(sampleTime(period, rxTest))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should sample nothing if source has not nexted by time of sample", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions, time }) => {
      const e1 = hot("----a-^-------------b-------------|")
      const e1subs = "      ^---------------------------!"
      const expected = "    ----------------------b-----|"
      // period             -----------!----------!---------
      const period = time(" -----------|                 ")
      expectObservable(e1.pipe(sampleTime(period, rxTest))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if source raises error", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions, time }) => {
      const e1 = hot("----a-^--b----c----d----#")
      const e1subs = "      ^-----------------!"
      const expected = "    -----------c------#"
      // period             -----------!----------!---------
      const period = time(" -----------|       ")
      expectObservable(e1.pipe(sampleTime(period, rxTest))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions, time }) => {
      const e1 = hot("----a-^--b----c----d----e----f----|")
      const unsub = "       ----------------!            "
      const e1subs = "      ^---------------!            "
      const expected = "    -----------c-----            "
      // period             -----------!----------!---------
      const period = time(" -----------|                 ")
      expectObservable(e1.pipe(sampleTime(period, rxTest)), unsub).toBe(
        expected
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions, time }) => {
      const e1 = hot("----a-^--b----c----d----e----f----|")
      const e1subs = "      ^---------------!            "
      // period             -----------!----------!---------
      const period = time(" -----------|                 ")
      const expected = "    -----------c-----            "
      const unsub = "       ----------------!            "
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        sampleTime(period, rxTest),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should completes if source does not emits", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions, time }) => {
      const e1 = cold("    |     ")
      const e1subs = "     (^!)  "
      const expected = "   |     "
      const period = time("-----|")
      expectObservable(e1.pipe(sampleTime(period, rxTest))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if source throws immediately", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions, time }) => {
      const e1 = cold("    #     ")
      const e1subs = "     (^!)  "
      const expected = "   #     "
      const period = time("-----|")
      expectObservable(e1.pipe(sampleTime(period, rxTest))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not complete if source does not complete", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions, time }) => {
      const e1 = cold("    --------")
      const e1subs = "     ^------!"
      const expected = "   --------"
      const period = time("-----|  ")
      const e1unsbs = "    -------!"
      expectObservable(e1.pipe(sampleTime(period, rxTest)), e1unsbs).toBe(
        expected
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
})
import { expect } from "chai"
import { scan, mergeMap, finalize, take } from "rxjs/operators"
import { of, Observable } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {scan} */
describe("scan", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should scan", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      // prettier-ignore
      const values = {
        a: 1, b: 3, c: 5,
        x: 1, y: 4, z: 9,
      };
      const e1 = hot("  --a--b--c--|", values)
      const e1subs = "  ^----------!"
      const expected = "--x--y--z--|"
      const scanFunction = function (o: number, x: number) {
        return o + x
      }
      expectObservable(e1.pipe(scan(scanFunction, 0))).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should scan things", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--e--f--g--|")
      const e1subs = "     ^--------------------!"
      const expected = "   ---u--v--w--x--y--z--|"
      const values = {
        u: ["b"],
        v: ["b", "c"],
        w: ["b", "c", "d"],
        x: ["b", "c", "d", "e"],
        y: ["b", "c", "d", "e", "f"],
        z: ["b", "c", "d", "e", "f", "g"],
      }
      const source = e1.pipe(scan((acc, x) => acc.concat(x), [] as string[]))
      expectObservable(source).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should provide the proper index if seed is skipped", () => {
    const expected = [1, 2]
    of(3, 3, 3)
      .pipe(
        scan((_: any, __, i) => {
          expect(i).to.equal(expected.shift())
          return null
        })
      )
      .subscribe()
  })
  it("should scan with a seed of undefined", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--e--f--g--|")
      const e1subs = "     ^--------------------!"
      const expected = "   ---u--v--w--x--y--z--|"
      const values = {
        u: "undefined b",
        v: "undefined b c",
        w: "undefined b c d",
        x: "undefined b c d e",
        y: "undefined b c d e f",
        z: "undefined b c d e f g",
      }
      const source = e1.pipe(
        scan((acc: any, x: string) => acc + " " + x, undefined)
      )
      expectObservable(source).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should scan without seed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--|")
      const e1subs = "     ^-----------!"
      const expected = "   ---x--y--z--|"
      const values = {
        x: "b",
        y: "bc",
        z: "bcd",
      }
      const source = e1.pipe(scan((acc: any, x: string) => acc + x))
      expectObservable(source).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle errors", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--#")
      const e1subs = "     ^-----------!"
      const expected = "   ---u--v--w--#"
      const values = {
        u: ["b"],
        v: ["b", "c"],
        w: ["b", "c", "d"],
      }
      const source = e1.pipe(scan((acc, x) => acc.concat(x), [] as string[]))
      expectObservable(source).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle errors in the projection function", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--e--f--g--|")
      const e1subs = "     ^--------!            "
      const expected = "   ---u--v--#            "
      const values = {
        u: ["b"],
        v: ["b", "c"],
        w: ["b", "c", "d"],
        x: ["b", "c", "d", "e"],
        y: ["b", "c", "d", "e", "f"],
        z: ["b", "c", "d", "e", "f", "g"],
      }
      const source = e1.pipe(
        scan((acc, x) => {
          if (x === "d") {
            throw "bad!"
          }
          return acc.concat(x)
        }, [] as string[])
      )
      expectObservable(source).toBe(expected, values, "bad!")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("handle empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      const source = e1.pipe(scan((acc, x) => acc.concat(x), [] as string[]))
      expectObservable(source).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("handle never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      const source = e1.pipe(scan((acc, x) => acc.concat(x), [] as string[]))
      expectObservable(source).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("handle throw", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      const source = e1.pipe(scan((acc, x) => acc.concat(x), [] as string[]))
      expectObservable(source).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--e--f--g--|")
      const unsub = "      --------------!       "
      const e1subs = "     ^-------------!       "
      const expected = "   ---u--v--w--x--       "
      const values = {
        u: ["b"],
        v: ["b", "c"],
        w: ["b", "c", "d"],
        x: ["b", "c", "d", "e"],
        y: ["b", "c", "d", "e", "f"],
        z: ["b", "c", "d", "e", "f", "g"],
      }
      const source = e1.pipe(scan((acc, x) => acc.concat(x), [] as string[]))
      expectObservable(source, unsub).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b--c--d--e--f--g--|")
      const e1subs = "     ^-------------!       "
      const expected = "   ---u--v--w--x--       "
      const unsub = "      --------------!       "
      const values = {
        u: ["b"],
        v: ["b", "c"],
        w: ["b", "c", "d"],
        x: ["b", "c", "d", "e"],
        y: ["b", "c", "d", "e", "f"],
        z: ["b", "c", "d", "e", "f", "g"],
      }
      const source = e1.pipe(
        mergeMap((x: string) => of(x)),
        scan((acc, x) => acc.concat(x), [] as string[]),
        mergeMap((x: string[]) => of(x))
      )
      expectObservable(source, unsub).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should pass current index to accumulator", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      // prettier-ignore
      const values = {
        a: 1, b: 3, c: 5,
        x: 1, y: 4, z: 9,
      };
      let idx = [0, 1, 2]
      const e1 = hot("  --a--b--c--|", values)
      const e1subs = "  ^----------!"
      const expected = "--x--y--z--|"
      const scanFunction = (o: number, value: number, index: number) => {
        expect(index).to.equal(idx.shift())
        return o + value
      }
      const scanObs = e1.pipe(
        scan(scanFunction, 0),
        finalize(() => {
          expect(idx).to.be.empty
        })
      )
      expectObservable(scanObs).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        scan((_acc, value: number) => value, 0),
        take(3)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { sequenceEqual } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
const booleans = { T: true, F: false }
/** @test {sequenceEqual} */
describe("sequenceEqual", () => {
  let rxTestScheduler: TestScheduler
  beforeEach(() => {
    rxTestScheduler = new TestScheduler(observableMatcher)
  })
  it("should return true for two equal sequences", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const s1 = hot("--a--^--b--c--d--e--f--g--|       ")
      const s1subs = "     ^--------------------!       "
      const s2 = hot("-----^-----b--c--d-e-f------g-|   ")
      const s2subs = "     ^------------------------!   "
      const expected = "   -------------------------(T|)"
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected, booleans)
      expectSubscriptions(s1.subscriptions).toBe(s1subs)
      expectSubscriptions(s2.subscriptions).toBe(s2subs)
    })
  })
  it("should return false for two sync observables that are unequal in length", () => {
    rxTestScheduler.run(({ cold, expectObservable }) => {
      const s1 = cold(" (abcdefg|)")
      const s2 = cold(" (abc|)    ")
      const expected = "(F|)      "
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected, booleans)
    })
  })
  it("should return true for two sync observables that match", () => {
    rxTestScheduler.run(({ cold, expectObservable }) => {
      const s1 = cold(" (abcdefg|)")
      const s2 = cold(" (abcdefg|)")
      const expected = "(T|)      "
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected, booleans)
    })
  })
  it("should return true for two observables that match when the last one emits and completes in the same frame", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const s1 = hot("--a--^--b--c--d--e--f--g--|       ")
      const s1subs = "     ^--------------------!       "
      const s2 = hot("-----^--b--c--d--e--f--g------|   ")
      const s2subs = "     ^------------------------!   "
      const expected = "   -------------------------(T|)"
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected, booleans)
      expectSubscriptions(s1.subscriptions).toBe(s1subs)
      expectSubscriptions(s2.subscriptions).toBe(s2subs)
    })
  })
  it("should return true for two observables that match when the last one emits and completes in the same frame", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const s1 = hot("--a--^--b--c--d--e--f--g--|       ")
      const s1subs = "     ^--------------------!       "
      const s2 = hot("-----^--b--c--d--e--f---------(g|)")
      const s2subs = "     ^------------------------!   "
      const expected = "   -------------------------(T|)"
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected, booleans)
      expectSubscriptions(s1.subscriptions).toBe(s1subs)
      expectSubscriptions(s2.subscriptions).toBe(s2subs)
    })
  })
  it("should error with an errored source", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const s1 = hot("--a--^--b---c---#  ")
      const s2 = hot("--a--^--b---c-----|")
      const expected = "   -----------#  "
      const sub = "        ^----------!  "
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected, booleans)
      expectSubscriptions(s1.subscriptions).toBe(sub)
      expectSubscriptions(s2.subscriptions).toBe(sub)
    })
  })
  it("should error with an errored compareTo", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const s1 = hot("--a--^--b---c-----|")
      const s2 = hot("--a--^--b---c---#  ")
      const expected = "   -----------#  "
      const sub = "        ^----------!  "
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected, booleans)
      expectSubscriptions(s1.subscriptions).toBe(sub)
      expectSubscriptions(s2.subscriptions).toBe(sub)
    })
  })
  it("should error if the source is a throw", () => {
    rxTestScheduler.run(({ cold, expectObservable }) => {
      const s1 = cold(" #            ")
      const s2 = cold(" ---a--b--c--|")
      const expected = "#            "
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected)
    })
  })
  it("should never return if source is a never", () => {
    rxTestScheduler.run(({ cold, expectObservable }) => {
      const s1 = cold(" ------------")
      const s2 = cold(" --a--b--c--|")
      const expected = "------------"
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected)
    })
  })
  it("should never return if compareTo is a never", () => {
    rxTestScheduler.run(({ cold, expectObservable }) => {
      const s1 = cold(" --a--b--c--|")
      const s2 = cold(" ------------")
      const expected = "------------"
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected)
    })
  })
  it("should return false if source is empty and compareTo is not", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const s1 = cold(" |            ")
      const s1subs = "  (^!)          "
      const s2 = cold(" ------a------")
      const s2subs = "  ^-----!      "
      const expected = "------(F|)   "
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected, booleans)
      expectSubscriptions(s1.subscriptions).toBe(s1subs)
      expectSubscriptions(s2.subscriptions).toBe(s2subs)
    })
  })
  it("should return false if compareTo is empty and source is not", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const s1 = cold(" ------a------")
      const s2 = cold(" |            ")
      const expected = "------(F|)   "
      const s1subs = "  ^-----!      "
      const s2subs = "  (^!)         "
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected, booleans)
      expectSubscriptions(s1.subscriptions).toBe(s1subs)
      expectSubscriptions(s2.subscriptions).toBe(s2subs)
    })
  })
  it("should return never if compareTo is empty and source is never", () => {
    rxTestScheduler.run(({ cold, expectObservable }) => {
      const s1 = cold(" -")
      const s2 = cold(" |")
      const expected = "-"
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected)
    })
  })
  it("should return never if source is empty and compareTo is never", () => {
    rxTestScheduler.run(({ cold, expectObservable }) => {
      const s1 = cold(" |")
      const s2 = cold(" -")
      const expected = "-"
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected)
    })
  })
  it("should error if the comparator function errors", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values: { [key: string]: any } = {
        a: null,
        b: { value: "bees knees" },
        c: { value: "carpy dumb" },
        d: { value: "derp" },
        x: { value: "bees knees", foo: "lol" },
        y: { value: "carpy dumb", scooby: "doo" },
        z: { value: "derp", weCouldBe: "dancin, yeah" },
      }
      const s1 = hot("--a--^--b-----c------d--|      ", values)
      const s1subs = "     ^------------!            "
      const s2 = hot("-----^--------x---y---z-------|", values)
      const s2subs = "     ^------------!            "
      const expected = "   -------------#            "
      let i = 0
      const source = s1.pipe(
        sequenceEqual(s2, (a: any, b: any) => {
          if (++i === 2) {
            throw new Error("shazbot")
          }
          return a.value === b.value
        })
      )
      expectObservable(source).toBe(expected, booleans, new Error("shazbot"))
      expectSubscriptions(s1.subscriptions).toBe(s1subs)
      expectSubscriptions(s2.subscriptions).toBe(s2subs)
    })
  })
  it("should use the provided comparator function", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const values: { [key: string]: any } = {
        a: null,
        b: { value: "bees knees" },
        c: { value: "carpy dumb" },
        d: { value: "derp" },
        x: { value: "bees knees", foo: "lol" },
        y: { value: "carpy dumb", scooby: "doo" },
        z: { value: "derp", weCouldBe: "dancin, yeah" },
      }
      const s1 = hot("--a--^--b-----c------d--|         ", values)
      const s1subs = "     ^------------------!         "
      const s2 = hot("-----^--------x---y---z-------|   ", values)
      const s2subs = "     ^------------------------!   "
      const expected = "   -------------------------(T|)"
      const source = s1.pipe(
        sequenceEqual(s2, (a: any, b: any) => a.value === b.value)
      )
      expectObservable(source).toBe(expected, booleans)
      expectSubscriptions(s1.subscriptions).toBe(s1subs)
      expectSubscriptions(s2.subscriptions).toBe(s2subs)
    })
  })
  it("should return false for two unequal sequences, compareTo finishing last", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const s1 = hot("--a--^--b--c--d--e--f--g--|    ")
      const s1subs = "     ^--------------------!    "
      const s2 = hot("-----^-----b--c--d-e-f------z-|")
      const s2subs = "     ^----------------------!   "
      const expected = "   -----------------------(F|)"
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected, booleans)
      expectSubscriptions(s1.subscriptions).toBe(s1subs)
      expectSubscriptions(s2.subscriptions).toBe(s2subs)
    })
  })
  it("should return false for two unequal sequences, early wrong value from source", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const s1 = hot("--a--^--b--c---x-----------|")
      const s1subs = "     ^---------!            "
      const s2 = hot("-----^--b--c--d--e--f--|    ")
      const s2subs = "     ^---------!            "
      const expected = "   ----------(F|)         "
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected, booleans)
      expectSubscriptions(s1.subscriptions).toBe(s1subs)
      expectSubscriptions(s2.subscriptions).toBe(s2subs)
    })
  })
  it("should return false when the source emits an extra value after the compareTo completes", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const s1 = hot("--a--^--b--c--d--e--f--g--h--|")
      const s1subs = "     ^-----------!            "
      const s2 = hot("-----^--b--c--d-|             ")
      const s2subs = "     ^----------!             "
      const expected = "   ------------(F|)         "
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected, booleans)
      expectSubscriptions(s1.subscriptions).toBe(s1subs)
      expectSubscriptions(s2.subscriptions).toBe(s2subs)
    })
  })
  it("should return false when the compareTo emits an extra value after the source completes", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const s1 = hot("--a--^--b--c--d-|             ")
      const s1subs = "     ^----------!             "
      const s2 = hot("-----^--b--c--d--e--f--g--h--|")
      const s2subs = "     ^-----------!            "
      const expected = "   ------------(F|)         "
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected, booleans)
      expectSubscriptions(s1.subscriptions).toBe(s1subs)
      expectSubscriptions(s2.subscriptions).toBe(s2subs)
    })
  })
  it("should return true for two empty observables", () => {
    rxTestScheduler.run(({ cold, expectObservable }) => {
      const s1 = cold(" |   ")
      const s2 = cold(" |   ")
      const expected = "(T|)"
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected, booleans)
    })
  })
  it("should return false for an empty observable and an observable that emits", () => {
    rxTestScheduler.run(({ cold, expectObservable }) => {
      const s1 = cold(" |      ")
      const s2 = cold(" ---a--|")
      const expected = "---(F|)"
      const source = s1.pipe(sequenceEqual(s2))
      expectObservable(source).toBe(expected, booleans)
    })
  })
  it("should return compare hot and cold observables", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const s1 = hot("---a--^---b---c---d---e---f---g---h---i---j---|   ")
        const s2 = cold("     ----b---c-|                                 ")
        const s2subs = "      ^---------!                                 "
        const expected1 = "   ------------(F|)                            "
        const s3 = cold("                        -f---g---h---i---j---|   ")
        const test2subs = "   -------------------^                        "
        const expected2 = "   ----------------------------------------(T|)"
        const s3subs = "      -------------------^--------------------!   "
        const test1 = s1.pipe(sequenceEqual(s2))
        const test2 = s1.pipe(sequenceEqual(s3))
        expectObservable(test1).toBe(expected1, booleans)
        expectObservable(test2, test2subs).toBe(expected2, booleans)
        expectSubscriptions(s2.subscriptions).toBe(s2subs)
        expectSubscriptions(s3.subscriptions).toBe(s3subs)
      }
    )
  })
})
import { expect } from "chai"
import {
  asapScheduler,
  concat,
  config,
  defer,
  EMPTY,
  NEVER,
  Observable,
  of,
  scheduled,
  Subject,
  throwError,
  pipe,
} from "rxjs"
import {
  map,
  mergeMap,
  mergeMapTo,
  onErrorResumeNext,
  repeat,
  retry,
  share,
  startWith,
  take,
  takeUntil,
  takeWhile,
  tap,
  toArray,
  withLatestFrom,
} from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
import { SinonSpy, spy } from "sinon"
const syncNotify = of(1)
const asapNotify = scheduled(syncNotify, asapScheduler)
const syncError = throwError(() => new Error())
function spyOnUnhandledError(fn: (spy: SinonSpy) => void): void {
  const prevOnUnhandledError = config.onUnhandledError
  try {
    const onUnhandledError = spy()
    config.onUnhandledError = onUnhandledError
    fn(onUnhandledError)
  } finally {
    config.onUnhandledError = prevOnUnhandledError
  }
}
/** @test {share} */
describe("share", () => {
  let rxTest: TestScheduler
  beforeEach(() => {
    rxTest = new TestScheduler(observableMatcher)
  })
  for (const { title, options } of [
    { title: "share()", options: {} },
    {
      title: "share() using sync reset notifiers equivalent to default config",
      options: {
        resetOnError: () => syncNotify,
        resetOnComplete: () => syncNotify,
        resetOnRefCountZero: () => syncNotify,
      },
    },
    {
      title:
        "share() using sync reset notifiers equivalent to default config and notifying again after reset is notified",
      options: {
        resetOnError: () => concat(syncNotify, syncNotify),
        resetOnComplete: () => concat(syncNotify, syncNotify),
        resetOnRefCountZero: () => concat(syncNotify, syncNotify),
      },
    },
    {
      title:
        "share() using sync reset notifiers equivalent to default config and never completing after reset is notified",
      options: {
        resetOnError: () => concat(syncNotify, NEVER),
        resetOnComplete: () => concat(syncNotify, NEVER),
        resetOnRefCountZero: () => concat(syncNotify, NEVER),
      },
    },
    {
      title:
        "share() using sync reset notifiers equivalent to default config and throwing an error after reset is notified",
      options: {
        resetOnError: () => concat(syncNotify, syncError),
        resetOnComplete: () => concat(syncNotify, syncError),
        resetOnRefCountZero: () => concat(syncNotify, syncError),
      },
    },
  ]) {
    describe(title, () => {
      it("should mirror a simple source Observable", () => {
        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
          const source = cold("--1-2---3-4--5-|")
          const sourceSubs = " ^--------------!"
          const expected = "   --1-2---3-4--5-|"
          const shared = source.pipe(share(options))
          expectObservable(shared).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
      })
      it("should share a single subscription", () => {
        let subscriptionCount = 0
        const obs = new Observable<never>(() => {
          subscriptionCount++
        })
        const source = obs.pipe(share(options))
        expect(subscriptionCount).to.equal(0)
        source.subscribe()
        source.subscribe()
        expect(subscriptionCount).to.equal(1)
      })
      it("should not change the output of the observable when error", () => {
        rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
          const e1 = hot("---a--^--b--c--d--e--#")
          const e1subs = "      ^--------------!"
          const expected = "    ---b--c--d--e--#"
          expectObservable(e1.pipe(share(options))).toBe(expected)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        })
      })
      it("should not change the output of the observable when successful with cold observable", () => {
        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
          const e1 = cold(" ---a--b--c--d--e--|")
          const e1subs = "  ^-----------------!"
          const expected = "---a--b--c--d--e--|"
          expectObservable(e1.pipe(share(options))).toBe(expected)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        })
      })
      it("should not change the output of the observable when error with cold observable", () => {
        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
          const e1 = cold(" ---a--b--c--d--e--#")
          const e1subs = "  ^-----------------!"
          const expected = "---a--b--c--d--e--#"
          expectObservable(e1.pipe(share(options))).toBe(expected)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        })
      })
      it("should retry just fine", () => {
        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
          const e1 = cold(" ---a--b--c--d--e--#                  ")
          // prettier-ignore
          const e1subs = [
            '               ^-----------------!                  ',
            '               ------------------^-----------------!'
          ];
          const expected = "---a--b--c--d--e-----a--b--c--d--e--#"
          expectObservable(e1.pipe(share(options), retry(1))).toBe(expected)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        })
      })
      it("should share the same values to multiple observers", () => {
        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("    -1-2-3----4-|")
          const sourceSubs = "     ^-----------!"
          const subscriber1 = hot("a|           ")
          const expected1 = "      -1-2-3----4-|"
          const subscriber2 = hot("----b|       ")
          const expected2 = "      -----3----4-|"
          const subscriber3 = hot("--------c|   ")
          const expected3 = "      ----------4-|"
          const shared = source.pipe(share(options))
          expectObservable(subscriber1.pipe(mergeMapTo(shared))).toBe(expected1)
          expectObservable(subscriber2.pipe(mergeMapTo(shared))).toBe(expected2)
          expectObservable(subscriber3.pipe(mergeMapTo(shared))).toBe(expected3)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
      })
      it("should share an error from the source to multiple observers", () => {
        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("    -1-2-3----4-#")
          const sourceSubs = "     ^-----------!"
          const subscriber1 = hot("a|           ")
          const expected1 = "      -1-2-3----4-#"
          const subscriber2 = hot("----b|       ")
          const expected2 = "      -----3----4-#"
          const subscriber3 = hot("--------c|   ")
          const expected3 = "      ----------4-#"
          const shared = source.pipe(share(options))
          expectObservable(subscriber1.pipe(mergeMapTo(shared))).toBe(expected1)
          expectObservable(subscriber2.pipe(mergeMapTo(shared))).toBe(expected2)
          expectObservable(subscriber3.pipe(mergeMapTo(shared))).toBe(expected3)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
      })
      it("should share the same values to multiple observers, but is unsubscribed explicitly and early", () => {
        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("    -1-2-3----4-|")
          const sourceSubs = "     ^--------!   "
          const unsub = "          ---------!   "
          const subscriber1 = hot("a|           ")
          const expected1 = "      -1-2-3----   "
          const subscriber2 = hot("----b|       ")
          const expected2 = "      -----3----   "
          const subscriber3 = hot("--------c|   ")
          const expected3 = "      ----------   "
          const shared = source.pipe(share(options))
          expectObservable(subscriber1.pipe(mergeMapTo(shared)), unsub).toBe(
            expected1
          )
          expectObservable(subscriber2.pipe(mergeMapTo(shared)), unsub).toBe(
            expected2
          )
          expectObservable(subscriber3.pipe(mergeMapTo(shared)), unsub).toBe(
            expected3
          )
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
      })
      it("should share an empty source", () => {
        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
          const source = cold("|   ")
          const sourceSubs = " (^!)"
          const expected = "   |   "
          const shared = source.pipe(share(options))
          expectObservable(shared).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
      })
      it("should share a never source", () => {
        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
          const source = cold("-")
          const sourceSubs = " ^"
          const expected = "   -"
          const shared = source.pipe(share(options))
          expectObservable(shared).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
      })
      it("should share a throw source", () => {
        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
          const source = cold("#   ")
          const sourceSubs = " (^!)"
          const expected = "   #   "
          const shared = source.pipe(share(options))
          expectObservable(shared).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
      })
      it("should connect when first subscriber subscribes", () => {
        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("       -1-2-3----4-|")
          const sourceSubs = "     ---^-----------!"
          const subscriber1 = hot("---a|           ")
          const expected1 = "      ----1-2-3----4-|"
          const subscriber2 = hot("-------b|       ")
          const expected2 = "      --------3----4-|"
          const subscriber3 = hot("-----------c|   ")
          const expected3 = "      -------------4-|"
          const shared = source.pipe(share(options))
          expectObservable(subscriber1.pipe(mergeMapTo(shared))).toBe(expected1)
          expectObservable(subscriber2.pipe(mergeMapTo(shared))).toBe(expected2)
          expectObservable(subscriber3.pipe(mergeMapTo(shared))).toBe(expected3)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
      })
      it("should disconnect when last subscriber unsubscribes", () => {
        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("       -1-2-3----4-|")
          const sourceSubs = "     ---^--------!   "
          const subscriber1 = hot("---a|           ")
          const unsub1 = "         ----------!     "
          const expected1 = "      ----1-2-3--     "
          const subscriber2 = hot("-------b|       ")
          const unsub2 = "         ------------!   "
          const expected2 = "      --------3----   "
          const shared = source.pipe(share(options))
          expectObservable(subscriber1.pipe(mergeMapTo(shared)), unsub1).toBe(
            expected1
          )
          expectObservable(subscriber2.pipe(mergeMapTo(shared)), unsub2).toBe(
            expected2
          )
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
      })
      it("should not break unsubscription chain when last subscriber unsubscribes", () => {
        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("       -1-2-3----4-|")
          const sourceSubs = "     ---^--------!   "
          const subscriber1 = hot("---a|           ")
          const unsub1 = "         ----------!     "
          const expected1 = "      ----1-2-3--     "
          const subscriber2 = hot("-------b|       ")
          const unsub2 = "         ------------!   "
          const expected2 = "      --------3----   "
          const shared = source.pipe(
            mergeMap((x: string) => of(x)),
            share(options),
            mergeMap((x: string) => of(x))
          )
          expectObservable(subscriber1.pipe(mergeMapTo(shared)), unsub1).toBe(
            expected1
          )
          expectObservable(subscriber2.pipe(mergeMapTo(shared)), unsub2).toBe(
            expected2
          )
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
      })
      it("should be retryable when cold source is synchronous", () => {
        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("(123#)    ")
          const subscribe1 = " s         "
          const expected1 = "  (123123#) "
          const subscribe2 = " -s        "
          const expected2 = "  -(123123#)"
          const sourceSubs = [
            "                  (^!)      ",
            "                  (^!)      ",
            "                  -(^!)     ",
            "                  -(^!)     ",
          ]
          const shared = source.pipe(share(options))
          expectObservable(
            hot(subscribe1).pipe(
              tap(() => {
                expectObservable(shared.pipe(retry(1))).toBe(expected1)
              })
            )
          ).toBe(subscribe1)
          expectObservable(
            hot(subscribe2).pipe(
              tap(() => {
                expectObservable(shared.pipe(retry(1))).toBe(expected2)
              })
            )
          ).toBe(subscribe2)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
      })
      it("should be repeatable when cold source is synchronous", () => {
        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("(123|)    ")
          const subscribe1 = " s         "
          const expected1 = "  (123123|) "
          const subscribe2 = " -s        "
          const expected2 = "  -(123123|)"
          const sourceSubs = [
            "                  (^!)      ",
            "                  (^!)      ",
            "                  -(^!)     ",
            "                  -(^!)     ",
          ]
          const shared = source.pipe(share(options))
          expectObservable(
            hot(subscribe1).pipe(
              tap(() => {
                expectObservable(shared.pipe(repeat(2))).toBe(expected1)
              })
            )
          ).toBe(subscribe1)
          expectObservable(
            hot(subscribe2).pipe(
              tap(() => {
                expectObservable(shared.pipe(repeat(2))).toBe(expected2)
              })
            )
          ).toBe(subscribe2)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
      })
      it("should be retryable", () => {
        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("-1-2-3----4-#                        ")
          const sourceSubs = [
            "                  ^-----------!                        ",
            "                  ------------^-----------!            ",
            "                  ------------------------^-----------!",
          ]
          const subscribe1 = " s------------------------------------"
          const expected1 = "  -1-2-3----4--1-2-3----4--1-2-3----4-#"
          const subscribe2 = " ----s--------------------------------"
          const expected2 = "  -----3----4--1-2-3----4--1-2-3----4-#"
          const shared = source.pipe(share(options))
          expectObservable(
            hot(subscribe1).pipe(
              tap(() => {
                expectObservable(shared.pipe(retry(2))).toBe(expected1)
              })
            )
          ).toBe(subscribe1)
          expectObservable(
            hot(subscribe2).pipe(
              tap(() => {
                expectObservable(shared.pipe(retry(2))).toBe(expected2)
              })
            )
          ).toBe(subscribe2)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
      })
      it("should be repeatable", () => {
        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = cold("-1-2-3----4-|                        ")
          const sourceSubs = [
            "                  ^-----------!                        ",
            "                  ------------^-----------!            ",
            "                  ------------------------^-----------!",
          ]
          const subscribe1 = " s------------------------------------"
          const expected1 = "  -1-2-3----4--1-2-3----4--1-2-3----4-|"
          const subscribe2 = " ----s--------------------------------"
          const expected2 = "  -----3----4--1-2-3----4--1-2-3----4-|"
          const shared = source.pipe(share(options))
          expectObservable(
            hot(subscribe1).pipe(
              tap(() => {
                expectObservable(shared.pipe(repeat(3))).toBe(expected1)
              })
            )
          ).toBe(subscribe1)
          expectObservable(
            hot(subscribe2).pipe(
              tap(() => {
                expectObservable(shared.pipe(repeat(3))).toBe(expected2)
              })
            )
          ).toBe(subscribe2)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
      })
      it("should not change the output of the observable when never", () => {
        rxTest.run(({ expectObservable }) => {
          const e1 = NEVER
          const expected = "-"
          expectObservable(e1.pipe(share(options))).toBe(expected)
        })
      })
      it("should not change the output of the observable when empty", () => {
        rxTest.run(({ expectObservable }) => {
          const e1 = EMPTY
          const expected = "|"
          expectObservable(e1.pipe(share(options))).toBe(expected)
        })
      })
      it("should stop listening to a synchronous observable when unsubscribed", () => {
        const sideEffects: number[] = []
        const synchronousObservable = new Observable<number>(subscriber => {
          // This will check to see if the subscriber was closed on each loop
          // when the unsubscribe hits (from the `take`), it should be closed
          for (let i = 0; !subscriber.closed && i < 10; i++) {
            sideEffects.push(i)
            subscriber.next(i)
          }
        })
        synchronousObservable.pipe(share(options), take(3)).subscribe(() => {
          /* noop */
        })
        expect(sideEffects).to.deep.equal([0, 1, 2])
      })
      it("should not fail on reentrant subscription", () => {
        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
          // https://github.com/ReactiveX/rxjs/issues/6144
          const source = cold("(123|)")
          const subs = "       (^!)  "
          const expected = "   (136|)"
          const deferred = defer(() => shared).pipe(startWith(0))
          const shared: Observable<string> = source.pipe(
            withLatestFrom(deferred),
            map(([a, b]) => String(Number(a) + Number(b))),
            share(options)
          )
          expectObservable(shared).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(subs)
        })
      })
    })
  }
  for (const { title, resetOnError, resetOnComplete, resetOnRefCountZero } of [
    {
      title: "share(config)",
      resetOnError: false,
      resetOnComplete: false,
      resetOnRefCountZero: false,
    },
    {
      title: "share(config) using EMPTY as sync reset notifier equivalents",
      resetOnError: () => EMPTY,
      resetOnComplete: () => EMPTY,
      resetOnRefCountZero: () => EMPTY,
    },
    {
      title: "share(config) using NEVER as sync reset notifier equivalents",
      resetOnError: () => NEVER,
      resetOnComplete: () => NEVER,
      resetOnRefCountZero: () => NEVER,
    },
  ]) {
    describe(title, () => {
      it("should not reset on error if configured to do so", () => {
        rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
          const source = hot("---a---b---c---d---e---f----#")
          const expected = "  ---a---b---c---d---e---f----#"
          const sourceSubs = [
            "                 ^----------!                 ",
            "                 -----------^-----------!     ",
            "                 -----------------------^----!",
          ]
          const result = source.pipe(
            // takes a, b, c... then repeat causes it to take d, e, f
            take(3),
            share({ resetOnError }),
            repeat()
          )
          expectObservable(result).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
      })
      it("should not reset on complete if configured to do so", () => {
        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
          const source = cold("---a---b---c---#                          ")
          const expected = "   ---a---b---c------a---b---c------a---b---|"
          const sourceSubs = [
            "                  ^--------------!                          ",
            "                  ---------------^--------------!           ",
            "                  ------------------------------^----------!",
          ]
          // Used to trigger the source to complete at a given moment.
          const triggerComplete = new Subject<void>()
          // just used to count how many values have made it through the share.
          let count = 0
          const result = source.pipe(
            takeUntil(triggerComplete),
            share({ resetOnComplete }),
            // Retry on any error.
            retry(),
            tap(() => {
              if (++count === 9) {
                // If we see the ninth value, complete the source this time.
                triggerComplete.next()
              }
            })
          )
          expectObservable(result).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
      })
      it("should not reset on refCount 0 if configured to do so", () => {
        rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
          const source = hot(
            "  ---v---v---v---E--v---v---v---C---v----v------v---"
          )
          const expected =
            "    ---v---v---v------v---v---v-------v----v----      "
          const subscription =
            "^-------------------------------------------!     "
          const sourceSubs = [
            "                   ^--------------!",
            "                   ---------------^--------------!",
            // Note this last subscription never ends, because refCount hitting zero isn't going to reset.
            "                   ------------------------------^--------------     ",
          ]
          const result = source.pipe(
            tap(value => {
              if (value === "E") {
                throw new Error("E")
              }
            }),
            takeWhile(value => value !== "C"),
            share({ resetOnRefCountZero }),
            retry(),
            repeat()
          )
          expectObservable(result, subscription).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
      })
      it("should be referentially-transparent", () => {
        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
          const source1 = cold("-1-2-3-4-5-|")
          const source1Subs = " ^----------!"
          const expected1 = "   -1-2-3-4-5-|"
          const source2 = cold("-6-7-8-9-0-|")
          const source2Subs = " ^----------!"
          const expected2 = "   -6-7-8-9-0-|"
          // Calls to the _operator_ must be referentially-transparent.
          const partialPipeLine = pipe(share({ resetOnRefCountZero }))
          // The non-referentially-transparent sharing occurs within the _operator function_
          // returned by the _operator_ and that happens when the complete pipeline is composed.
          const shared1 = source1.pipe(partialPipeLine)
          const shared2 = source2.pipe(partialPipeLine)
          expectObservable(shared1).toBe(expected1)
          expectSubscriptions(source1.subscriptions).toBe(source1Subs)
          expectObservable(shared2).toBe(expected2)
          expectSubscriptions(source2.subscriptions).toBe(source2Subs)
        })
      })
    })
  }
  describe("share(config)", () => {
    it("should use the connector function provided", () => {
      const connector = spy(() => new Subject())
      rxTest.run(({ hot, expectObservable }) => {
        const source = hot(
          "  ---v---v---v---E--v---v---v---C---v----v--------v----v---"
        )
        const subs1 =
          "       ^-------------------------------------------!            "
        const expResult1 =
          "  ---v---v---v------v---v---v-------v----v-----            "
        const subs2 =
          "       ----------------------------------------------^---------!"
        const expResult2 =
          "  ------------------------------------------------v----v---"
        const result = source.pipe(
          tap(value => {
            if (value === "E") {
              throw new Error("E")
            }
          }),
          takeWhile(value => value !== "C"),
          share({
            connector,
          }),
          retry(),
          repeat()
        )
        expectObservable(result, subs1).toBe(expResult1)
        expectObservable(result, subs2).toBe(expResult2)
      })
      expect(connector).to.have.callCount(4)
    })
  })
  describe("share(config) with async/deferred reset notifiers", () => {
    it("should reset on refCount 0 when synchronously resubscribing to a firehose and using a sync reset notifier", () => {
      let subscriptionCount = 0
      const source = new Observable(subscriber => {
        subscriptionCount++
        for (let i = 0; i < 3 && !subscriber.closed; i++) {
          subscriber.next(i)
        }
        if (!subscriber.closed) {
          subscriber.complete()
        }
      })
      let result
      source
        .pipe(
          share({ resetOnRefCountZero: () => syncNotify }),
          take(2),
          repeat(2),
          toArray()
        )
        .subscribe(numbers => void (result = numbers))
      expect(subscriptionCount).to.equal(2)
      expect(result).to.deep.equal([0, 1, 0, 1])
    })
    it("should reset on refCount 0 when synchronously resubscribing and using a sync reset notifier", () => {
      rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
        const source = hot("  ---1---2---3---(4 )---5---|")
        const sourceSubs = [
          "                   ^------!                   ",
          // break the line, please
          "                   -------^-------(! )        ",
        ]
        const expected = "    ---1---2---3---(4|)        "
        const subscription = "^--------------(- )        "
        const sharedSource = source.pipe(
          share({ resetOnRefCountZero: () => syncNotify }),
          take(2)
        )
        const result = concat(sharedSource, sharedSource)
        expectObservable(result, subscription).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      })
    })
    it("should not reset on refCount 0 when synchronously resubscribing and using a deferred reset notifier", () => {
      rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
        const source = cold(" ---1---2---3---4---5---|")
        const sourceSubs = "  ^----------------------!"
        const expected = "    ---1---2---3---4---5---|"
        const subscription = "^-----------------------"
        const sharedSource = source.pipe(
          share({ resetOnRefCountZero: () => asapNotify }),
          take(3)
        )
        const result = concat(sharedSource, sharedSource)
        expectObservable(result, subscription).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      })
    })
    it("should reset on refCount 0 only after reset notifier emitted", () => {
      rxTest.run(({ hot, cold, expectObservable, expectSubscriptions }) => {
        const source = hot("      ---1---2---3---4---5---|")
        const sourceSubs = [
          "                       ^----------------!      ",
          // break the line, please
          "                       ------------------^----!",
        ]
        const expected = "        ---1---2---3---4---5---|"
        const subscription = "    ^-----------------------"
        const firstPause = cold("        -|               ")
        const reset = cold("             --r              ")
        const secondPause = cold("               ---|     ")
        // reset: '                              --r      '
        const sharedSource = source.pipe(
          share({ resetOnRefCountZero: () => reset }),
          take(2)
        )
        const result = concat(
          sharedSource,
          firstPause,
          sharedSource,
          secondPause,
          sharedSource
        )
        expectObservable(result, subscription).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      })
    })
    it("should reset on error only after reset notifier emitted", () => {
      rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
        const source = cold("     ---1---2---#                ")
        // source: '                            ---1---2---#  '
        const sourceSubs = [
          "                       ^----------!                ",
          // break the line, please
          "                       --------------^----------!  ",
        ]
        const expected = "        ---1---2---------1---2----# "
        const subscription = "    ^-------------------------- "
        const firstPause = cold("        -------|             ")
        const reset = cold("                 --r              ")
        const secondPause = cold("                     -----| ")
        // reset: '                                        --r'
        const sharedSource = source.pipe(
          share({ resetOnError: () => reset, resetOnRefCountZero: false }),
          take(2)
        )
        const result = concat(
          sharedSource,
          firstPause,
          sharedSource,
          secondPause,
          sharedSource
        )
        expectObservable(result, subscription).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      })
    })
    it("should reset on complete only after reset notifier emitted", () => {
      rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
        const source = cold("     ---1---2---|                ")
        // source: '                            ---1---2---|  '
        const sourceSubs = [
          "                       ^----------!                ",
          // break the line, please
          "                       --------------^----------!  ",
        ]
        const expected = "        ---1---2---------1---2----| "
        const subscription = "    ^-------------------------- "
        const firstPause = cold("        -------|             ")
        const reset = cold("                 --r              ")
        const secondPause = cold("                     -----| ")
        // reset: '                                        --r'
        const sharedSource = source.pipe(
          share({ resetOnComplete: () => reset, resetOnRefCountZero: false }),
          take(2)
        )
        const result = concat(
          sharedSource,
          firstPause,
          sharedSource,
          secondPause,
          sharedSource
        )
        expectObservable(result, subscription).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      })
    })
    it("should not reset on refCount 0 if reset notifier errors before emitting any value", () => {
      spyOnUnhandledError(onUnhandledError => {
        const error = new Error()
        rxTest.run(({ hot, cold, expectObservable, expectSubscriptions }) => {
          const source = hot("       ---1---2---3---4---(5 )---|")
          const sourceSubs = "       ^------------------(- )---!"
          const expected = "         ---1---2-------4---(5|)    "
          const subscription = "     ^------------------(- )    "
          const firstPause = cold("         ------|             ")
          const reset = cold(
            "              --#                 ",
            undefined,
            error
          )
          // reset: '                                   (- )-#  '
          const sharedSource = source.pipe(
            share({ resetOnRefCountZero: () => reset }),
            take(2)
          )
          const result = concat(sharedSource, firstPause, sharedSource)
          expectObservable(result, subscription).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
        expect(onUnhandledError).to.have.been.calledTwice
        expect(onUnhandledError.getCall(0)).to.have.been.calledWithExactly(
          error
        )
        expect(onUnhandledError.getCall(1)).to.have.been.calledWithExactly(
          error
        )
      })
    })
    it("should not reset on error if reset notifier errors before emitting any value", () => {
      spyOnUnhandledError(onUnhandledError => {
        const error = new Error()
        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
          const source = cold("    ---1---2---#   ")
          const sourceSubs = "     ^----------!   "
          const expected = "       ---1---2------#"
          const subscription = "   ^--------------"
          const firstPause = cold("       -------|")
          const reset = cold("                --# ", undefined, error)
          const sharedSource = source.pipe(
            share({ resetOnError: () => reset, resetOnRefCountZero: false }),
            take(2)
          )
          const result = concat(sharedSource, firstPause, sharedSource)
          expectObservable(result, subscription).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
        expect(onUnhandledError).to.have.been.calledOnce
        expect(onUnhandledError.getCall(0)).to.have.been.calledWithExactly(
          error
        )
      })
    })
    it("should not reset on complete if reset notifier errors before emitting any value", () => {
      spyOnUnhandledError(onUnhandledError => {
        const error = new Error()
        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
          const source = cold("    ---1---2---|   ")
          const sourceSubs = "     ^----------!   "
          const expected = "       ---1---2------|"
          const subscription = "   ^--------------"
          const firstPause = cold("       -------|")
          const reset = cold("                --# ", undefined, error)
          const sharedSource = source.pipe(
            share({ resetOnComplete: () => reset, resetOnRefCountZero: false }),
            take(2)
          )
          const result = concat(sharedSource, firstPause, sharedSource)
          expectObservable(result, subscription).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        })
        expect(onUnhandledError).to.have.been.calledOnce
        expect(onUnhandledError.getCall(0)).to.have.been.calledWithExactly(
          error
        )
      })
    })
    it('should not call "resetOnRefCountZero" on error', () => {
      rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
        const resetOnRefCountZero = spy(() => EMPTY)
        const source = cold("    ---1---(2#)                ")
        // source: '                           ---1---(2#)  '
        const sourceSubs = [
          "                      ^------(! )                ",
          // break the line, please
          "                      -------(- )---^------(! )  ",
        ]
        const expected = "       ---1---(2 )------1---(2#)  "
        const subscription = "   ^------(- )----------(- )  "
        const firstPause = cold("       (- )---|            ")
        const reset = cold("            (- )-r              ")
        // reset: '                                   (- )-r'
        const sharedSource = source.pipe(
          share({ resetOnError: () => reset, resetOnRefCountZero })
        )
        const result = concat(
          sharedSource.pipe(onErrorResumeNext(firstPause)),
          sharedSource
        )
        expectObservable(result, subscription).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expect(resetOnRefCountZero).to.not.have.been.called
      })
    })
    it('should not call "resetOnRefCountZero" on complete', () => {
      rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
        const resetOnRefCountZero = spy(() => EMPTY)
        const source = cold("    ---1---(2|)                ")
        // source: '                           ---1---(2|)  '
        const sourceSubs = [
          "                      ^------(! )                ",
          // break the line, please
          "                      -------(- )---^------(! )  ",
        ]
        const expected = "       ---1---(2 )------1---(2|)  "
        const subscription = "   ^------(- )----------(- )  "
        const firstPause = cold("       (- )---|            ")
        const reset = cold("            (- )-r              ")
        // reset: '                                   (- )-r'
        const sharedSource = source.pipe(
          share({ resetOnComplete: () => reset, resetOnRefCountZero })
        )
        const result = concat(sharedSource, firstPause, sharedSource)
        expectObservable(result, subscription).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expect(resetOnRefCountZero).to.not.have.been.called
      })
    })
  })
})
import { expect } from "chai"
import * as sinon from "sinon"
import { shareReplay, mergeMapTo, retry, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import {
  Observable,
  Operator,
  Observer,
  of,
  from,
  defer,
  pipe,
  combineLatest,
  firstValueFrom,
  BehaviorSubject,
} from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {shareReplay} */
describe("shareReplay", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should mirror a simple source Observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--1-2---3-4--5-|")
      const sourceSubs = " ^--------------!"
      const expected = "   --1-2---3-4--5-|"
      const published = source.pipe(shareReplay())
      expectObservable(published).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should do nothing if result is not subscribed", () => {
    let subscribed = false
    const source = new Observable(() => {
      subscribed = true
    })
    source.pipe(shareReplay())
    expect(subscribed).to.be.false
  })
  it("should multicast the same values to multiple observers, bufferSize=1", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-3----4-|")
        const sourceSubs = "     ^-----------!"
        const subscriber1 = hot("a|           ")
        const expected1 = "      -1-2-3----4-|"
        const subscriber2 = hot("----b|       ")
        const expected2 = "      ----23----4-|"
        const subscriber3 = hot("--------c|   ")
        const expected3 = "      --------3-4-|"
        const shared = source.pipe(shareReplay(1))
        expectObservable(subscriber1.pipe(mergeMapTo(shared))).toBe(expected1)
        expectObservable(subscriber2.pipe(mergeMapTo(shared))).toBe(expected2)
        expectObservable(subscriber3.pipe(mergeMapTo(shared))).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      }
    )
  })
  it("should multicast the same values to multiple observers, bufferSize=2", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-----3------4-|")
        const sourceSubs = "     ^-----------------!"
        const subscriber1 = hot("a|                 ")
        const expected1 = "      -1-2-----3------4-|"
        const subscriber2 = hot("----b|             ")
        const expected2 = "      ----(12)-3------4-|"
        const subscriber3 = hot("-----------c|      ")
        const expected3 = "      -----------(23)-4-|"
        const shared = source.pipe(shareReplay(2))
        expectObservable(subscriber1.pipe(mergeMapTo(shared))).toBe(expected1)
        expectObservable(subscriber2.pipe(mergeMapTo(shared))).toBe(expected2)
        expectObservable(subscriber3.pipe(mergeMapTo(shared))).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      }
    )
  })
  it("should multicast an error from the source to multiple observers", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-3----4-#")
        const sourceSubs = "     ^-----------!"
        const subscriber1 = hot("a|           ")
        const expected1 = "      -1-2-3----4-#"
        const subscriber2 = hot("----b|       ")
        const expected2 = "      ----23----4-#"
        const subscriber3 = hot("--------c|   ")
        const expected3 = "      --------3-4-#"
        const shared = source.pipe(shareReplay(1))
        expectObservable(subscriber1.pipe(mergeMapTo(shared))).toBe(expected1)
        expectObservable(subscriber2.pipe(mergeMapTo(shared))).toBe(expected2)
        expectObservable(subscriber3.pipe(mergeMapTo(shared))).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      }
    )
  })
  it("should multicast an empty source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("|   ")
      const sourceSubs = " (^!)"
      const expected = "   |   "
      const shared = source.pipe(shareReplay(1))
      expectObservable(shared).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should multicast a never source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("-")
      const sourceSubs = " ^"
      const expected = "   -"
      const shared = source.pipe(shareReplay(1))
      expectObservable(shared).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should multicast a throw source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("#   ")
      const sourceSubs = " (^!)"
      const expected = "   #   "
      const shared = source.pipe(shareReplay(1))
      expectObservable(shared).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should replay results to subsequent subscriptions if source completes, bufferSize=2", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-----3-|        ")
        const sourceSubs = "     ^----------!        "
        const subscriber1 = hot("a|                  ")
        const expected1 = "      -1-2-----3-|        "
        const subscriber2 = hot("----b|              ")
        const expected2 = "      ----(12)-3-|        "
        const subscriber3 = hot("---------------(c|) ")
        const expected3 = "      ---------------(23|)"
        const shared = source.pipe(shareReplay(2))
        expectObservable(subscriber1.pipe(mergeMapTo(shared))).toBe(expected1)
        expectObservable(subscriber2.pipe(mergeMapTo(shared))).toBe(expected2)
        expectObservable(subscriber3.pipe(mergeMapTo(shared))).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      }
    )
  })
  it("should completely restart for subsequent subscriptions if source errors, bufferSize=2", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const source = cold("    -1-2-----3-#               ")
        const sourceSubs1 = "    ^----------!               "
        const subscriber1 = hot("a|                         ")
        const expected1 = "      -1-2-----3-#               "
        const subscriber2 = hot("----b|                     ")
        const expected2 = "      ----(12)-3-#               "
        const subscriber3 = hot("---------------(c|)        ")
        const expected3 = "      ----------------1-2-----3-#"
        const sourceSubs2 = "    ---------------^----------!"
        const shared = source.pipe(shareReplay(2))
        expectObservable(subscriber1.pipe(mergeMapTo(shared))).toBe(expected1)
        expectObservable(subscriber2.pipe(mergeMapTo(shared))).toBe(expected2)
        expectObservable(subscriber3.pipe(mergeMapTo(shared))).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe([
          sourceSubs1,
          sourceSubs2,
        ])
      }
    )
  })
  it("should be retryable, bufferSize=2", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const subs = []
        const source = cold("    -1-2-----3-#                      ")
        subs.push("              ^----------!                      ")
        subs.push("              -----------^----------!           ")
        subs.push("              ----------------------^----------!")
        const subscriber1 = hot("a|                                ")
        const expected1 = "      -1-2-----3--1-2-----3-#           "
        const subscriber2 = hot("----b|                            ")
        const expected2 = "      ----(12)-3--1-2-----3-#           "
        const subscriber3 = hot("---------------(c|)               ")
        const expected3 = "      ---------------(12)-3--1-2-----3-#"
        const shared = source.pipe(shareReplay(2), retry(1))
        expectObservable(subscriber1.pipe(mergeMapTo(shared))).toBe(expected1)
        expectObservable(subscriber2.pipe(mergeMapTo(shared))).toBe(expected2)
        expectObservable(subscriber3.pipe(mergeMapTo(shared))).toBe(expected3)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  it("when no windowTime is given ReplaySubject should be in _infiniteTimeWindow mode", () => {
    const spy = sinon.spy(testScheduler, "now")
    of(1).pipe(shareReplay(1, undefined, testScheduler)).subscribe()
    spy.restore()
    expect(
      spy,
      "ReplaySubject should not call scheduler.now() when no windowTime is given"
    ).to.be.not.called
  })
  it("should not restart due to unsubscriptions if refCount is false", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("a-b-c-d-e-f-g-h-i-j")
      const sourceSubs = " ^------------------"
      const sub1 = "       ^------!           "
      const expected1 = "  a-b-c-d-           "
      const sub2 = "       -----------^-------"
      const expected2 = "  -----------fg-h-i-j"
      const shared = source.pipe(
        shareReplay({ bufferSize: 1, refCount: false })
      )
      expectObservable(shared, sub1).toBe(expected1)
      expectObservable(shared, sub2).toBe(expected2)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should restart due to unsubscriptions if refCount is true", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const sourceSubs = []
      const source = cold("a-b-c-d-e-f-g-h-i-j           ")
      sourceSubs.push("    ^------!----------------------")
      sourceSubs.push("    -----------^------------------")
      const sub1 = "       ^------!                      "
      const expected1 = "  a-b-c-d-                      "
      const sub2 = "       -----------^------------------"
      const expected2 = "  -----------a-b-c-d-e-f-g-h-i-j"
      const shared = source.pipe(shareReplay({ bufferSize: 1, refCount: true }))
      expectObservable(shared, sub1).toBe(expected1)
      expectObservable(shared, sub2).toBe(expected2)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should not restart due to unsubscriptions if refCount is true when the source has completed", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("a-(b|)         ")
      const sourceSubs = " ^-!            "
      const sub1 = "       ^------!       "
      const expected1 = "  a-(b|)         "
      const sub2 = "       -----------^!  "
      const expected2 = "  -----------(b|)"
      const shared = source.pipe(shareReplay({ bufferSize: 1, refCount: true }))
      expectObservable(shared, sub1).toBe(expected1)
      expectObservable(shared, sub2).toBe(expected2)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should not restart a synchronous source due to unsubscriptions if refCount is true when the source has completed", () => {
    // The test above this one doesn't actually test completely synchronous
    // behaviour because of this problem:
    // https://github.com/ReactiveX/rxjs/issues/5523
    let subscriptions = 0
    const source = defer(() => {
      ++subscriptions
      return of(42)
    }).pipe(shareReplay({ bufferSize: 1, refCount: true }))
    source.subscribe()
    source.subscribe()
    expect(subscriptions).to.equal(1)
  })
  it("should only subscribe once each with multiple synchronous subscriptions and unsubscriptions ", async () => {
    // This may seem very specific, but it's a regression test for https://github.com/ReactiveX/rxjs/issues/6760
    let subscriptions = 0
    const source = defer(() => {
      ++subscriptions
      // Needs to be an observable that doesn't complete
      return new BehaviorSubject(1)
    }).pipe(shareReplay({ bufferSize: 1, refCount: true }))
    await firstValueFrom(combineLatest([source, source]))
    expect(subscriptions).to.equal(1)
  })
  it("should default to refCount being false", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("a-b-c-d-e-f-g-h-i-j")
      const sourceSubs = " ^------------------"
      const sub1 = "       ^------!           "
      const expected1 = "  a-b-c-d-           "
      const sub2 = "       -----------^-------"
      const expected2 = "  -----------fg-h-i-j"
      const shared = source.pipe(shareReplay(1))
      expectObservable(shared, sub1).toBe(expected1)
      expectObservable(shared, sub2).toBe(expected2)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should not break lift() composability", done => {
    class MyCustomObservable<T> extends Observable<T> {
      lift<R>(operator: Operator<T, R>): Observable<R> {
        const observable = new MyCustomObservable<R>()
        ;(<any>observable).source = this
        ;(<any>observable).operator = operator
        return observable
      }
    }
    const result = new MyCustomObservable((observer: Observer<number>) => {
      observer.next(1)
      observer.next(2)
      observer.next(3)
      observer.complete()
    }).pipe(shareReplay())
    expect(result instanceof MyCustomObservable).to.be.true
    const expected = [1, 2, 3]
    result.subscribe({
      next(n: any) {
        expect(expected.length).to.be.greaterThan(0)
        expect(n).to.equal(expected.shift())
      },
      error() {
        done(new Error("should not be called"))
      },
      complete() {
        done()
      },
    })
  })
  it("should not skip values on a sync source", () => {
    testScheduler.run(({ cold, expectObservable }) => {
      const a = from(["a", "b", "c", "d"])
      // We would like for the previous line to read like this:
      //
      // const a = cold('(abcd|)');
      //
      // However, that would synchronously emit multiple values at frame 0,
      // but it's not synchronous upon-subscription.
      // TODO: revisit once https://github.com/ReactiveX/rxjs/issues/5523 is fixed
      const x = cold("  x-------x")
      const expected = "(abcd)--d"
      const shared = a.pipe(shareReplay(1))
      const result = x.pipe(mergeMapTo(shared))
      expectObservable(result).toBe(expected)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(shareReplay({ refCount: true }), take(3))
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
  const FinalizationRegistry = (global as any).FinalizationRegistry
  if (FinalizationRegistry && global.gc) {
    it("should not leak the subscriber for sync sources", done => {
      let callback: (() => void) | undefined = () => {
        /* noop */
      }
      const registry = new FinalizationRegistry((value: any) => {
        expect(value).to.equal("callback")
        done()
      })
      registry.register(callback, "callback")
      const shared = of(42).pipe(shareReplay(1))
      shared.subscribe(callback)
      callback = undefined
      global.gc?.()
    })
  } else {
    console.warn(
      `No support for FinalizationRegistry in Node ${process.version}`
    )
  }
  it("should be referentially-transparent", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source1 = cold("-1-2-3-4-5-|")
      const source1Subs = " ^----------!"
      const expected1 = "   -1-2-3-4-5-|"
      const source2 = cold("-6-7-8-9-0-|")
      const source2Subs = " ^----------!"
      const expected2 = "   -6-7-8-9-0-|"
      // Calls to the _operator_ must be referentially-transparent.
      const partialPipeLine = pipe(shareReplay({ refCount: false }))
      // The non-referentially-transparent sharing occurs within the _operator function_
      // returned by the _operator_ and that happens when the complete pipeline is composed.
      const shared1 = source1.pipe(partialPipeLine)
      const shared2 = source2.pipe(partialPipeLine)
      expectObservable(shared1).toBe(expected1)
      expectSubscriptions(source1.subscriptions).toBe(source1Subs)
      expectObservable(shared2).toBe(expected2)
      expectSubscriptions(source2.subscriptions).toBe(source2Subs)
    })
  })
})
import { expect } from "chai"
import { single, mergeMap, tap } from "rxjs/operators"
import { of, EmptyError, SequenceError, NotFoundError, Observable } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {single} */
describe("single operator", () => {
  let rxTest: TestScheduler
  beforeEach(() => {
    rxTest = new TestScheduler(observableMatcher)
  })
  it("should raise error from empty predicate if observable emits multiple time", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^----!      "
      const expected = "-----#      "
      expectObservable(e1.pipe(single())).toBe(
        expected,
        null,
        new SequenceError("Too many matching values")
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error from empty predicate if observable does not emit", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--|")
      const e1subs = "     ^--!"
      const expected = "   ---#"
      expectObservable(e1.pipe(single())).toBe(expected, null, new EmptyError())
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return only element from empty predicate if observable emits only once", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--|")
      const e1subs = "  ^----!"
      const expected = "-----(a|)"
      expectObservable(e1.pipe(single())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const unsub = "   ----!        "
      const e1subs = "  ^---!        "
      const expected = "------------"
      expectObservable(e1.pipe(single()), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^--!        "
      const expected = "----        "
      const unsub = "   ---!        "
      const result = e1.pipe(
        mergeMap(x => of(x)),
        single(),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error from empty predicate if observable emits error", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b^--#")
      const e1subs = "        ^--!"
      const expected = "      ---#"
      expectObservable(e1.pipe(single())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error from predicate if observable emits error", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--b^--#")
      const e1subs = "      ^--!"
      const expected = "    ---#"
      expectObservable(e1.pipe(single(v => v === "c"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if predicate throws error", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--|")
      const e1subs = "  ^----------!   "
      const expected = "-----------#   "
      expectObservable(
        e1.pipe(
          single(v => {
            if (v !== "d") {
              return false
            }
            throw "error"
          })
        )
      ).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should return element from predicate if observable have single matching element", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^----------!"
      const expected = "-----------(b|)"
      expectObservable(e1.pipe(single(v => v === "b"))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error from predicate if observable have multiple matching element", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--a--b--b--|")
      const e1subs = "  ^----------!      "
      const expected = "-----------#      "
      expectObservable(e1.pipe(single(v => v === "b"))).toBe(
        expected,
        null,
        new SequenceError("Too many matching values")
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error from predicate if observable does not emit", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--|")
      const e1subs = "     ^--!"
      const expected = "   ---#"
      expectObservable(e1.pipe(single(v => v === "a"))).toBe(
        expected,
        null,
        new EmptyError()
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error from predicate if observable does not contain matching element", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^----------!"
      const expected = "-----------#"
      expectObservable(e1.pipe(single(v => v === "x"))).toBe(
        expected,
        undefined,
        new NotFoundError("No matching values")
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should call predicate with indices starting at 0", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--|")
      const e1subs = "  ^----------!"
      const expected = "-----------(b|)"
      let indices: number[] = []
      const predicate = function (value: string, index: number) {
        indices.push(index)
        return value === "b"
      }
      expectObservable(
        e1.pipe(
          single(predicate),
          tap({
            complete: () => {
              expect(indices).to.deep.equal([0, 1, 2])
            },
          })
        )
      ).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should error for synchronous empty observables when no arguments are provided", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("|")
      const expected = "   #"
      const subs = ["      (^!)"]
      const result = source.pipe(single())
      expectObservable(result).toBe(expected, undefined, new EmptyError())
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should error for async empty observables when no arguments are provided", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("-------|")
      const expected = "   -------#"
      const subs = ["      ^------!"]
      const result = source.pipe(single())
      expectObservable(result).toBe(expected, undefined, new EmptyError())
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should error for hot observables that do not emit while active when no arguments are provided", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b--^----|")
      const expected = "          -----#"
      const subs = ["             ^----!"]
      const result = source.pipe(single())
      expectObservable(result).toBe(expected, undefined, new EmptyError())
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should error for synchronous empty observables when predicate never passes", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("|")
      const expected = "   #"
      const subs = ["      (^!)"]
      const result = source.pipe(single(() => false))
      expectObservable(result).toBe(expected, undefined, new EmptyError())
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should error for async empty observables when predicate never passes", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("-------|")
      const expected = "   -------#"
      const subs = ["      ^------!"]
      const result = source.pipe(single(() => false))
      expectObservable(result).toBe(expected, undefined, new EmptyError())
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should error for hot observables that do not emit while active when predicate never passes", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b--^----|")
      const expected = "          -----#"
      const subs = ["             ^----!"]
      const result = source.pipe(single(() => false))
      expectObservable(result).toBe(expected, undefined, new EmptyError())
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should error for synchronous observables that emit when predicate never passes", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("(a|)")
      const expected = "   #"
      const subs = ["      (^!)"]
      const result = source.pipe(single(() => false))
      expectObservable(result).toBe(
        expected,
        undefined,
        new NotFoundError("No matching values")
      )
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should error for async observables that emit when predicate never passes", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--a--b-|")
      const expected = "   -------#"
      const subs = ["      ^------!"]
      const result = source.pipe(single(() => false))
      expectObservable(result).toBe(
        expected,
        undefined,
        new NotFoundError("No matching values")
      )
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should error for hot observables that emit while active when predicate never passes", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b--^--c--d--|")
      const expected = "          ---------#"
      const subs = ["             ^--------!"]
      const result = source.pipe(single(() => false))
      expectObservable(result).toBe(
        expected,
        undefined,
        new NotFoundError("No matching values")
      )
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should error for synchronous observables when the predicate passes more than once", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("(axbxc|)")
      const expected = "   #"
      const subs = ["      (^!)"]
      const result = source.pipe(single(v => v === "x"))
      expectObservable(result).toBe(
        expected,
        undefined,
        new SequenceError("Too many matching values")
      )
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should error for async observables that emit when the predicate passes more than once", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--a-x-b-x-c-|")
      const expected = "   --------#"
      const subs = ["      ^-------!"]
      const result = source.pipe(single(v => v === "x"))
      expectObservable(result).toBe(
        expected,
        undefined,
        new SequenceError("Too many matching values")
      )
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should error for hot observables that emit while active when the predicate passes more than once", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b--^--c--x--d--x--|")
      const expected = "          ------------#"
      const subs = ["             ^-----------!"]
      const result = source.pipe(single(v => v === "x"))
      expectObservable(result).toBe(
        expected,
        undefined,
        new SequenceError("Too many matching values")
      )
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits, it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(single()).subscribe({
      next: () => {
        /* noop */
      },
      error: () => {
        /* noop */
      },
    })
    expect(sideEffects).to.deep.equal([0, 1])
  })
})
import { expect } from "chai"
import { skip, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
import { of, Observable } from "rxjs"
/** @test {skip} */
describe("skip", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should skip values before a total", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b--c--d--e--|")
      const subs = "      ^----------------!"
      const expected = "  -----------d--e--|"
      expectObservable(source.pipe(skip(3))).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should skip all values without error if total is more than actual number of values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b--c--d--e--|")
      const subs = "      ^----------------!"
      const expected = "  -----------------|"
      expectObservable(source.pipe(skip(6))).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should skip all values without error if total is same as actual number of values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b--c--d--e--|")
      const subs = "      ^----------------!"
      const expected = "  -----------------|"
      expectObservable(source.pipe(skip(5))).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should not skip if count is zero", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b--c--d--e--|")
      const subs = "      ^----------------!"
      const expected = "  --a--b--c--d--e--|"
      expectObservable(source.pipe(skip(0))).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should not skip if count is negative value", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("--a--b--c--d--e--|")
      const subs = "       ^----------------!"
      const expected = "   --a--b--c--d--e--|"
      expectObservable(source.pipe(skip(-42))).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b--c--d--e--|")
      const unsub = "     ----------!       "
      const subs = "      ^---------!       "
      const expected = "  --------c--       "
      expectObservable(source.pipe(skip(2)), unsub).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b--c--d--e--|")
      const subs = "      ^---------!       "
      const expected = "  --------c--       "
      const unsub = "     ----------!       "
      const result = source.pipe(
        mergeMap((x: string) => of(x)),
        skip(2),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should raise error if skip count is more than actual number of emits and source raises error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b--c--d--#")
      const subs = "      ^-------------!"
      const expected = "  --------------#"
      expectObservable(source.pipe(skip(6))).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should raise error if skip count is same as emits of source and source raises error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b--c--d--#")
      const subs = "      ^-------------!"
      const expected = "  --------------#"
      expectObservable(source.pipe(skip(4))).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should skip values before a total and raises error if source raises error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b--c--d--#")
      const subs = "      ^-------------!"
      const expected = "  -----------d--#"
      expectObservable(source.pipe(skip(3))).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should complete regardless of skip count if source is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |")
      const e1subs = "  (^!)"
      const expected = "|"
      expectObservable(e1.pipe(skip(3))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not complete if source never completes without emit", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(skip(3))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should skip values before total and never completes if source emits and does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c-")
      const e1subs = "  ^         "
      const expected = "-----b--c-"
      expectObservable(e1.pipe(skip(1))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should skip all values and never completes if total is more than numbers of value and source does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c-")
      const e1subs = "  ^         "
      const expected = "----------"
      expectObservable(e1.pipe(skip(6))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should skip all values and never completes if total is same asnumbers of value and source does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c-")
      const e1subs = "  ^         "
      const expected = "----------"
      expectObservable(e1.pipe(skip(3))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if source throws", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #")
      const e1subs = "  (^!)"
      const expected = "#"
      expectObservable(e1.pipe(skip(3))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(skip(1), take(2)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { skipLast, mergeMap, take } from "rxjs/operators"
import { of, Observable } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {skipLast} */
describe("skipLast operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should skip two values of an observable with many values", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a-----b----c---d--|")
      const e1subs = "  ^-------------------!"
      const expected = "-------------a---b--|"
      expectObservable(e1.pipe(skipLast(2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should skip last three values", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a-----b----c---d--|")
      const e1subs = "  ^-------------------!"
      const expected = "-----------------a--|"
      expectObservable(e1.pipe(skipLast(3))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should skip all elements when trying to skip larger then source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a-----b----c---d--|")
      const e1subs = "  ^-------------------!"
      const expected = "--------------------|"
      expectObservable(e1.pipe(skipLast(5))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should skip all elements when trying to skip exact", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a-----b----c---d--|")
      const e1subs = "  ^-------------------!"
      const expected = "--------------------|"
      expectObservable(e1.pipe(skipLast(4))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not skip any values", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a-----b----c---d--|")
      const e1subs = "  ^-------------------!"
      const expected = "--a-----b----c---d--|"
      expectObservable(e1.pipe(skipLast(0))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not skip any values if provided with negative value", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a-----b----c---d--|")
      const e1subs = "  ^-------------------!"
      const expected = "--a-----b----c---d--|"
      expectObservable(e1.pipe(skipLast(-42))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work with empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |")
      const e1subs = "  (^!)"
      const expected = "|"
      expectObservable(e1.pipe(skipLast(42))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should go on forever on never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(skipLast(42))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should skip one value from an observable with one value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---(a|)")
      const e1subs = "  ^--!   "
      const expected = "---|   "
      expectObservable(e1.pipe(skipLast(1))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should skip one value from an observable with many values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b----c---d--|")
      const e1subs = "     ^--------------!"
      const expected = "   --------b---c--|"
      expectObservable(e1.pipe(skipLast(1))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work with empty and early emission", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^----|")
      const e1subs = "     ^----!"
      const expected = "   -----|"
      expectObservable(e1.pipe(skipLast(42))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should propagate error from the source observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^---#", undefined, "too bad")
      const e1subs = "   ^---!"
      const expected = " ----#"
      expectObservable(e1.pipe(skipLast(42))).toBe(expected, null, "too bad")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should propagate error from an observable with values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^--a--b--#")
      const e1subs = "   ^--------!"
      const expected = " ---------#"
      expectObservable(e1.pipe(skipLast(42))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^--a--b-----c--d--e--|")
      const unsub = "    ---------!            "
      const e1subs = "   ^--------!            "
      const expected = " ----------            "
      expectObservable(e1.pipe(skipLast(42)), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work with throw", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #")
      const e1subs = "  (^!)"
      const expected = "#"
      expectObservable(e1.pipe(skipLast(42))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chain when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^--a--b-----c--d--e--|")
      const unsub = "    ---------!            "
      const e1subs = "   ^--------!            "
      const expected = " ----------            "
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        skipLast(42),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(skipLast(1), take(3)).subscribe(() => {
      /* noop */
    })
    // This expectation might seem a little strange, but the implementation of
    // skipLast works by eating the number of elements that are to be skipped,
    // so it will consume the number skipped in addition to the number taken.
    expect(sideEffects).to.deep.equal([0, 1, 2, 3])
  })
})
import { expect } from "chai"
import { concat, defer, of, Subject, Observable } from "rxjs"
import { skipUntil, mergeMap, take } from "rxjs/operators"
import { asInteropObservable } from "../helpers/interop-helper"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {skipUntil} */
describe("skipUntil", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should skip values until another observable notifies", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("    --a--b--c--d--e----|")
      const e1subs = "    ^------------------!"
      const skip = hot("  ---------x------|   ")
      const skipSubs = "  ^--------!          "
      const expected = "  -----------d--e----|"
      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(skip.subscriptions).toBe(skipSubs)
    })
  })
  it("should emit elements after notifier emits", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("    --a--b--c--d--e--|")
      const e1subs = "    ^----------------!"
      const skip = hot("  ---------x----|   ")
      const skipSubs = "  ^--------!        "
      const expected = "  -----------d--e--|"
      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(skip.subscriptions).toBe(skipSubs)
    })
  })
  it("should emit elements after a synchronous notifier emits", () => {
    const values: string[] = []
    of("a", "b")
      .pipe(skipUntil(of("x")))
      .subscribe({
        next(value) {
          values.push(value)
        },
        error(err) {
          throw err
        },
        complete() {
          expect(values).to.deep.equal(["a", "b"])
        },
      })
  })
  it("should raise an error if notifier throws and source is hot", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--|")
      const e1subs = "  ^------------!    "
      const skip = hot("-------------#    ")
      const skipSubs = "^------------!    "
      const expected = "-------------#    "
      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(skip.subscriptions).toBe(skipSubs)
    })
  })
  it("should skip all elements when notifier does not emit and completes early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--|")
      const e1subs = "  ^----------------!"
      const skip = hot("------------|     ")
      const skipSubs = "^-----------!     "
      const expected = "-----------------|"
      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(skip.subscriptions).toBe(skipSubs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("    --a--b--c--d--e----|")
      const unsub = "     ---------!          "
      const e1subs = "    ^--------!          "
      const skip = hot("  -------------x--|   ")
      const skipSubs = "  ^--------!          "
      const expected = "  ----------          "
      expectObservable(e1.pipe(skipUntil(skip)), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(skip.subscriptions).toBe(skipSubs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("    --a--b--c--d--e----|")
      const e1subs = "    ^--------!          "
      const skip = hot("  -------------x--|   ")
      const skipSubs = "  ^--------!          "
      const expected = "  ----------          "
      const unsub = "     ---------!          "
      const result = e1.pipe(
        mergeMap(x => of(x)),
        skipUntil(skip),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(skip.subscriptions).toBe(skipSubs)
    })
  })
  it("should not break unsubscription chains with interop inners when result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("    --a--b--c--d--e----|")
      const e1subs = "    ^--------!          "
      const skip = hot("  -------------x--|   ")
      const skipSubs = "  ^--------!          "
      const expected = "  ----------          "
      const unsub = "     ---------!          "
      // This test is the same as the previous test, but the observable is
      // manipulated to make it look like an interop observable - an observable
      // from a foreign library. Interop subscribers are treated differently:
      // they are wrapped in a safe subscriber. This test ensures that
      // unsubscriptions are chained all the way to the interop subscriber.
      const result = e1.pipe(
        mergeMap(x => of(x)),
        skipUntil(asInteropObservable(skip)),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(skip.subscriptions).toBe(skipSubs)
    })
  })
  it("should skip all elements when notifier is empty", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("   --a--b--c--d--e--|")
        const e1subs = "   ^----------------!"
        const skip = cold("|                 ")
        const skipSubs = " (^!)              "
        const expected = " -----------------|"
        expectObservable(e1.pipe(skipUntil(skip))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(skip.subscriptions).toBe(skipSubs)
      }
    )
  })
  it("should keep subscription to source, to wait for its eventual completion", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ------------------------------|")
      const e1subs = "  ^-----------------------------!"
      const skip = hot("-------|                       ")
      const skipSubs = "^------!                       "
      const expected = "------------------------------|"
      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(skip.subscriptions).toBe(skipSubs)
    })
  })
  it("should not complete if hot source observable does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -                ")
      const e1subs = "  ^                "
      const skip = hot("-------------x--|")
      const skipSubs = "^------------!   "
      const expected = "-                "
      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(skip.subscriptions).toBe(skipSubs)
    })
  })
  it("should not complete if cold source observable never completes", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" -                ")
        const e1subs = "  ^                "
        const skip = hot("-------------x--|")
        const skipSubs = "^------------!   "
        const expected = "-                "
        expectObservable(e1.pipe(skipUntil(skip))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(skip.subscriptions).toBe(skipSubs)
      }
    )
  })
  it("should raise error if cold source is never and notifier errors", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" -             ")
        const e1subs = "  ^------------!"
        const skip = hot("-------------#")
        const skipSubs = "^------------!"
        const expected = "-------------#"
        expectObservable(e1.pipe(skipUntil(skip))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(skip.subscriptions).toBe(skipSubs)
      }
    )
  })
  it("should skip all elements and complete if notifier is cold never", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("   --a--b--c--d--e--|")
        const e1subs = "   ^----------------!"
        const skip = cold("-                 ")
        const skipSubs = " ^----------------!"
        const expected = " -----------------|"
        expectObservable(e1.pipe(skipUntil(skip))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(skip.subscriptions).toBe(skipSubs)
      }
    )
  })
  it("should skip all elements and complete if notifier is a hot never", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--|")
      const e1subs = "  ^----------------!"
      const skip = hot("-                 ")
      const skipSubs = "^----------------!"
      const expected = "-----------------|"
      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(skip.subscriptions).toBe(skipSubs)
    })
  })
  it("should skip all elements and complete, even if notifier would not complete until later", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ^-a--b--c--d--e--|       ")
      const e1subs = "  ^----------------!       "
      const skip = hot("^-----------------------|")
      const skipSubs = "^----------------!       "
      const expected = "-----------------|       "
      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(skip.subscriptions).toBe(skipSubs)
    })
  })
  it("should not complete if source does not complete if notifier completes without emission", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -              ")
      const e1subs = "  ^              "
      const skip = hot("--------------|")
      const skipSubs = "^-------------!"
      const expected = "-              "
      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(skip.subscriptions).toBe(skipSubs)
    })
  })
  it("should not complete if source and notifier are both hot never", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -")
      const e1subs = "  ^"
      const skip = hot("-")
      const skipSubs = "^"
      const expected = "-"
      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(skip.subscriptions).toBe(skipSubs)
    })
  })
  it("should skip skip all elements if notifier is unsubscribed explicitly before the notifier emits", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--|")
      const e1subs = [
        "               ^----------------!",
        "               ^----------------!", // for the explicit subscribe some lines below
      ]
      const skip = new Subject<string>()
      const expected = "-----------------|"
      e1.subscribe((x: string) => {
        if (x === "d" && !skip.closed) {
          skip.next("x")
        }
        skip.unsubscribe()
      })
      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should unsubscribe the notifier after its first nexted value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("  -^-o---o---o---o---o---o---|")
      const notifier = hot("-^--------n--n--n--n--n--n-|")
      const nSubs = "        ^--------!                 "
      const expected = "    -^---------o---o---o---o---|"
      const result = source.pipe(skipUntil(notifier))
      expectObservable(result).toBe(expected)
      expectSubscriptions(notifier.subscriptions).toBe(nSubs)
    })
  })
  it("should stop listening to a synchronous notifier after its first nexted value", () => {
    const sideEffects: number[] = []
    const synchronousNotifer = concat(
      defer(() => {
        sideEffects.push(1)
        return of(1)
      }),
      defer(() => {
        sideEffects.push(2)
        return of(2)
      }),
      defer(() => {
        sideEffects.push(3)
        return of(3)
      })
    )
    of(null)
      .pipe(skipUntil(synchronousNotifer))
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([1])
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(skipUntil(of(0)), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { skipWhile, mergeMap, tap, take } from "rxjs/operators"
import { of, Observable } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {skipWhile} */
describe("skipWhile", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should skip all elements until predicate is false", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("-1-^2--3--4--5--6--|")
      const sourceSubs = "   ^---------------!"
      const expected = "     -------4--5--6--|"
      const predicate = function (v: string) {
        return +v < 4
      }
      const result = source.pipe(skipWhile(predicate))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should skip all elements with a true predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("-1-^2--3--4--5--6--|")
      const sourceSubs = "   ^---------------!"
      const expected = "     ----------------|"
      const result = source.pipe(skipWhile(() => true))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should skip all elements with a truthy predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("-1-^2--3--4--5--6--|")
      const sourceSubs = "   ^---------------!"
      const expected = "     ----------------|"
      const result = source.pipe(
        skipWhile((): any => {
          return {}
        })
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should not skip any element with a false predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("-1-^2--3--4--5--6--|")
      const sourceSubs = "   ^---------------!"
      const expected = "     -2--3--4--5--6--|"
      const result = source.pipe(skipWhile(() => false))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should not skip any elements with a falsy predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("-1-^2--3--4--5--6--|")
      const sourceSubs = "   ^---------------!"
      const expected = "     -2--3--4--5--6--|"
      const result = source.pipe(skipWhile(() => undefined as any))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should skip elements on hot source", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--1--2-^-3--4--5--6--7--8--")
      const sourceSubs = "       ^-------------------"
      const expected = "         --------5--6--7--8--"
      const predicate = function (v: string) {
        return +v < 5
      }
      const result = source.pipe(skipWhile(predicate))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should be possible to skip using the element's index", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b-^-c--d--e--f--g--h--|")
      const sourceSubs = "       ^-------------------!"
      const expected = "         --------e--f--g--h--|"
      const predicate = function (_v: string, index: number) {
        return index < 2
      }
      const result = source.pipe(skipWhile(predicate))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should skip using index with source unsubscribes early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b-^-c--d--e--f--g--h--|")
      const sourceSubs = "       ^----------!         "
      const unsub = "            -----------!         "
      const expected = "         -----d--e---         "
      const predicate = function (_v: string, index: number) {
        return index < 1
      }
      const result = source.pipe(skipWhile(predicate))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b-^-c--d--e--f--g--h--|")
      const sourceSubs = "       ^----------!         "
      const expected = "         -----d--e---         "
      const unsub = "            -----------!         "
      const predicate = function (_v: string, index: number) {
        return index < 1
      }
      const result = source.pipe(
        mergeMap(function (x) {
          return of(x)
        }),
        skipWhile(predicate),
        mergeMap(function (x) {
          return of(x)
        })
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should skip using value with source throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b-^-c--d--e--f--g--h--#")
      const sourceSubs = "       ^-------------------!"
      const expected = "         -----d--e--f--g--h--#"
      const predicate = function (v: string) {
        return v !== "d"
      }
      const result = source.pipe(skipWhile(predicate))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should invoke predicate while its false and never again", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b-^-c--d--e--f--g--h--|")
      const sourceSubs = "       ^-------------------!"
      const expected = "         --------e--f--g--h--|"
      let invoked = 0
      const predicate = function (v: string) {
        invoked++
        return v !== "e"
      }
      const result = source.pipe(
        skipWhile(predicate),
        tap({
          complete() {
            expect(invoked).to.equal(3)
          },
        })
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should handle predicate that throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const source = hot("--a--b-^-c--d--e--f--g--h--|")
      const sourceSubs = "       ^-------!            "
      const expected = "         --------#            "
      const predicate = function (v: string) {
        if (v === "e") {
          throw new Error("nom d'une pipe !")
        }
        return v !== "f"
      }
      const result = source.pipe(skipWhile(predicate))
      expectObservable(result).toBe(
        expected,
        undefined,
        new Error("nom d'une pipe !")
      )
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
    })
  })
  it("should handle Observable.empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("|   ")
      const subs = "       (^!)"
      const expected = "   |   "
      const result = source.pipe(skipWhile(() => true))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should handle Observable.never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("-")
      const subs = "       ^"
      const expected = "   -"
      const result = source.pipe(skipWhile(() => true))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should handle Observable.throw", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("#   ")
      const subs = "       (^!)"
      const expected = "   #   "
      const result = source.pipe(skipWhile(() => true))
      expectObservable(result).toBe(expected)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        skipWhile(value => value < 2),
        take(1)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { startWith, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of, Observable } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {startWith} */
describe("startWith", () => {
  const defaultStartValue = "x"
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should prepend to a cold Observable", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" ---a--b--c--|")
      const e1subs = "  ^-----------!"
      const expected = "s--a--b--c--|"
      const result = e1.pipe(startWith("s"))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should start an observable with given value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--|")
      const e1subs = "  ^----!"
      const expected = "x-a--|"
      const result = e1.pipe(startWith(defaultStartValue))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should start with given value and does not completes if source does not completes", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----a-")
      const e1subs = "  ^-----"
      const expected = "x---a-"
      const result = e1.pipe(startWith(defaultStartValue))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should start with given value and does not completes if source never emits", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" - ")
      const e1subs = "  ^ "
      const expected = "x-"
      const result = e1.pipe(startWith(defaultStartValue))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should start with given value and completes if source does not emits", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---|")
      const e1subs = "  ^--!"
      const expected = "x--|"
      const result = e1.pipe(startWith(defaultStartValue))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should start with given value and complete immediately if source is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "(x|)"
      const result = e1.pipe(startWith(defaultStartValue))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should start with given value and source both if source emits single value", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" (a|)")
      const e1subs = "  (^!)"
      const expected = "(xa|)"
      const result = e1.pipe(startWith(defaultStartValue))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should start with given values when given value is more than one", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -----a--|")
      const e1subs = "  ^-------!"
      const expected = "(yz)-a--|"
      const result = e1.pipe(startWith("y", "z"))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should start with given value and raises error if source raises error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --#")
      const e1subs = "  ^-!"
      const expected = "x-#"
      const result = e1.pipe(startWith(defaultStartValue))
      expectObservable(result).toBe(expected, defaultStartValue)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should start with given value and raises error immediately if source throws error", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "(x#)"
      const result = e1.pipe(startWith(defaultStartValue))
      expectObservable(result).toBe(expected, defaultStartValue)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---a--b----c--d--|")
      const unsub = "   ---------!        "
      const e1subs = "  ^--------!        "
      const expected = "s--a--b---        "
      const values = { s: "s", a: "a", b: "b" }
      const result = e1.pipe(startWith("s", testScheduler))
      expectObservable(result, unsub).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---a--b----c--d--|")
      const e1subs = "  ^--------!        "
      const expected = "s--a--b---        "
      const unsub = "   ---------!        "
      const values = { s: "s", a: "a", b: "b" }
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        startWith("s", testScheduler),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should start with empty if given value is not specified", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -a-|")
      const e1subs = "  ^--!"
      const expected = "-a-|"
      const result = e1.pipe(startWith(testScheduler))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should accept scheduler as last argument with single value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--|")
      const e1subs = "  ^----!"
      const expected = "x-a--|"
      const result = e1.pipe(startWith(defaultStartValue, testScheduler))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should accept scheduler as last argument with multiple value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -----a--|")
      const e1subs = "  ^-------!"
      const expected = "(yz)-a--|"
      const result = e1.pipe(startWith("y", "z", testScheduler))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(startWith(-1), take(4)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { subscribeOn, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of, Observable, queueScheduler } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {subscribeOn} */
describe("subscribeOn", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should subscribe on specified scheduler", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--|")
      const expected = "--a--b--|"
      const sub = "     ^-------!"
      const result = e1.pipe(subscribeOn(testScheduler))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(sub)
    })
  })
  it("should start subscribe after specified delay", () => {
    testScheduler.run(
      ({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("    --a--b--|")
        const expected = "  -----b--|"
        const delay = time("---|     ")
        const sub = "       ---^----!"
        const result = e1.pipe(subscribeOn(testScheduler, delay))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(sub)
      }
    )
  })
  it("should unsubscribe when source raises error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--#")
      const expected = "--a--#"
      const sub = "     ^----!"
      const result = e1.pipe(subscribeOn(testScheduler))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(sub)
    })
  })
  it("should subscribe when source is empty", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----|")
      const expected = "----|"
      const sub = "     ^---!"
      const result = e1.pipe(subscribeOn(testScheduler))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(sub)
    })
  })
  it("should subscribe when source does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----")
      const expected = "----"
      const sub = "     ^---"
      const result = e1.pipe(subscribeOn(testScheduler))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(sub)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--|")
      const sub = "     ^---!    "
      const expected = "--a--    "
      const unsub = "   ----!    "
      const result = e1.pipe(subscribeOn(testScheduler))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(sub)
    })
  })
  it("should not break unsubscription chains when the result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--|")
      const sub = "     ^---!    "
      const expected = "--a--    "
      const unsub = "   ----!    "
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        subscribeOn(testScheduler),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(sub)
    })
  })
  it("should properly support a delayTime of Infinity", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--|")
      const expected = "---------"
      const result = e1.pipe(subscribeOn(testScheduler, Infinity))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe([])
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(subscribeOn(queueScheduler), take(3))
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { Observable, of, NEVER, queueScheduler, Subject, scheduled } from "rxjs"
import { map, switchAll, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {switch} */
describe("switchAll", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should switch a hot observable of cold observables", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("    --a---b--c---d--|      ")
        const xsubs = "   --^------!               "
        const y = cold("           ----e---f--g---|")
        const ysubs = "   ---------^--------------!"
        const e1 = hot("  --x------y-------|       ", { x: x, y: y })
        const e1subs = "  ^----------------!       "
        const expected = "----a---b----e---f--g---|"
        const result = e1.pipe(switchAll())
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch to each immediately-scheduled inner Observable", done => {
    const a = scheduled([1, 2, 3], queueScheduler)
    const b = scheduled([4, 5, 6], queueScheduler)
    const r = [1, 4, 5, 6]
    let i = 0
    scheduled([a, b], queueScheduler)
      .pipe(switchAll())
      .subscribe({
        next(x) {
          expect(x).to.equal(r[i++])
        },
        complete: done,
      })
  })
  it("should unsub inner observables", () => {
    const unsubbed: string[] = []
    of("a", "b")
      .pipe(
        map(
          x =>
            new Observable<string>(subscriber => {
              subscriber.complete()
              return () => {
                unsubbed.push(x)
              }
            })
        ),
        switchAll()
      )
      .subscribe()
    expect(unsubbed).to.deep.equal(["a", "b"])
  })
  it("should switch to each inner Observable", done => {
    const a = of(1, 2, 3)
    const b = of(4, 5, 6)
    const r = [1, 2, 3, 4, 5, 6]
    let i = 0
    of(a, b)
      .pipe(switchAll())
      .subscribe({
        next(x) {
          expect(x).to.equal(r[i++])
        },
        complete: done,
      })
  })
  it("should handle a hot observable of observables", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("        --a---b---c--|         ")
        const xsubs = "   ------^-------!              "
        const y = cold("                ---d--e---f---|")
        const ysubs = "   --------------^-------------!"
        const e1 = hot("  ------x-------y------|       ", { x: x, y: y })
        const e1subs = "  ^--------------------!       "
        const expected = "--------a---b----d--e---f---|"
        const result = e1.pipe(switchAll())
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
      }
    )
  })
  it("should handle a hot observable of observables, outer is unsubscribed early", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("        --a---b---c--|         ")
        const xsubs = "   ------^-------!              "
        const y = cold("                ---d--e---f---|")
        const ysubs = "   --------------^-!            "
        const e1 = hot("  ------x-------y------|       ", { x: x, y: y })
        const unsub = "   ----------------!            "
        const expected = "--------a---b---             "
        const result = e1.pipe(switchAll())
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("        --a---b---c--|         ")
        const xsubs = "   ------^-------!              "
        const y = cold("                ---d--e---f---|")
        const ysubs = "   --------------^-!            "
        const e1 = hot("  ------x-------y------|       ", { x: x, y: y })
        const expected = "--------a---b----            "
        const unsub = "   ----------------!            "
        const result = e1.pipe(
          mergeMap(x => of(x)),
          switchAll(),
          mergeMap(x => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
      }
    )
  })
  it("should handle a hot observable of observables, inner never completes", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("        --a---b---c--|          ")
        const xsubs = "   ------^-------!               "
        const y = cold("                ---d--e---f-----")
        const ysubs = "   --------------^               "
        const e1 = hot("  ------x-------y------|        ", { x: x, y: y })
        const expected = "--------a---b----d--e---f-----"
        const result = e1.pipe(switchAll())
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
      }
    )
  })
  it("should handle a synchronous switch to the second inner observable", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("        --a---b---c--|   ")
        const xsubs = "   ------(^!)             "
        const y = cold("        ---d--e---f---|  ")
        const ysubs = "   ------^-------------!  "
        const e1 = hot("  ------(xy)------------|", { x: x, y: y })
        const expected = "---------d--e---f-----|"
        const result = e1.pipe(switchAll())
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
      }
    )
  })
  it("should handle a hot observable of observables, one inner throws", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("        --a---#                ")
        const xsubs = "   ------^-----!                "
        const y = cold("                ---d--e---f---|")
        const ysubs = "                                "
        const e1 = hot("  ------x-------y------|       ", { x: x, y: y })
        const expected = "--------a---#                "
        const result = e1.pipe(switchAll())
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
      }
    )
  })
  it("should handle a hot observable of observables, outer throws", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("        --a---b---c--|         ")
        const xsubs = "   ------^-------!              "
        const y = cold("                ---d--e---f---|")
        const ysubs = "   --------------^-------!      "
        const e1 = hot("  ------x-------y-------#      ", { x: x, y: y })
        const expected = "--------a---b----d--e-#      "
        const result = e1.pipe(switchAll())
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
      }
    )
  })
  it("should handle an empty hot observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ------|")
      const e1subs = "  ^-----!"
      const expected = "------|"
      const result = e1.pipe(switchAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a never hot observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -")
      const e1subs = "  ^"
      const expected = "-"
      const result = e1.pipe(switchAll())
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should complete not before the outer completes", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("        --a---b---c--|   ")
        const xsubs = "   ------^------------!   "
        const e1 = hot("  ------x---------------|", { x: x })
        const e1subs = "  ^---------------------!"
        const expected = "--------a---b---c-----|"
        const result = e1.pipe(switchAll())
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should handle an observable of promises", done => {
    const expected = [3]
    of(Promise.resolve(1), Promise.resolve(2), Promise.resolve(3))
      .pipe(switchAll())
      .subscribe({
        next(x) {
          expect(x).to.equal(expected.shift())
        },
        complete() {
          expect(expected.length).to.equal(0)
          done()
        },
      })
  })
  it("should handle an observable of promises, where last rejects", done => {
    of(Promise.resolve(1), Promise.resolve(2), Promise.reject(3))
      .pipe(switchAll())
      .subscribe({
        next() {
          done(new Error("should not be called"))
        },
        error(err) {
          expect(err).to.equal(3)
          done()
        },
        complete() {
          done(new Error("should not be called"))
        },
      })
  })
  it("should handle an observable with Arrays in it", () => {
    const expected = [1, 2, 3, 4]
    let completed = false
    of(NEVER, NEVER, [1, 2, 3, 4])
      .pipe(switchAll())
      .subscribe({
        next(x) {
          expect(x).to.equal(expected.shift())
        },
        complete() {
          completed = true
          expect(expected.length).to.equal(0)
        },
      })
    expect(completed).to.be.true
  })
  it("should not leak when child completes before each switch (prevent memory leaks #2355)", () => {
    let iStream: Subject<number>
    const oStreamControl = new Subject<number>()
    const oStream = oStreamControl.pipe(
      map(() => (iStream = new Subject<number>()))
    )
    const switcher = oStream.pipe(switchAll())
    const result: number[] = []
    let sub = switcher.subscribe(x => result.push(x))
    ;[0, 1, 2, 3, 4].forEach(n => {
      oStreamControl.next(n) // creates inner
      iStream.complete()
    })
    // Expect one child of switchAll(): The oStream
    expect((sub as any)._finalizers?.[0]._finalizers?.length).to.equal(1)
    sub.unsubscribe()
  })
  it("should not leak if we switch before child completes (prevent memory leaks #2355)", () => {
    const oStreamControl = new Subject<number>()
    const oStream = oStreamControl.pipe(map(() => new Subject<number>()))
    const switcher = oStream.pipe(switchAll())
    const result: number[] = []
    let sub = switcher.subscribe(x => result.push(x))
    ;[0, 1, 2, 3, 4].forEach(n => {
      oStreamControl.next(n) // creates inner
    })
    // Expect one child of switchAll(): The oStream
    expect((sub as any)._finalizers?.[0]._finalizers?.length).to.equal(1)
    // Expect two children of subscribe(): The destination and the first inner
    // See #4106 - inner subscriptions are now added to destinations
    expect((sub as any)._finalizers?.length).to.equal(2)
    sub.unsubscribe()
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    of(synchronousObservable)
      .pipe(switchAll(), take(3))
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { switchMap, mergeMap, map, takeWhile, take } from "rxjs/operators"
import { concat, defer, of, Observable, BehaviorSubject } from "rxjs"
import { asInteropObservable } from "../helpers/interop-helper"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {switchMap} */
describe("switchMap", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should map-and-flatten each item to an Observable", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("   --1-----3--5-------|")
        const e1subs = "   ^------------------!"
        const e2 = cold("    x-x-x|            ", { x: 10 })
        //                         x-x-x|
        //                            x-x-x|
        const expected = " --x-x-x-y-yz-z-z---|"
        const values = { x: 10, y: 30, z: 50 }
        const result = e1.pipe(switchMap(x => e2.pipe(map(i => i * +x))))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should support the deprecated resultSelector", () => {
    const results: Array<number[]> = []
    of(1, 2, 3)
      .pipe(
        switchMap(
          x => of(x, x + 1, x + 2),
          (a, b, i, ii) => [a, b, i, ii]
        )
      )
      .subscribe({
        next(value) {
          results.push(value)
        },
        error(err) {
          throw err
        },
        complete() {
          expect(results).to.deep.equal([
            [1, 1, 0, 0],
            [1, 2, 0, 1],
            [1, 3, 0, 2],
            [2, 2, 1, 0],
            [2, 3, 1, 1],
            [2, 4, 1, 2],
            [3, 3, 2, 0],
            [3, 4, 2, 1],
            [3, 5, 2, 2],
          ])
        },
      })
  })
  it("should support a void resultSelector (still deprecated)", () => {
    const results: number[] = []
    of(1, 2, 3)
      .pipe(switchMap(x => of(x, x + 1, x + 2), void 0))
      .subscribe({
        next(value) {
          results.push(value)
        },
        error(err) {
          throw err
        },
        complete() {
          expect(results).to.deep.equal([1, 2, 3, 2, 3, 4, 3, 4, 5])
        },
      })
  })
  it("should unsub inner observables", () => {
    const unsubbed: string[] = []
    of("a", "b")
      .pipe(
        switchMap(
          x =>
            new Observable<string>(subscriber => {
              subscriber.complete()
              return () => {
                unsubbed.push(x)
              }
            })
        )
      )
      .subscribe()
    expect(unsubbed).to.deep.equal(["a", "b"])
  })
  it("should switch inner cold observables", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|           ")
        const xsubs = "   ---------^---------!                  "
        const y = cold("                     ---f---g---h---i--|")
        const ysubs = "   -------------------^-----------------!"
        const e1 = hot("  ---------x---------y---------|        ")
        const e1subs = "  ^----------------------------!        "
        const expected = "-----------a--b--c----f---g---h---i--|"
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        const result = e1.pipe(switchMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should raise error when projection throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -------x-----y---|")
      const e1subs = "  ^------!          "
      const expected = "-------#          "
      function project(): any[] {
        throw "error"
      }
      expectObservable(e1.pipe(switchMap(project))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should switch inner cold observables, outer is unsubscribed early", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|           ")
        const xsubs = "   ---------^---------!                  "
        const y = cold("                     ---f---g---h---i--|")
        const ysubs = "   -------------------^-!                "
        const e1 = hot("  ---------x---------y---------|        ")
        const e1subs = "  ^--------------------!                "
        const unsub = "   ---------------------!                "
        const expected = "-----------a--b--c----                "
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        const result = e1.pipe(switchMap(value => observableLookup[value]))
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|           ")
        const xsubs = "   ---------^---------!                  "
        const y = cold("                     ---f---g---h---i--|")
        const ysubs = "   -------------------^-!                "
        const e1 = hot("  ---------x---------y---------|        ")
        const e1subs = "  ^--------------------!                "
        const expected = "-----------a--b--c----                "
        const unsub = "   ---------------------!                "
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        const result = e1.pipe(
          mergeMap(x => of(x)),
          switchMap(value => observableLookup[value]),
          mergeMap(x => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not break unsubscription chains with interop inners when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|           ")
        const xsubs = "   ---------^---------!                  "
        const y = cold("                     ---f---g---h---i--|")
        const ysubs = "   -------------------^-!                "
        const e1 = hot("  ---------x---------y---------|        ")
        const e1subs = "  ^--------------------!                "
        const expected = "-----------a--b--c----                "
        const unsub = "   ---------------------!                "
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        // This test is the same as the previous test, but the observable is
        // manipulated to make it look like an interop observable - an observable
        // from a foreign library. Interop subscribers are treated differently:
        // they are wrapped in a safe subscriber. This test ensures that
        // unsubscriptions are chained all the way to the interop subscriber.
        const result = e1.pipe(
          mergeMap(x => of(x)),
          switchMap(value => asInteropObservable(observableLookup[value])),
          mergeMap(x => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = concat(
      defer(() => {
        sideEffects.push(1)
        return of(1)
      }),
      defer(() => {
        sideEffects.push(2)
        return of(2)
      }),
      defer(() => {
        sideEffects.push(3)
        return of(3)
      })
    )
    of(null)
      .pipe(
        switchMap(() => synchronousObservable),
        takeWhile(x => x != 2) // unsubscribe at the second side-effect
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([1, 2])
  })
  it("should switch inner cold observables, inner never completes", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|          ")
        const xsubs = "   ---------^---------!                 "
        const y = cold("                     ---f---g---h---i--")
        const ysubs = "   -------------------^                 "
        const e1 = hot("  ---------x---------y---------|       ")
        const e1subs = "  ^----------------------------!       "
        const expected = "-----------a--b--c----f---g---h---i--"
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        const result = e1.pipe(switchMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should handle a synchronous switch to the second inner observable", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|   ")
        const xsubs = "   ---------(^!)                 "
        const y = cold("           ---f---g---h---i--|  ")
        const ysubs = "   ---------^-----------------!  "
        const e1 = hot("  ---------(xy)----------------|")
        const e1subs = "  ^----------------------------!"
        const expected = "------------f---g---h---i----|"
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        const result = e1.pipe(switchMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch inner cold observables, one inner throws", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--#--d--e--|          ")
        const xsubs = "   ---------^-------!                   "
        const y = cold("                     ---f---g---h---i--")
        const ysubs = "                                        "
        const e1 = hot("  ---------x---------y---------|       ")
        const e1subs = "  ^----------------!                   "
        const expected = "-----------a--b--#                   "
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        const result = e1.pipe(switchMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch inner hot observables", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const x = hot("   -----a--b--c--d--e--|                 ")
      const xsubs = "   ---------^---------!                  "
      const y = hot("   --p-o-o-p-------------f---g---h---i--|")
      const ysubs = "   -------------------^-----------------!"
      const e1 = hot("  ---------x---------y---------|        ")
      const e1subs = "  ^----------------------------!        "
      const expected = "-----------c--d--e----f---g---h---i--|"
      const observableLookup: Record<string, Observable<string>> = {
        x: x,
        y: y,
      }
      const result = e1.pipe(switchMap(value => observableLookup[value]))
      expectObservable(result).toBe(expected)
      expectSubscriptions(x.subscriptions).toBe(xsubs)
      expectSubscriptions(y.subscriptions).toBe(ysubs)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should switch inner empty and empty", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           |                    ")
        const y = cold("                     |          ")
        const xsubs = "   ---------(^!)                 "
        const ysubs = "   -------------------(^!)       "
        const e1 = hot("  ---------x---------y---------|")
        const e1subs = "  ^----------------------------!"
        const expected = "-----------------------------|"
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        const result = e1.pipe(switchMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch inner empty and never", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           |                    ")
        const y = cold("                     -          ")
        const xsubs = "   ---------(^!)                 "
        const ysubs = "   -------------------^          "
        const e1 = hot("  ---------x---------y---------|")
        const e1subs = "  ^----------------------------!"
        const expected = "------------------------------"
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        const result = e1.pipe(switchMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch inner never and empty", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           -                    ")
        const y = cold("                     |          ")
        const xsubs = "   ---------^---------!          "
        const ysubs = "   -------------------(^!)       "
        const e1 = hot("  ---------x---------y---------|")
        const e1subs = "  ^----------------------------!"
        const expected = "-----------------------------|"
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        const result = e1.pipe(switchMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch inner never and throw", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           -                    ")
        const y = cold("                     #          ", undefined, "sad")
        const xsubs = "   ---------^---------!          "
        const ysubs = "   -------------------(^!)       "
        const e1 = hot("  ---------x---------y---------|")
        const e1subs = "  ^------------------!          "
        const expected = "-------------------#          "
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        const result = e1.pipe(switchMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected, undefined, "sad")
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch inner empty and throw", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           |                    ")
        const y = cold("                     #          ", undefined, "sad")
        const xsubs = "   ---------(^!)                 "
        const ysubs = "   -------------------(^!)       "
        const e1 = hot("  ---------x---------y---------|")
        const e1subs = "  ^------------------!          "
        const expected = "-------------------#          "
        const observableLookup: Record<string, Observable<string>> = {
          x: x,
          y: y,
        }
        const result = e1.pipe(switchMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected, undefined, "sad")
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should handle outer empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      const result = e1.pipe(switchMap(value => of(value)))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle outer never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      const result = e1.pipe(switchMap(value => of(value)))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle outer throw", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      const result = e1.pipe(switchMap(value => of(value)))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle outer error", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|")
        const xsubs = "   ---------^---------!       "
        const e1 = hot("  ---------x---------#       ")
        const e1subs = "  ^------------------!       "
        const expected = "-----------a--b--c-#       "
        const observableLookup: Record<string, Observable<string>> = { x: x }
        const result = e1.pipe(switchMap(value => observableLookup[value]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        switchMap(value => of(value)),
        take(3)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
  it("should unsubscribe previous inner sub when getting synchronously reentrance during subscribing the inner sub", () => {
    const e = new BehaviorSubject(1)
    const results: Array<number> = []
    e.pipe(
      take(3),
      switchMap(
        value =>
          new Observable<number>(subscriber => {
            e.next(value + 1)
            subscriber.next(value)
          })
      )
    ).subscribe(value => results.push(value))
    expect(results).to.deep.equal([3])
  })
})
import { expect } from "chai"
import { Observable, of } from "rxjs"
import { switchMapTo, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {switchMapTo} */
describe("switchMapTo", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should map-and-flatten each item to an Observable", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --1-----3--5-------|")
        const e1subs = "  ^------------------!"
        const e2 = cold("   x-x-x|            ", { x: 10 })
        //                        x-x-x|
        //                           x-x-x|
        const expected = "--x-x-x-x-xx-x-x---|"
        const values = { x: 10 }
        const result = e1.pipe(switchMapTo(e2))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should support the deprecated resultSelector", () => {
    const results: Array<number[]> = []
    of(1, 2, 3)
      .pipe(switchMapTo(of(4, 5, 6), (a, b, i, ii) => [a, b, i, ii]))
      .subscribe({
        next(value) {
          results.push(value)
        },
        error(err) {
          throw err
        },
        complete() {
          expect(results).to.deep.equal([
            [1, 4, 0, 0],
            [1, 5, 0, 1],
            [1, 6, 0, 2],
            [2, 4, 1, 0],
            [2, 5, 1, 1],
            [2, 6, 1, 2],
            [3, 4, 2, 0],
            [3, 5, 2, 1],
            [3, 6, 2, 2],
          ])
        },
      })
  })
  it("should support a void resultSelector (still deprecated)", () => {
    const results: number[] = []
    of(1, 2, 3)
      .pipe(switchMapTo(of(4, 5, 6), void 0))
      .subscribe({
        next(value) {
          results.push(value)
        },
        error(err) {
          throw err
        },
        complete() {
          expect(results).to.deep.equal([4, 5, 6, 4, 5, 6, 4, 5, 6])
        },
      })
  })
  it("should switch a synchronous many outer to a synchronous many inner", done => {
    const a = of(1, 2, 3)
    const expected = ["a", "b", "c", "a", "b", "c", "a", "b", "c"]
    a.pipe(switchMapTo(of("a", "b", "c"))).subscribe({
      next(x) {
        expect(x).to.equal(expected.shift())
      },
      complete: done,
    })
  })
  it("should unsub inner observables", () => {
    let unsubbed = 0
    of("a", "b")
      .pipe(
        switchMapTo(
          new Observable<string>(subscriber => {
            subscriber.complete()
            return () => {
              unsubbed++
            }
          })
        )
      )
      .subscribe()
    expect(unsubbed).to.equal(2)
  })
  it("should switch to an inner cold observable", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|          ")
        const xsubs = [
          "               ---------^---------!                 ",
          //                                 --a--b--c--d--e--|
          "               -------------------^----------------!",
        ]
        const e1 = hot("  ---------x---------x---------|       ")
        const e1subs = "  ^----------------------------!       "
        const expected = "-----------a--b--c---a--b--c--d--e--|"
        expectObservable(e1.pipe(switchMapTo(x))).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch to an inner cold observable, outer eventually throws", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|")
        const xsubs = "   ---------^---------!       "
        const e1 = hot("  ---------x---------#       ")
        const e1subs = "  ^------------------!       "
        const expected = "-----------a--b--c-#       "
        expectObservable(e1.pipe(switchMapTo(x))).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch to an inner cold observable, outer is unsubscribed early", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|   ")
        const xsubs = [
          "               ---------^---------!          ",
          //                                 --a--b--c--d--e--|
          "               -------------------^--!       ",
        ]
        const e1 = hot("  ---------x---------x---------|")
        const unsub = "   ----------------------!       "
        const e1subs = "  ^---------------------!       "
        const expected = "-----------a--b--c---a-       "
        expectObservable(e1.pipe(switchMapTo(x)), unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("--a--b--c--d--e--|   ")
        const xsubs = [
          "               ---------^---------!          ",
          //                                 --a--b--c--d--e--|
          "               -------------------^--!       ",
        ]
        const e1 = hot("  ---------x---------x---------|")
        const e1subs = "  ^---------------------!       "
        const expected = "-----------a--b--c---a-       "
        const unsub = "   ----------------------!       "
        const result = e1.pipe(
          mergeMap(x => of(x)),
          switchMapTo(x),
          mergeMap(x => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch to an inner cold observable, inner never completes", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e-          ")
        const xsubs = [
          "               ---------^---------!               ",
          //                                 --a--b--c--d--e-
          "               -------------------^               ",
        ]
        const e1 = hot("  ---------x---------y---------|     ")
        const e1subs = "  ^----------------------------!     "
        const expected = "-----------a--b--c---a--b--c--d--e-"
        expectObservable(e1.pipe(switchMapTo(x))).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should handle a synchronous switch to the inner observable", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|   ")
        // prettier-ignore
        const xsubs = [
        '               ---------(^!)                 ', 
        '               ---------^----------------!   '
      ];
        const e1 = hot("  ---------(xx)----------------|")
        const e1subs = "  ^----------------------------!"
        const expected = "-----------a--b--c--d--e-----|"
        expectObservable(e1.pipe(switchMapTo(x))).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch to an inner cold observable, inner raises an error", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--#            ")
        const xsubs = "   ---------^-------!            "
        const e1 = hot("  ---------x---------x---------|")
        const e1subs = "  ^----------------!            "
        const expected = "-----------a--b--#            "
        expectObservable(e1.pipe(switchMapTo(x))).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch an inner hot observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const x = hot("   --p-o-o-p---a--b--c--d-|      ")
      // prettier-ignore
      const xsubs = [
        '               ---------^---------!          ',
        '               -------------------^---!      '
      ];
      const e1 = hot("  ---------x---------x---------|")
      const e1subs = "  ^----------------------------!"
      const expected = "------------a--b--c--d-------|"
      expectObservable(e1.pipe(switchMapTo(x))).toBe(expected)
      expectSubscriptions(x.subscriptions).toBe(xsubs)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should switch to an inner empty", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           |                    ")
        const xsubs = [
          "               ---------(^!)                 ",
          //                                 |
          "               -------------------(^!)       ",
        ]
        const e1 = hot("  ---------x---------x---------|")
        const e1subs = "  ^----------------------------!"
        const expected = "-----------------------------|"
        expectObservable(e1.pipe(switchMapTo(x))).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch to an inner never", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           -                    ")
        const xsubs = [
          "               ---------^---------!          ",
          //                                 -
          "               -------------------^          ",
        ]
        const e1 = hot("  ---------x---------x---------|")
        const e1subs = "  ^----------------------------!"
        const expected = "------------------------------"
        expectObservable(e1.pipe(switchMapTo(x))).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch to an inner that just raises an error", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           #                    ")
        const xsubs = "   ---------(^!)                 "
        const e1 = hot("  ---------x---------x---------|")
        const e1subs = "  ^--------!                    "
        const expected = "---------#                    "
        expectObservable(e1.pipe(switchMapTo(x))).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should handle an empty outer", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      expectObservable(e1.pipe(switchMapTo(of("foo")))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle a never outer", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(switchMapTo(of("foo")))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle an outer that just raises and error", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      expectObservable(e1.pipe(switchMapTo(of("foo")))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(switchMapTo(of(0)), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { concat, defer, Observable, of } from "rxjs"
import { switchScan, map, mergeMap, takeWhile } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {switchScan} */
describe("switchScan", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should map-and-flatten each item to an Observable while passing the accumulated value", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  --1-----3--5-------|")
        const e1subs = "  ^------------------!"
        const e2 = cold("    x-x-x|           ", { x: 10 })
        //                        x-x-x|
        //                           x-x-x|
        const expected = "--x-x-x-y-yz-z-z---|"
        const values = { x: 10, y: 40, z: 90 }
        const result = e1.pipe(
          switchScan((acc, x) => e2.pipe(map(i => i * Number(x) + acc)), 0)
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should provide the proper accumulated values", () => {
    const accs: number[] = []
    of(1, 3, 5)
      .pipe(
        switchScan((acc, x) => {
          accs.push(acc)
          return of(acc + x)
        }, 100)
      )
      .subscribe()
    expect(accs).to.deep.equal([100, 101, 104])
  })
  it("should unsub inner observables", () => {
    const unsubbed: string[] = []
    of("a", "b")
      .pipe(
        switchScan(
          (_acc, x) =>
            new Observable<string>(subscriber => {
              subscriber.complete()
              return () => {
                unsubbed.push(x)
              }
            }),
          null
        )
      )
      .subscribe()
    expect(unsubbed).to.deep.equal(["a", "b"])
  })
  it("should switch inner cold observables", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|           ")
        const xsubs = "   ---------^---------!                  "
        const y = cold("                     ---f---g---h---i--|")
        const ysubs = "   -------------------^-----------------!"
        const e1 = hot("  ---------x---------y---------|        ")
        const e1subs = "  ^----------------------------!        "
        const expected = "-----------a--b--c----f---g---h---i--|"
        const observableLookup: Record<string, Observable<string>> = { x, y }
        const result = e1.pipe(
          switchScan((_acc, value) => observableLookup[value], null)
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should raise error when projection throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -------x-----y---|")
      const e1subs = "  ^------!          "
      const expected = "-------#          "
      function project(): any[] {
        throw "error"
      }
      expectObservable(e1.pipe(switchScan(project, null))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should switch inner cold observables, outer is unsubscribed early", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|           ")
        const xsubs = "   ---------^---------!                  "
        const y = cold("                     ---f---g---h---i--|")
        const ysubs = "   -------------------^-!                "
        const e1 = hot("  ---------x---------y---------|        ")
        const e1subs = "  ^--------------------!                "
        const unsub = "   ---------------------!                "
        const expected = "-----------a--b--c----                "
        const observableLookup: Record<string, Observable<string>> = { x, y }
        const result = e1.pipe(
          switchScan((_acc, value) => observableLookup[value], null)
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|           ")
        const xsubs = "   ---------^---------!                  "
        const y = cold("                     ---f---g---h---i--|")
        const ysubs = "   -------------------^-!                "
        const e1 = hot("  ---------x---------y---------|        ")
        const e1subs = "  ^--------------------!                "
        const expected = "-----------a--b--c----                "
        const unsub = "   ---------------------!                "
        const observableLookup: Record<string, Observable<string>> = { x, y }
        const result = e1.pipe(
          mergeMap(x => of(x)),
          switchScan((_acc, value) => observableLookup[value], null),
          mergeMap(x => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = concat(
      defer(() => {
        sideEffects.push(1)
        return of(1)
      }),
      defer(() => {
        sideEffects.push(2)
        return of(2)
      }),
      defer(() => {
        sideEffects.push(3)
        return of(3)
      })
    )
    of(null)
      .pipe(
        switchScan(() => synchronousObservable, null),
        takeWhile(x => x != 2) // unsubscribe at the second side-effect
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([1, 2])
  })
  it("should switch inner cold observables, inner never completes", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|          ")
        const xsubs = "   ---------^---------!                 "
        const y = cold("                     ---f---g---h---i--")
        const ysubs = "   -------------------^                 "
        const e1 = hot("  ---------x---------y---------|       ")
        const e1subs = "  ^----------------------------!       "
        const expected = "-----------a--b--c----f---g---h---i--"
        const observableLookup: Record<string, Observable<string>> = { x, y }
        const result = e1.pipe(
          switchScan((_acc, value) => observableLookup[value], null)
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should handle a synchronous switch to the second inner observable", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|   ")
        const xsubs = "   ---------(^!)                 "
        const y = cold("           ---f---g---h---i--|  ")
        const ysubs = "   ---------^-----------------!  "
        const e1 = hot("  ---------(xy)----------------|")
        const e1subs = "  ^----------------------------!"
        const expected = "------------f---g---h---i----|"
        const observableLookup: Record<string, Observable<string>> = { x, y }
        const result = e1.pipe(
          switchScan((_acc, value) => observableLookup[value], null)
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch inner cold observables, one inner throws", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--#--d--e--|          ")
        const xsubs = "   ---------^-------!                   "
        const y = cold("                     ---f---g---h---i--")
        const ysubs = "                                        "
        const e1 = hot("  ---------x---------y---------|       ")
        const e1subs = "  ^----------------!                   "
        const expected = "-----------a--b--#                   "
        const observableLookup: Record<string, Observable<string>> = { x, y }
        const result = e1.pipe(
          switchScan((_acc, value) => observableLookup[value], null)
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch inner hot observables", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const x = hot("   -----a--b--c--d--e--|                 ")
      const xsubs = "   ---------^---------!                  "
      const y = hot("   --p-o-o-p-------------f---g---h---i--|")
      const ysubs = "   -------------------^-----------------!"
      const e1 = hot("  ---------x---------y---------|        ")
      const e1subs = "  ^----------------------------!        "
      const expected = "-----------c--d--e----f---g---h---i--|"
      const observableLookup: Record<string, Observable<string>> = { x, y }
      const result = e1.pipe(
        switchScan((_acc, value) => observableLookup[value], null)
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(x.subscriptions).toBe(xsubs)
      expectSubscriptions(y.subscriptions).toBe(ysubs)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should switch inner empty and empty", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           |                    ")
        const y = cold("                     |          ")
        const xsubs = "   ---------(^!)                 "
        const ysubs = "   -------------------(^!)       "
        const e1 = hot("  ---------x---------y---------|")
        const e1subs = "  ^----------------------------!"
        const expected = "-----------------------------|"
        const observableLookup: Record<string, Observable<string>> = { x, y }
        const result = e1.pipe(
          switchScan((_acc, value) => observableLookup[value], null)
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch inner empty and never", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           |                    ")
        const y = cold("                     -----------")
        const xsubs = "   ---------(^!)                 "
        const ysubs = "   -------------------^          "
        const e1 = hot("  ---------x---------y---------|")
        const e1subs = "  ^----------------------------!"
        const expected = "------------------------------"
        const observableLookup: Record<string, Observable<string>> = { x, y }
        const result = e1.pipe(
          switchScan((_acc, value) => observableLookup[value], null)
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch inner never and empty", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           -----------          ")
        const y = cold("                     |          ")
        const xsubs = "   ---------^---------!          "
        const ysubs = "   -------------------(^!)       "
        const e1 = hot("  ---------x---------y---------|")
        const e1subs = "  ^----------------------------!"
        const expected = "-----------------------------|"
        const observableLookup: Record<string, Observable<string>> = { x, y }
        const result = e1.pipe(
          switchScan((_acc, value) => observableLookup[value], null)
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch inner never and throw", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           -----------          ")
        const y = cold("                     #          ", undefined, "sad")
        const xsubs = "   ---------^---------!          "
        const ysubs = "   -------------------(^!)       "
        const e1 = hot("  ---------x---------y---------|")
        const e1subs = "  ^------------------!          "
        const expected = "-------------------#          "
        const observableLookup: Record<string, Observable<string>> = { x, y }
        const result = e1.pipe(
          switchScan((_acc, value) => observableLookup[value], null)
        )
        expectObservable(result).toBe(expected, undefined, "sad")
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should switch inner empty and throw", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           |                    ")
        const y = cold("                     #          ", undefined, "sad")
        const xsubs = "   ---------(^!)                 "
        const ysubs = "   -------------------(^!)       "
        const e1 = hot("  ---------x---------y---------|")
        const e1subs = "  ^------------------!          "
        const expected = "-------------------#          "
        const observableLookup: Record<string, Observable<string>> = { x, y }
        const result = e1.pipe(
          switchScan((_acc, value) => observableLookup[value], null)
        )
        expectObservable(result).toBe(expected, undefined, "sad")
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should handle outer empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      const result = e1.pipe(switchScan((_acc, value) => of(value), ""))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle outer never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      const result = e1.pipe(switchScan((_acc, value) => of(value), ""))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle outer throw", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      const result = e1.pipe(switchScan((_acc, value) => of(value), ""))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should handle outer error", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("           --a--b--c--d--e--|")
        const xsubs = "   ---------^---------!       "
        const e1 = hot("  ---------x---------#       ")
        const e1subs = "  ^------------------!       "
        const expected = "-----------a--b--c-#       "
        const observableLookup: Record<string, Observable<string>> = { x: x }
        const result = e1.pipe(
          switchScan((_acc, value) => observableLookup[value], null)
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should create a new seed for each subscriber", () => {
    const seeds: string[] = []
    const observer = (value: string) => seeds.push(value)
    const source = of("a", "b").pipe(switchScan((acc, x) => of(acc + x), ""))
    source.subscribe(observer)
    source.subscribe(observer)
    expect(seeds).to.deep.equal(["a", "ab", "a", "ab"])
  })
  it("should pass index to the accumulator function", () => {
    const indices: number[] = []
    of("a", "b", "c", "d")
      .pipe(
        switchScan((_acc, _x, index) => {
          indices.push(index)
          return of()
        }, "")
      )
      .subscribe()
    expect(indices).to.deep.equal([0, 1, 2, 3])
  })
})
import { expect } from "chai"
import { merge, Observable, of, Subject } from "rxjs"
import { mergeMap, take, tap } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {take} */
describe("take", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should take two values of an observable with many values", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a-----b----c---d--|")
      const e1subs = "  ^-------!------------"
      const expected = "--a-----(b|)         "
      expectObservable(e1.pipe(take(2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work with empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |")
      const e1subs = "  (^!)"
      const expected = "|"
      expectObservable(e1.pipe(take(42))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should go on forever on never", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(take(42))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should be empty on take(0)", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b----c---d--|")
      const e1subs: string[] = [] // Don't subscribe at all
      const expected = "   |"
      expectObservable(e1.pipe(take(0))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should be empty if provided with negative value", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a-----b----c---d--|")
      const expected = "|"
      const e1subs: string[] = [] // Don't subscribe at all
      expectObservable(e1.pipe(take(-42))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should take one value of an observable with one value", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---(a|)")
      const e1subs = "  ^--!---"
      const expected = "---(a|)"
      expectObservable(e1.pipe(take(1))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should take one values of an observable with many values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b----c---d--|")
      const e1subs = "     ^--!------------"
      const expected = "   ---(b|)         "
      expectObservable(e1.pipe(take(1))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should error on empty", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^----|")
      const e1subs = "     ^----!"
      const expected = "   -----|"
      expectObservable(e1.pipe(take(42))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should propagate error from the source observable", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^---#", undefined, "too bad")
      const e1subs = "   ^---!"
      const expected = " ----#"
      expectObservable(e1.pipe(take(42))).toBe(expected, null, "too bad")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should propagate error from an observable with values", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^--a--b--#")
      const e1subs = "   ^--------!"
      const expected = " ---a--b--#"
      expectObservable(e1.pipe(take(42))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^--a--b-----c--d--e--|")
      const unsub = "    ---------!------------"
      const e1subs = "   ^--------!------------"
      const expected = " ---a--b---            "
      expectObservable(e1.pipe(take(42)), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work with throw", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #")
      const e1subs = "  (^!)"
      const expected = "#"
      expectObservable(e1.pipe(take(42))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chain when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^--a--b-----c--d--e--|")
      const unsub = "    ---------!            "
      const e1subs = "   ^--------!            "
      const expected = " ---a--b---            "
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        take(42),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should unsubscribe from the source when it reaches the limit", () => {
    const source = new Observable<number>(observer => {
      expect(observer.closed).to.be.false
      observer.next(42)
      expect(observer.closed).to.be.true
    }).pipe(take(1))
    source.subscribe()
  })
  it("should complete when the source is reentrant", () => {
    let completed = false
    const source = new Subject<void>()
    source.pipe(take(5)).subscribe({
      next() {
        source.next()
      },
      complete() {
        completed = true
      },
    })
    source.next()
    expect(completed).to.be.true
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
  it("should complete even if the parameter is a string", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a-----b----c---d--|")
      const e1subs = "  ^-------!------------"
      const expected = "--a-----(b|)         "
      expectObservable(e1.pipe(take("2" as any))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  // This is related to a PR with discussion here: https://github.com/ReactiveX/rxjs/pull/6396
  // We can't fix this until version 8.
  it.skip("should unsubscribe from the source when it reaches the limit before a recursive synchronous upstream error is notified", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const subject = new Subject()
      const e1 = cold(" (a|)")
      const e1subs = "  (^!)"
      const expected = "(a|)"
      const result = merge(e1, subject).pipe(
        take(1),
        tap(() => subject.error("error"))
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
})
import { takeLast, mergeMap } from "rxjs/operators"
import { of } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {takeLast} */
describe("takeLast operator", () => {
  let rxTest: TestScheduler
  beforeEach(() => {
    rxTest = new TestScheduler(observableMatcher)
  })
  it("should take two values of an observable with many values", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold("--a-----b----c---d--|    ")
      const e1subs = " ^-------------------!    "
      const expected = "--------------------(cd|)"
      expectObservable(e1.pipe(takeLast(2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should take last three values", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a-----b----c---d--|    ")
      const e1subs = "  ^-------------------!    "
      const expected = "--------------------(bcd|)"
      expectObservable(e1.pipe(takeLast(3))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should take all element when try to take larger then source", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a-----b----c---d--|    ")
      const e1subs = "  ^-------------------!    "
      const expected = "--------------------(abcd|)"
      expectObservable(e1.pipe(takeLast(5))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should take all element when try to take exact", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a-----b----c---d--|    ")
      const e1subs = "  ^-------------------!    "
      const expected = "--------------------(abcd|)"
      expectObservable(e1.pipe(takeLast(4))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not take any values", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a-----b----c---d--|")
      const expected = "|"
      const e1subs: string[] = []
      expectObservable(e1.pipe(takeLast(0))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not take any values if provided with negative value", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --a-----b----c---d--|")
      const expected = "|"
      const e1subs: string[] = []
      expectObservable(e1.pipe(takeLast(-42))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work with empty", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |")
      const e1subs = "  (^!)"
      const expected = "|"
      expectObservable(e1.pipe(takeLast(42))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should go on forever on never", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(takeLast(42))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should be empty on takeLast(0)", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b----c---d--|")
      const expected = "   |"
      const e1subs: string[] = [] // Don't subscribe at all
      expectObservable(e1.pipe(takeLast(0))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should take one value from an observable with one value", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---(a|)")
      const e1subs = "  ^--!   "
      const expected = "---(a|)"
      expectObservable(e1.pipe(takeLast(1))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should take one value from an observable with many values", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^--b----c---d--|   ")
      const e1subs = "     ^--------------!   "
      const expected = "   ---------------(d|)"
      expectObservable(e1.pipe(takeLast(1))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should error on empty", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^----|")
      const e1subs = "     ^----!"
      const expected = "   -----|"
      expectObservable(e1.pipe(takeLast(42))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should propagate error from the source observable", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^---#", undefined, "too bad")
      const e1subs = "   ^---!"
      const expected = " ----#"
      expectObservable(e1.pipe(takeLast(42))).toBe(expected, null, "too bad")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should propagate error from an observable with values", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^--a--b--#")
      const e1subs = "   ^--------!"
      const expected = " ---------#"
      expectObservable(e1.pipe(takeLast(42))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^--a--b-----c--d--e--|")
      const unsub = "    ---------!            "
      const e1subs = "   ^--------!            "
      const expected = " ----------------------"
      expectObservable(e1.pipe(takeLast(42)), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work with throw", () => {
    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #")
      const e1subs = "  (^!)"
      const expected = "#"
      expectObservable(e1.pipe(takeLast(42))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chain when unsubscribed explicitly", () => {
    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("---^--a--b-----c--d--e--|")
      const unsub = "    ---------!            "
      const e1subs = "   ^--------!            "
      const expected = " ----------------------"
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        takeLast(42),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
})
import { takeUntil, mergeMap } from "rxjs/operators"
import { of, EMPTY } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {takeUntil} */
describe("takeUntil operator", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should take values until notifier emits", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--f--g--|")
      const e1subs = "  ^------------!          "
      const e2 = hot("  -------------z--|       ")
      const e2subs = "  ^------------!          "
      const expected = "--a--b--c--d-|          "
      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should take values and raises error when notifier raises error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--f--g--|")
      const e1subs = "  ^------------!          "
      const e2 = hot("  -------------#          ")
      const e2subs = "  ^------------!          "
      const expected = "--a--b--c--d-#          "
      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should take all values when notifier is empty", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--f--g--|")
      const e1subs = "  ^----------------------!"
      const e2 = hot("  -------------|          ")
      const e2subs = "  ^------------!          "
      const expected = "--a--b--c--d--e--f--g--|"
      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should take all values when notifier does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--f--g--|")
      const e1subs = "  ^----------------------!"
      const e2 = hot("  -                       ")
      const e2subs = "  ^----------------------!"
      const expected = "--a--b--c--d--e--f--g--|"
      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should complete without subscribing to the source when notifier synchronously emits", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----a--|")
      const e2 = of(1, 2, 3)
      const expected = "(|)     "
      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe([])
    })
  })
  it("should subscribe to the source when notifier synchronously completes without emitting", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----a--|")
      const e1subs = "  ^------!"
      const e2 = EMPTY
      const expected = "----a--|"
      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--f--g--|")
      const e1subs = "  ^------!                "
      const e2 = hot("  -------------z--|       ")
      const e2subs = "  ^------!                "
      const unsub = "   -------!                "
      const expected = "--a--b--                "
      expectObservable(e1.pipe(takeUntil(e2)), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should complete when notifier emits if source observable does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -        ")
      const e1subs = "  ^-!      "
      const e2 = hot("  --a--b--|")
      const e2subs = "  ^-!      "
      const expected = "--|      "
      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise error when notifier raises error if source observable does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -  ")
      const e1subs = "  ^-!"
      const e2 = hot("  --#")
      const e2subs = "  ^-!"
      const expected = "--#"
      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not complete when notifier is empty if source observable does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -  ")
      const e1subs = "  ^  "
      const e2 = hot("  --|")
      const e2subs = "  ^-!"
      const expected = "---"
      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not complete when source and notifier do not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -")
      const e1subs = "  ^"
      const e2 = hot("  -")
      const e2subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should complete when notifier emits before source observable emits", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ----a--|")
      const e1subs = "  ^-!     "
      const e2 = hot("  --x     ")
      const e2subs = "  ^-!     "
      const expected = "--|     "
      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise error if source raises error before notifier emits", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--#     ")
      const e1subs = "  ^-------------!     "
      const e2 = hot("  ----------------a--|")
      const e2subs = "  ^-------------!     "
      const expected = "--a--b--c--d--#     "
      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should raise error immediately if source throws", () => {
    testScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" #   ")
        const e1subs = "  (^!)"
        const e2 = hot("  --x ")
        const e2subs = "  (^!)"
        const expected = "#   "
        expectObservable(e1.pipe(takeUntil(e2))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should dispose source observable if notifier emits before source emits", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---a---|")
      const e1subs = "  ^-!     "
      const e2 = hot("  --x-|   ")
      const e2subs = "  ^-!     "
      const expected = "--|     "
      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should dispose notifier if source observable completes", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--|     ")
      const e1subs = "  ^----!     "
      const e2 = hot("  -------x--|")
      const e2subs = "  ^----!     "
      const expected = "--a--|     "
      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should not break unsubscription chain when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b--c--d--e--f--g--|")
      const e1subs = "  ^------!                "
      const e2 = hot("  -------------z--|       ")
      const e2subs = "  ^------!                "
      const unsub = "   -------!                "
      const expected = "--a--b--                "
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        takeUntil(e2),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
})
import { expect } from "chai"
import { takeWhile, tap, mergeMap } from "rxjs/operators"
import { of, Observable, from } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {takeWhile} */
describe("takeWhile", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should take all elements until predicate is false", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-1-^2--3--4--5--6--|")
      const e1subs = "   ^------!         "
      const expected = " -2--3--|         "
      const result = e1.pipe(takeWhile(v => +v < 4))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should take all elements with predicate returns true", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^-b--c--d--e--|")
      const e1subs = "    ^-------------!"
      const expected = "  --b--c--d--e--|"
      const result = e1.pipe(takeWhile(() => true))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should take all elements with truthy predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^-b--c--d--e--|")
      const e1subs = "    ^-------------!"
      const expected = "  --b--c--d--e--|"
      const result = e1.pipe(
        takeWhile(<any>(() => {
          return {}
        }))
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should skip all elements with predicate returns false", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^-b--c--d--e--|")
      const e1subs = "    ^-!            "
      const expected = "  --|            "
      const result = e1.pipe(takeWhile(() => false))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should skip all elements with falsy predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^-b--c--d--e--|")
      const e1subs = "    ^-!            "
      const expected = "  --|            "
      const result = e1.pipe(takeWhile(() => null as any))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should take all elements until predicate return false", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^-b--c--d--e--|")
      const e1subs = "    ^-------!      "
      const expected = "  --b--c--|      "
      function predicate(value: string) {
        return value !== "d"
      }
      const result = e1.pipe(takeWhile(predicate))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should take all elements up to and including the element that made the predicate return false", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^-b--c--d--e--|")
      const e1subs = "    ^-------!      "
      const expected = "  --b--c--(d|)   "
      function predicate(value: string) {
        return value !== "d"
      }
      const inclusive = true
      const result = e1.pipe(takeWhile(predicate, inclusive))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should take elements with predicate when source does not complete", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^-b--c--d--e--")
      const e1subs = "    ^-------------"
      const expected = "  --b--c--d--e--"
      const result = e1.pipe(takeWhile(() => true))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not complete when source never completes", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      const result = e1.pipe(takeWhile(() => true))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should complete when source does not emit", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^------------|")
      const e1subs = "    ^------------!"
      const expected = "  -------------|"
      const result = e1.pipe(takeWhile(() => true))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should complete when source is empty", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      const result = e1.pipe(takeWhile(() => true))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should pass element index to predicate", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^-b--c--d--e--|")
      const e1subs = "    ^-------!      "
      const expected = "  --b--c--|      "
      function predicate(value: string, index: number) {
        return index < 2
      }
      const result = e1.pipe(takeWhile(predicate))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error when source raises error", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^-b--c--d--e--#")
      const e1subs = "    ^-------------!"
      const expected = "  --b--c--d--e--#"
      const result = e1.pipe(takeWhile(() => true))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error when source throws", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      const result = e1.pipe(takeWhile(() => true))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should invoke predicate until return false", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^-b--c--d--e--|")
      const e1subs = "    ^-------!      "
      const expected = "  --b--c--|      "
      let invoked = 0
      function predicate(value: string) {
        invoked++
        return value !== "d"
      }
      const result = e1.pipe(
        takeWhile(predicate),
        tap({
          complete: () => {
            expect(invoked).to.equal(3)
          },
        })
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if predicate throws", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^-b--c--d--e--|")
      const e1subs = "    ^-!            "
      const expected = "  --#            "
      function predicate(value: string) {
        throw "error"
      }
      const result = e1.pipe(takeWhile(<any>predicate))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should take elements until unsubscribed", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^-b--c--d--e--|")
      const unsub = "     -----!         "
      const e1subs = "    ^----!         "
      const expected = "  --b---         "
      function predicate(value: string) {
        return value !== "d"
      }
      const result = e1.pipe(takeWhile(predicate))
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chain when unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a-^-b--c--d--e--|")
      const unsub = "     -----!         "
      const e1subs = "    ^----!         "
      const expected = "  --b---         "
      function predicate(value: string) {
        return value !== "d"
      }
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        takeWhile(predicate),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should support type guards without breaking previous behavior", () => {
    // type guards with interfaces and classes
    {
      interface Bar {
        bar?: string
      }
      interface Baz {
        baz?: number
      }
      class Foo implements Bar, Baz {
        constructor(public bar: string = "name", public baz: number = 42) {}
      }
      const isBar = (x: any): x is Bar => x && (<Bar>x).bar !== undefined
      const foo: Foo = new Foo()
      of(foo)
        .pipe(takeWhile(foo => foo.baz === 42))
        .subscribe(x => x.baz) // x is still Foo
      of(foo)
        .pipe(takeWhile(isBar))
        .subscribe(x => x.bar) // x is Bar!
      const foobar: Bar = new Foo() // type is interface, not the class
      of(foobar)
        .pipe(takeWhile(foobar => foobar.bar === "name"))
        .subscribe(x => x.bar) // <-- x is still Bar
      of(foobar)
        .pipe(takeWhile(isBar))
        .subscribe(x => x.bar) // <--- x is Bar!
      const barish = { bar: "quack", baz: 42 } // type can quack like a Bar
      of(barish)
        .pipe(takeWhile(x => x.bar === "quack"))
        .subscribe(x => x.bar) // x is still { bar: string; baz: number; }
      of(barish)
        .pipe(takeWhile(isBar))
        .subscribe(bar => bar.bar) // x is Bar!
    }
    // type guards with primitive types
    {
      const xs: Observable<string | number> = from([1, "aaa", 3, "bb"])
      // This type guard will narrow a `string | number` to a string in the examples below
      const isString = (x: string | number): x is string =>
        typeof x === "string"
      xs.pipe(takeWhile(isString)).subscribe(s => s.length) // s is string
      // In contrast, this type of regular boolean predicate still maintains the original type
      xs.pipe(takeWhile(x => typeof x === "number")).subscribe(x => x) // x is still string | number
      xs.pipe(takeWhile((x, i) => typeof x === "number" && x > i)).subscribe(
        x => x
      ) // x is still string | number
    }
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(takeWhile(value => value < 2)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { tap, mergeMap, take } from "rxjs/operators"
import {
  Subject,
  of,
  throwError,
  Observer,
  EMPTY,
  Observable,
  noop,
} from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {tap} */
describe("tap", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should mirror multiple values and complete", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --1--2--3--|")
      const e1subs = "  ^----------!"
      const expected = "--1--2--3--|"
      const result = e1.pipe(
        tap(() => {
          //noop
        })
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should next with a callback", () => {
    let value = null
    of(42)
      .pipe(
        tap(function (x) {
          value = x
        })
      )
      .subscribe()
    expect(value).to.equal(42)
  })
  it("should error with a callback", () => {
    let err = null
    throwError(() => "bad")
      .pipe(
        tap({
          error: function (x) {
            err = x
          },
        })
      )
      .subscribe({
        error(ex) {
          expect(ex).to.equal("bad")
        },
      })
    expect(err).to.equal("bad")
  })
  it("should handle everything with an observer", done => {
    const expected = [1, 2, 3]
    const results: number[] = []
    of(1, 2, 3)
      .pipe(
        tap(<Observer<number>>{
          next: (x: number) => {
            results.push(x)
          },
          error: () => {
            done(new Error("should not be called"))
          },
          complete: () => {
            expect(results).to.deep.equal(expected)
            done()
          },
        })
      )
      .subscribe()
  })
  it("should handle everything with a Subject", done => {
    const expected = [1, 2, 3]
    const results: number[] = []
    const subject = new Subject<number>()
    subject.subscribe({
      next: (x: any) => {
        results.push(x)
      },
      error: () => {
        done(new Error("should not be called"))
      },
      complete: () => {
        expect(results).to.deep.equal(expected)
        done()
      },
    })
    of(1, 2, 3).pipe(tap(subject)).subscribe()
  })
  it("should handle an error with a callback", () => {
    let errored = false
    throwError(() => "bad")
      .pipe(
        tap({
          error: (err: any) => {
            expect(err).to.equal("bad")
          },
        })
      )
      .subscribe({
        error(err: any) {
          errored = true
          expect(err).to.equal("bad")
        },
      })
    expect(errored).to.be.true
  })
  it("should handle an error with observer", () => {
    let errored = false
    throwError(() => "bad")
      .pipe(
        tap(<any>{
          error: function (err: string) {
            expect(err).to.equal("bad")
          },
        })
      )
      .subscribe({
        error(err) {
          errored = true
          expect(err).to.equal("bad")
        },
      })
    expect(errored).to.be.true
  })
  it("should handle complete with observer", () => {
    let completed = false
    EMPTY.pipe(
      tap(<any>{
        complete: () => {
          completed = true
        },
      })
    ).subscribe()
    expect(completed).to.be.true
  })
  it("should handle next with observer", () => {
    let value = null
    of("hi")
      .pipe(
        tap(<any>{
          next: (x: string) => {
            value = x
          },
        })
      )
      .subscribe()
    expect(value).to.equal("hi")
  })
  it("should raise error if next handler raises error", () => {
    of("hi")
      .pipe(
        tap(<any>{
          next: () => {
            throw new Error("bad")
          },
        })
      )
      .subscribe({
        error(err: any) {
          expect(err.message).to.equal("bad")
        },
      })
  })
  it("should raise error if error handler raises error", () => {
    throwError(() => "ops")
      .pipe(
        tap(<any>{
          error: () => {
            throw new Error("bad")
          },
        })
      )
      .subscribe({
        error(err: any) {
          expect(err.message).to.equal("bad")
        },
      })
  })
  it("should raise error if complete handler raises error", () => {
    EMPTY.pipe(
      tap(<any>{
        complete: () => {
          throw new Error("bad")
        },
      })
    ).subscribe({
      error(err: any) {
        expect(err.message).to.equal("bad")
      },
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --1--2--3--#")
      const unsub = "   -------!    "
      const e1subs = "  ^------!    "
      const expected = "--1--2--    "
      const result = e1.pipe(
        tap(() => {
          //noop
        })
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --1--2--3--#")
      const e1subs = "  ^------!    "
      const expected = "--1--2--    "
      const unsub = "   -------!    "
      const result = e1.pipe(
        mergeMap((x: any) => of(x)),
        tap(() => {
          //noop
        }),
        mergeMap((x: any) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should mirror multiple values and complete", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --1--2--3--|")
      const e1subs = "  ^----------!"
      const expected = "--1--2--3--|"
      const result = e1.pipe(
        tap(() => {
          //noop
        })
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should mirror multiple values and terminate with error", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" --1--2--3--#")
      const e1subs = "  ^----------!"
      const expected = "--1--2--3--#"
      const result = e1.pipe(
        tap(() => {
          //noop
        })
      )
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        tap(() => {
          /* noop */
        }),
        take(3)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
  describe("lifecycle handlers", () => {
    it("should support an unsubscribe event that fires before finalize", () => {
      const results: any[] = []
      const subject = new Subject<number>()
      const subscription = subject
        .pipe(
          tap({
            subscribe: () => results.push("subscribe"),
            next: value => results.push(`next ${value}`),
            error: err => results.push(`error: ${err.message}`),
            complete: () => results.push("complete"),
            unsubscribe: () => results.push("unsubscribe"),
            finalize: () => results.push("finalize"),
          })
        )
        .subscribe()
      subject.next(1)
      subject.next(2)
      expect(results).to.deep.equal(["subscribe", "next 1", "next 2"])
      subscription.unsubscribe()
      expect(results).to.deep.equal([
        "subscribe",
        "next 1",
        "next 2",
        "unsubscribe",
        "finalize",
      ])
    })
    it("should not call unsubscribe if source completes", () => {
      const results: any[] = []
      const subject = new Subject<number>()
      const subscription = subject
        .pipe(
          tap({
            subscribe: () => results.push("subscribe"),
            next: value => results.push(`next ${value}`),
            error: err => results.push(`error: ${err.message}`),
            complete: () => results.push("complete"),
            unsubscribe: () => results.push("unsubscribe"),
            finalize: () => results.push("finalize"),
          })
        )
        .subscribe()
      subject.next(1)
      subject.next(2)
      expect(results).to.deep.equal(["subscribe", "next 1", "next 2"])
      subject.complete()
      // should have no effect
      subscription.unsubscribe()
      expect(results).to.deep.equal([
        "subscribe",
        "next 1",
        "next 2",
        "complete",
        "finalize",
      ])
    })
    it("should not call unsubscribe if source errors", () => {
      const results: any[] = []
      const subject = new Subject<number>()
      const subscription = subject
        .pipe(
          tap({
            subscribe: () => results.push("subscribe"),
            next: value => results.push(`next ${value}`),
            error: err => results.push(`error: ${err.message}`),
            complete: () => results.push("complete"),
            unsubscribe: () => results.push("unsubscribe"),
            finalize: () => results.push("finalize"),
          })
        )
        .subscribe({
          error: noop,
        })
      subject.next(1)
      subject.next(2)
      expect(results).to.deep.equal(["subscribe", "next 1", "next 2"])
      subject.error(new Error("bad"))
      // should have no effect
      subscription.unsubscribe()
      expect(results).to.deep.equal([
        "subscribe",
        "next 1",
        "next 2",
        "error: bad",
        "finalize",
      ])
    })
  })
})
import { expect } from "chai"
import { TestScheduler } from "rxjs/internal/testing/TestScheduler"
import { observableMatcher } from "../helpers/observableMatcher"
import { throttle, mergeMap, take } from "rxjs/operators"
import { of, Observable } from "rxjs"
/** @test {throttle} */
describe("throttle", () => {
  let testScheduler: TestScheduler
  beforeEach(() => {
    testScheduler = new TestScheduler(observableMatcher)
  })
  it("should immediately emit the first value in each time window", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a-xy-----b--x--cxyz-|")
        const e1subs = "  ^--------------------!"
        const e2 = cold("  ----i                ")
        //                          ----i
        //                                ----i
        const e2subs = [
          "               -^---!                ",
          "               ----------^---!       ",
          "               ----------------^---! ",
        ]
        const expected = "-a--------b-----c----|"
        const result = e1.pipe(throttle(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should handle sync source with sync notifier and trailing appropriately", () => {
    const results: any[] = []
    const source = of(1).pipe(
      throttle(() => of(1), { leading: false, trailing: true })
    )
    source.subscribe({
      next: value => results.push(value),
      complete: () => results.push("done"),
    })
    expect(results).to.deep.equal([1, "done"])
  })
  it("should simply mirror the source if values are not emitted often enough", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ^a--------b-----c----|")
        const e1subs = "  ^--------------------!"
        const e2 = cold("  ----|                ")
        const e2subs = [
          "               -^---!                ",
          "               ----------^---!       ",
          "               ----------------^---! ",
        ]
        const expected = "-a--------b-----c----|"
        const result = e1.pipe(throttle(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should throttle with duration Observable using next to close the duration", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ^a-xy-----b--x--cxxx-|")
        const e1subs = "  ^--------------------!"
        const e2 = cold("  ----x-y-z            ")
        const e2subs = [
          "               -^---!                ",
          "               ----------^---!       ",
          "               ----------------^---! ",
        ]
        const expected = "-a--------b-----c----|"
        const result = e1.pipe(throttle(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should interrupt source and duration when result is unsubscribed early", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a-x-y-z-xyz-x-y-z----b--x-x-|")
        const unsub = "   --------------!               "
        const e1subs = "  ^-------------!               "
        const e2 = cold("  ---------------------|       ")
        const e2subs = "  -^------------!               "
        const expected = "-a-------------               "
        const result = e1.pipe(throttle(() => e2))
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a-x-y-z-xyz-x-y-z----b--x-x-|")
        const e1subs = "  ^-------------!               "
        const e2 = cold("  ------------------|           ")
        const e2subs = "  -^------------!               "
        const expected = "-a-------------               "
        const unsub = "   --------------!               "
        const result = e1.pipe(
          mergeMap((x: string) => of(x)),
          throttle(() => e2),
          mergeMap((x: string) => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should handle a busy producer emitting a regular repeating sequence", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  abcdefabcdefabcdefabcdefa|")
        const e1subs = "  ^------------------------!"
        const e2 = cold(" -----|                    ")
        const e2subs = [
          "               ^----!                    ",
          "               ------^----!              ",
          "               ------------^----!        ",
          "               ------------------^----!  ",
          "               ------------------------^!",
        ]
        const expected = "a-----a-----a-----a-----a|"
        const result = e1.pipe(throttle(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should mirror source if durations are immediate", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  abcdefabcdefabcdefabcdefa|")
        const e1subs = "  ^------------------------!"
        const e2 = cold(" x                         ")
        const expected = "abcdefabcdefabcdefabcdefa|"
        const result = e1.pipe(throttle(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should mirror source if durations are empty", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  abcdefabcdefabcdefabcdefa|")
        const e1subs = "  ^------------------------!"
        const e2 = cold(" |                         ")
        const expected = "abcdefabcdefabcdefabcdefa|"
        const result = e1.pipe(throttle(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should take only the first value emitted if duration is a never", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ----abcdefabcdefabcdefabcdefa|")
        const e1subs = "  ^----------------------------!"
        const e2 = cold(" -                             ")
        const e2subs = "  ----^------------------------!"
        const expected = "----a------------------------|"
        const result = e1.pipe(throttle(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should unsubscribe duration Observable when source raise error", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ----abcdefabcdefabcdefabcdefa#")
        const e1subs = "  ^----------------------------!"
        const e2 = cold(" -                             ")
        const e2subs = "  ----^------------------------!"
        const expected = "----a------------------------#"
        const result = e1.pipe(throttle(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should raise error as soon as just-throw duration is used", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  ----abcdefabcdefabcdefabcdefa|")
        const e1subs = "  ^---!-------------------------"
        const e2 = cold(" #                             ")
        const e2subs = "  ----(^!)                      "
        const expected = "----(a#)                      "
        const result = e1.pipe(throttle(() => e2))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should throttle using durations of varying lengths", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  abcdefabcdabcdefghabca|   ")
        const e1subs = "  ^---------------------!   "
        const e2 = [
          cold("          -----|                    "),
          cold("                ---|                "),
          cold("                    -------|        "),
          cold("                            --|     "),
          cold("                               ----|"),
        ]
        const e2subs = [
          "               ^----!                    ",
          "               ------^--!                ",
          "               ----------^------!        ",
          "               ------------------^-!     ",
          "               ---------------------^!   ",
        ]
        const expected = "a-----a---a-------a--a|   "
        let i = 0
        const result = e1.pipe(throttle(() => e2[i++]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        for (let j = 0; j < e2.length; j++) {
          expectSubscriptions(e2[j].subscriptions).toBe(e2subs[j])
        }
      }
    )
  })
  it("should propagate error from duration Observable", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  abcdefabcdabcdefghabca|   ")
        const e1subs = "  ^----------------!        "
        const e2 = [
          cold("          -----|                    "),
          cold("                ---|                "),
          cold("                    -------#        "),
        ]
        const e2subs = [
          "               ^----!                    ",
          "               ------^--!                ",
          "               ----------^------!        ",
        ]
        const expected = "a-----a---a------#        "
        let i = 0
        const result = e1.pipe(throttle(() => e2[i++]))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        for (let j = 0; j < e2.length; j++) {
          expectSubscriptions(e2[j].subscriptions).toBe(e2subs[j])
        }
      }
    )
  })
  it("should propagate error thrown from durationSelector function", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const s1 = hot(" --^--x--x--x--x--x--x--e--x--x--x--|")
        const s1Subs = " ^--------------------!              "
        const n1 = cold("----|                               ")
        const n1Subs = [
          "              ---^---!                            ",
          "              ---------^---!                      ",
          "              ---------------^---!                ",
        ]
        const exp = "    ---x-----x-----x-----(e#)           "
        let i = 0
        const result = s1.pipe(
          throttle(() => {
            if (i++ === 3) {
              throw new Error("lol")
            }
            return n1
          })
        )
        expectObservable(result).toBe(exp, undefined, new Error("lol"))
        expectSubscriptions(s1.subscriptions).toBe(s1Subs)
        expectSubscriptions(n1.subscriptions).toBe(n1Subs)
      }
    )
  })
  it("should complete when source does not emit", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -----|")
        const subs = "    ^----!"
        const expected = "-----|"
        function durationSelector() {
          return cold("-----|")
        }
        expectObservable(e1.pipe(throttle(durationSelector))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      }
    )
  })
  it("should raise error when source does not emit and raises error", () => {
    testScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -----#")
        const subs = "    ^----!"
        const expected = "-----#"
        function durationSelector() {
          return cold("-----|")
        }
        expectObservable(e1.pipe(throttle(durationSelector))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      }
    )
  })
  it("should handle an empty source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |     ")
      const subs = "    (^!)  "
      const expected = "|     "
      function durationSelector() {
        return cold("-----|")
      }
      expectObservable(e1.pipe(throttle(durationSelector))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should handle a never source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -     ")
      const subs = "    ^     "
      const expected = "-     "
      function durationSelector() {
        return cold("-----|")
      }
      expectObservable(e1.pipe(throttle(durationSelector))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  it("should handle a throw source", () => {
    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #     ")
      const subs = "    (^!)  "
      const expected = "#     "
      function durationSelector() {
        return cold("-----|")
      }
      expectObservable(e1.pipe(throttle(durationSelector))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(subs)
    })
  })
  describe("throttle(fn, { leading: true, trailing: true })", () => {
    it("should immediately emit the first value in each time window", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const e1 = hot("  -a-xy-----b--x--cxxx------|")
          const e1subs = "  ^-------------------------!"
          const e2 = cold("  ----x                     ")
          const e2subs = [
            "               -^---!                     ",
            "               -----^---!                 ",
            "               ----------^---!            ",
            "               --------------^---!        ",
            "               ------------------^---!    ",
            "               ----------------------^---!",
          ]
          const expected = "-a---y----b---x---x---x---|"
          const result = e1.pipe(
            throttle(() => e2, { leading: true, trailing: true })
          )
          expectObservable(result).toBe(expected)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
          expectSubscriptions(e2.subscriptions).toBe(e2subs)
        }
      )
    })
    it("should work for individual values", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const s1 = hot("-^-x------------------|     ")
          const s1Subs = " ^--------------------!     "
          const n1 = cold("  ------------------------|")
          const n1Subs = ["--^------------------!     "]
          const exp = "    --x------------------|     "
          const result = s1.pipe(
            throttle(() => n1, { leading: true, trailing: true })
          )
          expectObservable(result).toBe(exp)
          expectSubscriptions(s1.subscriptions).toBe(s1Subs)
          expectSubscriptions(n1.subscriptions).toBe(n1Subs)
        }
      )
    })
    it("should emit trailing value after throttle duration when source completes", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const e1 = hot("  -a--------xy|     ")
          const e1subs = "  ^-----------!     "
          const e2 = cold("  ----x            ")
          const e2subs = [
            // because prettier
            "               -^---!            ",
            "               ----------^---!   ",
          ]
          const expected = "-a--------x---(y|)"
          const result = e1.pipe(
            throttle(() => e2, { leading: true, trailing: true })
          )
          expectObservable(result).toBe(expected)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
          expectSubscriptions(e2.subscriptions).toBe(e2subs)
        }
      )
    })
  })
  describe("throttle(fn, { leading: false, trailing: true })", () => {
    it("should immediately emit the first value in each time window", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const e1 = hot("  -a-xy-----b--x--cxxx------|")
          const e1subs = "  ^-------------------------!"
          const e2 = cold("  ----x                     ")
          const e2subs = [
            "               -^---!                     ",
            "               -----^---!                 ",
            "               ----------^---!            ",
            "               --------------^---!        ",
            "               ------------------^---!    ",
            "               ----------------------^---!",
          ]
          const expected = "-----y--------x---x---x---|"
          const result = e1.pipe(
            throttle(() => e2, { leading: false, trailing: true })
          )
          expectObservable(result).toBe(expected)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
          expectSubscriptions(e2.subscriptions).toBe(e2subs)
        }
      )
    })
    it("should work for individual values", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const s1 = hot("-^-x------------------|        ")
          const s1Subs = " ^--------------------!        "
          const n1 = cold("  ------------------------x   ")
          const n1Subs = ["--^-----------------------!   "]
          const exp = "    --------------------------(x|)"
          const result = s1.pipe(
            throttle(() => n1, { leading: false, trailing: true })
          )
          expectObservable(result).toBe(exp)
          expectSubscriptions(s1.subscriptions).toBe(s1Subs)
          expectSubscriptions(n1.subscriptions).toBe(n1Subs)
        }
      )
    })
    it("should wait for trailing throttle before completing, even if source completes", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const source = hot("  -^--x--------y---------|        ")
          const sourceSubs = "   ^---------------------!        "
          const duration = cold("   ------------------------x   ")
          const durationSubs = " ---^-----------------------!   "
          const exp = "          ---------------------------(y|)"
          const result = source.pipe(
            throttle(() => duration, { leading: false, trailing: true })
          )
          expectObservable(result).toBe(exp)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
          expectSubscriptions(duration.subscriptions).toBe(durationSubs)
        }
      )
    })
    it("should emit trailing value after throttle duration when source completes", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const e1 = hot("  -a--------x|   ")
          const e1subs = "  ^----------!   "
          const e2 = cold("  ----x         ")
          const e2subs = [
            // because prettier
            "               -^---!         ",
            "               -----^---!     ",
            "               ----------^---!",
          ]
          const expected = "-----a--------(x|)"
          const result = e1.pipe(
            throttle(() => e2, { leading: false, trailing: true })
          )
          expectObservable(result).toBe(expected)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
          expectSubscriptions(e2.subscriptions).toBe(e2subs)
        }
      )
    })
    it("should emit the last trailing value after throttle duration when source completes", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const e1 = hot("  -a--------xy|  ")
          const e1subs = "  ^-----------!  "
          const e2 = cold("  ----x         ")
          const e2subs = [
            // because prettier
            "               -^---!         ",
            "               -----^---!     ",
            "               ----------^---!",
          ]
          const expected = "-----a--------(y|)"
          const result = e1.pipe(
            throttle(() => e2, { leading: false, trailing: true })
          )
          expectObservable(result).toBe(expected)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
          expectSubscriptions(e2.subscriptions).toBe(e2subs)
        }
      )
    })
    it("should complete when source completes if no value is available", () => {
      testScheduler.run(
        ({ cold, hot, expectObservable, expectSubscriptions }) => {
          const e1 = hot("  -a-----|")
          const e1subs = "  ^------!"
          const e2 = cold("  ----x  ")
          const e2subs = [
            // because prettier
            "               -^---!  ",
            "               -----^-!",
          ]
          const expected = "-----a-|"
          const result = e1.pipe(
            throttle(() => e2, { leading: false, trailing: true })
          )
          expectObservable(result).toBe(expected)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
          expectSubscriptions(e2.subscriptions).toBe(e2subs)
        }
      )
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(
        throttle(() => of(0)),
        take(3)
      )
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { throttleTime, take, map, mergeMap } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of, concat, timer } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {throttleTime} */
describe("throttleTime operator", () => {
  let rxTest: TestScheduler
  beforeEach(() => {
    rxTest = new TestScheduler(observableMatcher)
  })
  describe("default behavior { leading: true, trailing: false }", () => {
    it("should immediately emit the first value in each time window", () => {
      rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a-x-y----b---x-cx---|")
        //                 ----|    ----| ----|
        const expected = "-a--------b-----c----|"
        const subs = "    ^--------------------!"
        const result = e1.pipe(throttleTime(5, rxTest))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      })
    })
    it("should throttle events by 5 time units", done => {
      of(1, 2, 3)
        .pipe(throttleTime(5))
        .subscribe({
          next: (x: number) => {
            expect(x).to.equal(1)
          },
          complete: done,
        })
    })
    it("should throttle events multiple times", () => {
      const expected = ["1-0", "2-0"]
      concat(
        timer(0, 1, rxTest).pipe(
          take(3),
          map((x: number) => "1-" + x)
        ),
        timer(8, 1, rxTest).pipe(
          take(5),
          map((x: number) => "2-" + x)
        )
      )
        .pipe(throttleTime(5, rxTest))
        .subscribe((x: string) => {
          expect(x).to.equal(expected.shift())
        })
      rxTest.flush()
    })
    it("should simply mirror the source if values are not emitted often enough", () => {
      rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a--------b-----c----|")
        const subs = "    ^--------------------!"
        const expected = "-a--------b-----c----|"
        expectObservable(e1.pipe(throttleTime(5, rxTest))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      })
    })
    it("should handle a busy producer emitting a regular repeating sequence", () => {
      rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  abcdefabcdefabcdefabcdefa|")
        const subs = "    ^------------------------!"
        const expected = "a-----a-----a-----a-----a|"
        expectObservable(e1.pipe(throttleTime(5, rxTest))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      })
    })
    it("should complete when source does not emit", () => {
      rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -----|")
        const subs = "    ^----!"
        const expected = "-----|"
        expectObservable(e1.pipe(throttleTime(5, rxTest))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      })
    })
    it("should raise error when source does not emit and raises error", () => {
      rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -----#")
        const subs = "    ^----!"
        const expected = "-----#"
        expectObservable(e1.pipe(throttleTime(10, rxTest))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      })
    })
    it("should handle an empty source", () => {
      rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" |")
        const subs = "    (^!)"
        const expected = "|"
        expectObservable(e1.pipe(throttleTime(30, rxTest))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      })
    })
    it("should handle a never source", () => {
      rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" -")
        const subs = "    ^"
        const expected = "-"
        expectObservable(e1.pipe(throttleTime(30, rxTest))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      })
    })
    it("should handle a throw source", () => {
      rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {
        const e1 = cold(" #")
        const subs = "    (^!)"
        const expected = "#"
        expectObservable(e1.pipe(throttleTime(30, rxTest))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      })
    })
    it("should throttle and does not complete when source does not completes", () => {
      rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a--(bc)-------d----------------")
        const unsub = "   -------------------------------!"
        const subs = "    ^------------------------------!"
        const expected = "-a-------------d----------------"
        expectObservable(e1.pipe(throttleTime(5, rxTest)), unsub).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      })
    })
    it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
      rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a--(bc)-------d----------------")
        const subs = "    ^------------------------------!"
        const expected = "-a-------------d----------------"
        const unsub = "   -------------------------------!"
        const result = e1.pipe(
          mergeMap((x: string) => of(x)),
          throttleTime(5, rxTest),
          mergeMap((x: string) => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      })
    })
    it("should throttle values until source raises error", () => {
      rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a--(bc)-------d---------------#")
        const subs = "    ^------------------------------!"
        const expected = "-a-------------d---------------#"
        expectObservable(e1.pipe(throttleTime(5, rxTest))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
      })
    })
  })
  describe("throttleTime(fn, { leading: true, trailing: true })", () => {
    it("should immediately emit the first and last values in each time window", () => {
      rxTest.run(({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a-xy-----b--x--cxxx--|")
        const e1subs = "  ^---------------------!"
        const t = time("   ----|                 ")
        //                     ----|----|---|---|
        const expected = "-a---y----b---x---x---(x|)"
        const result = e1.pipe(
          throttleTime(t, rxTest, { leading: true, trailing: true })
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      })
    })
    it("should emit the value if only a single one is given", () => {
      rxTest.run(({ hot, time, expectObservable }) => {
        const e1 = hot("  -a--------------------|")
        const t = time("   ----|                 ")
        const expected = "-a--------------------|"
        const result = e1.pipe(
          throttleTime(t, rxTest, { leading: true, trailing: true })
        )
        expectObservable(result).toBe(expected)
      })
    })
  })
  describe("throttleTime(fn, { leading: false, trailing: true })", () => {
    it("should immediately emit the last value in each time window", () => {
      rxTest.run(({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a-xy-----b--x--cxxx--|")
        const e1subs = "  ^---------------------!"
        const t = time("   ----|                 ")
        //                 ----|---|----|---|---|
        const expected = "-----y--------x---x---(x|)"
        const result = e1.pipe(
          throttleTime(t, rxTest, { leading: false, trailing: true })
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      })
    })
    it("should emit the last throttled value when complete", () => {
      rxTest.run(({ hot, time, expectObservable, expectSubscriptions }) => {
        const e1 = hot("  -a-xy-----b--x--cxx-|")
        const e1subs = "  ^-------------------!"
        const t = time("   ----|               ")
        //                 ----|---|----|---|---|
        const expected = "-----y--------x---x-|"
        const result = e1.pipe(
          throttleTime(t, rxTest, { leading: false, trailing: true })
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      })
    })
    it("should emit the value if only a single one is given", () => {
      rxTest.run(({ hot, time, expectObservable }) => {
        const e1 = hot("  -a--------------------|")
        const t = time("   ----|                 ")
        const expected = "-----a----------------|"
        const result = e1.pipe(
          throttleTime(t, rxTest, { leading: false, trailing: true })
        )
        expectObservable(result).toBe(expected)
      })
    })
  })
})
import { expect } from "chai"
import { EMPTY, of, EmptyError, defer, throwError, Observable } from "rxjs"
import { throwIfEmpty, mergeMap, retry, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {throwIfEmpty} */
describe("throwIfEmpty", () => {
  let rxTestScheduler: TestScheduler
  beforeEach(() => {
    rxTestScheduler = new TestScheduler(observableMatcher)
  })
  describe("with errorFactory", () => {
    it("should error when empty", () => {
      rxTestScheduler.run(({ cold, expectObservable }) => {
        const source = cold("----|")
        const expected = "   ----#"
        const result = source.pipe(throwIfEmpty(() => new Error("test")))
        expectObservable(result).toBe(expected, undefined, new Error("test"))
      })
    })
    it("should throw if empty", () => {
      const error = new Error("So empty inside")
      let thrown: any
      EMPTY.pipe(throwIfEmpty(() => error)).subscribe({
        error(err) {
          thrown = err
        },
      })
      expect(thrown).to.equal(error)
    })
    it("should NOT throw if NOT empty", () => {
      const error = new Error("So empty inside")
      let thrown: any
      of("test")
        .pipe(throwIfEmpty(() => error))
        .subscribe({
          error(err) {
            thrown = err
          },
        })
      expect(thrown).to.be.undefined
    })
    it("should pass values through", () => {
      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
        const source = cold("----a---b---c---|")
        const sub1 = "       ^---------------!"
        const expected = "   ----a---b---c---|"
        const result = source.pipe(throwIfEmpty(() => new Error("test")))
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe([sub1])
      })
    })
    it("should never when never", () => {
      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
        const source = cold("-")
        const sub1 = "       ^"
        const expected = "   -"
        const result = source.pipe(throwIfEmpty(() => new Error("test")))
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe([sub1])
      })
    })
    it("should error when empty", () => {
      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
        const source = cold("----|")
        const sub1 = "       ^---!"
        const expected = "   ----#"
        const result = source.pipe(throwIfEmpty(() => new Error("test")))
        expectObservable(result).toBe(expected, undefined, new Error("test"))
        expectSubscriptions(source.subscriptions).toBe([sub1])
      })
    })
    it("should throw if empty after retry", () => {
      const error = new Error("So empty inside")
      let thrown: any
      let sourceIsEmpty = false
      const source = defer(() => {
        if (sourceIsEmpty) {
          return EMPTY
        }
        sourceIsEmpty = true
        return of(1, 2)
      })
      source
        .pipe(
          throwIfEmpty(() => error),
          mergeMap(value => {
            if (value > 1) {
              return throwError(() => new Error())
            }
            return of(value)
          }),
          retry(1)
        )
        .subscribe({
          error(err) {
            thrown = err
          },
        })
      expect(thrown).to.equal(error)
    })
  })
  describe("without errorFactory", () => {
    it("should throw EmptyError if empty", () => {
      let thrown: any
      EMPTY.pipe(throwIfEmpty()).subscribe({
        error(err) {
          thrown = err
        },
      })
      expect(thrown).to.be.instanceof(EmptyError)
    })
    it("should NOT throw if NOT empty", () => {
      let thrown: any
      of("test")
        .pipe(throwIfEmpty())
        .subscribe({
          error(err) {
            thrown = err
          },
        })
      expect(thrown).to.be.undefined
    })
    it("should pass values through", () => {
      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
        const source = cold("----a---b---c---|")
        const sub1 = "       ^---------------!"
        const expected = "   ----a---b---c---|"
        const result = source.pipe(throwIfEmpty())
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe([sub1])
      })
    })
    it("should never when never", () => {
      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
        const source = cold("-")
        const sub1 = "       ^"
        const expected = "   -"
        const result = source.pipe(throwIfEmpty())
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe([sub1])
      })
    })
    it("should error when empty", () => {
      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
        const source = cold("----|")
        const sub1 = "       ^---!"
        const expected = "   ----#"
        const result = source.pipe(throwIfEmpty())
        expectObservable(result).toBe(expected, undefined, new EmptyError())
        expectSubscriptions(source.subscriptions).toBe([sub1])
      })
    })
    it("should throw if empty after retry", () => {
      let thrown: any
      let sourceIsEmpty = false
      const source = defer(() => {
        if (sourceIsEmpty) {
          return EMPTY
        }
        sourceIsEmpty = true
        return of(1, 2)
      })
      source
        .pipe(
          throwIfEmpty(),
          mergeMap(value => {
            if (value > 1) {
              return throwError(() => new Error())
            }
            return of(value)
          }),
          retry(1)
        )
        .subscribe({
          error(err) {
            thrown = err
          },
        })
      expect(thrown).to.be.instanceof(EmptyError)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(throwIfEmpty(), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { timeInterval, map, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of, Observable } from "rxjs"
import { TimeInterval } from "rxjs/internal/operators/timeInterval"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {timeInterval} */
describe("timeInterval", () => {
  let rxTestScheduler: TestScheduler
  beforeEach(() => {
    rxTestScheduler = new TestScheduler(observableMatcher)
  })
  it("should record the time interval between source elements", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^b-c-----d--e--|")
      const e1subs = "     ^--------------!"
      const expected = "   -w-x-----y--z--|"
      const expectedValue = { w: 1, x: 2, y: 6, z: 3 }
      const result = e1.pipe(
        timeInterval(rxTestScheduler),
        map(x => x.interval)
      )
      expectObservable(result).toBe(expected, expectedValue)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should record interval if source emit elements", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^b--c----d---e--|")
      const e1subs = "     ^---------------!"
      const expected = "   -w--x----y---z--|"
      const expectedValue = {
        w: new TimeInterval("b", 1),
        x: new TimeInterval("c", 3),
        y: new TimeInterval("d", 5),
        z: new TimeInterval("e", 4),
      }
      expectObservable(e1.pipe(timeInterval(rxTestScheduler))).toBe(
        expected,
        expectedValue
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should completes without record interval if source does not emits", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---------|")
      const e1subs = "  ^--------!"
      const expected = "---------|"
      expectObservable(e1.pipe(timeInterval(rxTestScheduler))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should complete immediately if source is empty", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      expectObservable(e1.pipe(timeInterval(rxTestScheduler))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should record interval then does not completes if source emits but not completes", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -a--b--")
      const e1subs = "  ^------"
      const expected = "-y--z--"
      const expectedValue = {
        y: new TimeInterval("a", 1),
        z: new TimeInterval("b", 3),
      }
      expectObservable(e1.pipe(timeInterval(rxTestScheduler))).toBe(
        expected,
        expectedValue
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -a--b-----c---d---|")
      const unsub = "   -------!           "
      const e1subs = "  ^------!           "
      const expected = "-y--z---           "
      const expectedValue = {
        y: new TimeInterval("a", 1),
        z: new TimeInterval("b", 3),
      }
      const result = e1.pipe(timeInterval(rxTestScheduler))
      expectObservable(result, unsub).toBe(expected, expectedValue)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -a--b-----c---d---|")
      const e1subs = "  ^------!           "
      const expected = "-y--z---           "
      const unsub = "   -------!           "
      const expectedValue = {
        y: new TimeInterval("a", 1),
        z: new TimeInterval("b", 3),
      }
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        timeInterval(rxTestScheduler),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected, expectedValue)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not completes if source never completes", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(timeInterval(rxTestScheduler))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("raise error if source raises error", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---#")
      const e1subs = "  ^--!"
      const expected = "---#"
      expectObservable(e1.pipe(timeInterval(rxTestScheduler))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should record interval then raise error if source raises error after emit", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -a--b--#")
      const e1subs = "  ^------!"
      const expected = "-y--z--#"
      const expectedValue = {
        y: new TimeInterval("a", 1),
        z: new TimeInterval("b", 3),
      }
      expectObservable(e1.pipe(timeInterval(rxTestScheduler))).toBe(
        expected,
        expectedValue
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if source immediately throws", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      expectObservable(e1.pipe(timeInterval(rxTestScheduler))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(timeInterval(), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { timeout, mergeMap, take, concatWith } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { TimeoutError, of, Observable, NEVER } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {timeout} */
describe("timeout operator", () => {
  let rxTestScheduler: TestScheduler
  beforeEach(() => {
    rxTestScheduler = new TestScheduler(observableMatcher)
  })
  const defaultTimeoutError = new TimeoutError()
  it("should timeout after a specified timeout period", () => {
    rxTestScheduler.run(
      ({ cold, expectObservable, expectSubscriptions, time }) => {
        const e1 = cold(" -------a--b--|")
        const t = time("  -----|        ")
        const e1subs = "  ^----!        "
        const expected = "-----#        "
        const result = e1.pipe(timeout(t, rxTestScheduler))
        expectObservable(result).toBe(expected, null, defaultTimeoutError)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should emit and TimeoutError on timeout with appropriate due as number", () => {
    rxTestScheduler.run(({ cold, time }) => {
      const e1 = cold("-------a--b--|")
      const t = time(" -----|")
      const result = e1.pipe(timeout(t, rxTestScheduler))
      let error: any
      result.subscribe({
        next: () => {
          throw new Error("this should not next")
        },
        error: err => {
          error = err
        },
        complete: () => {
          throw new Error("this should not complete")
        },
      })
      rxTestScheduler.flush()
      expect(error).to.be.an.instanceof(TimeoutError)
      expect(error).to.have.property("name", "TimeoutError")
      expect(error!.info).to.deep.equal({
        seen: 0,
        meta: null,
        lastValue: null,
      })
    })
  })
  it("should emit and TimeoutError on timeout with appropriate due as Date", () => {
    rxTestScheduler.run(({ cold, time }) => {
      const e1 = cold("-------a--b--|")
      const t = time(" ----|")
      // 4ms from "now", considering "now" with the rxTestScheduler is currently frame 0.
      const dueDate = new Date(t)
      const result = e1.pipe(timeout(dueDate, rxTestScheduler))
      let error: any
      result.subscribe({
        next: () => {
          throw new Error("this should not next")
        },
        error: err => {
          error = err
        },
        complete: () => {
          throw new Error("this should not complete")
        },
      })
      rxTestScheduler.flush()
      expect(error).to.be.an.instanceof(TimeoutError)
      expect(error).to.have.property("name", "TimeoutError")
      expect(error!.info).to.deep.equal({
        seen: 0,
        meta: null,
        lastValue: null,
      })
    })
  })
  it("should not timeout if source completes within absolute timeout period", () => {
    rxTestScheduler.run(
      ({ hot, expectObservable, expectSubscriptions, time }) => {
        const e1 = hot("  --a--b--c--d--e--|")
        const t = time("  --------------------|")
        const e1subs = "  ^----------------!"
        const expected = "--a--b--c--d--e--|"
        // Start frame is zero.
        const timeoutValue = new Date(t)
        expectObservable(e1.pipe(timeout(timeoutValue, rxTestScheduler))).toBe(
          expected
        )
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not timeout if source emits within timeout period", () => {
    rxTestScheduler.run(
      ({ hot, expectObservable, expectSubscriptions, time }) => {
        const e1 = hot("  --a--b--c--d--e--|")
        const t = time("  -----|            ")
        const e1subs = "  ^----------------!"
        const expected = "--a--b--c--d--e--|"
        expectObservable(e1.pipe(timeout(t, rxTestScheduler))).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should allow unsubscribing explicitly and early", () => {
    rxTestScheduler.run(
      ({ hot, expectObservable, expectSubscriptions, time }) => {
        const e1 = hot("  --a--b--c---d--e--|")
        const t = time("  -----|             ")
        const unsub = "   ----------!        "
        const e1subs = "  ^---------!        "
        const expected = "--a--b--c--        "
        const result = e1.pipe(timeout(t, rxTestScheduler))
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    rxTestScheduler.run(
      ({ hot, expectObservable, expectSubscriptions, time }) => {
        const e1 = hot("  --a--b--c---d--e--|")
        const t = time("  -----|             ")
        const e1subs = "  ^---------!        "
        const expected = "--a--b--c--        "
        const unsub = "   ----------!        "
        const result = e1.pipe(
          mergeMap(x => of(x)),
          timeout(t, rxTestScheduler),
          mergeMap(x => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should timeout after a specified timeout period between emit with default error while source emits", () => {
    rxTestScheduler.run(
      ({ hot, expectObservable, expectSubscriptions, time }) => {
        const e1 = hot("  ---a---b---c------d---e---|")
        const t = time("             -----|")
        const e1subs = "  ^---------------!          "
        const expected = "---a---b---c----#          "
        const result = e1.pipe(timeout(t, rxTestScheduler))
        expectObservable(result).toBe(expected, undefined, defaultTimeoutError)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should timeout at a specified Date", () => {
    rxTestScheduler.run(
      ({ cold, expectObservable, expectSubscriptions, time }) => {
        const e1 = cold(" -")
        const t = time("  ----------|")
        const e1subs = "  ^---------!"
        const expected = "----------#"
        // Start time is zero
        const result = e1.pipe(timeout(new Date(t), rxTestScheduler))
        expectObservable(result).toBe(expected, null, defaultTimeoutError)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should work with synchronous observable", () => {
    expect(() => {
      of(1).pipe(timeout(10)).subscribe()
    }).to.not.throw()
  })
  describe("config", () => {
    it("should timeout after a specified timeout period", () => {
      rxTestScheduler.run(
        ({ cold, expectObservable, expectSubscriptions, time }) => {
          const e1 = cold(" -------a--b--|")
          const t = time("  -----|        ")
          const e1subs = "  ^----!        "
          const expected = "-----#        "
          const result = e1.pipe(
            timeout({
              each: t,
            })
          )
          expectObservable(result).toBe(expected, null, defaultTimeoutError)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should emit and TimeoutError on timeout with appropriate due as number", () => {
      rxTestScheduler.run(({ cold, time }) => {
        const e1 = cold("-------a--b--|")
        const t = time(" -----|")
        const result = e1.pipe(timeout({ each: t }))
        let error: any
        result.subscribe({
          next: () => {
            throw new Error("this should not next")
          },
          error: err => {
            error = err
          },
          complete: () => {
            throw new Error("this should not complete")
          },
        })
        rxTestScheduler.flush()
        expect(error).to.be.an.instanceof(TimeoutError)
        expect(error).to.have.property("name", "TimeoutError")
        expect(error!.info).to.deep.equal({
          seen: 0,
          meta: null,
          lastValue: null,
        })
      })
    })
    it("should emit and TimeoutError on timeout with appropriate due as Date", () => {
      rxTestScheduler.run(({ cold, time }) => {
        const e1 = cold("-------a--b--|")
        const t = time(" ----|")
        // 4ms from "now", considering "now" with the rxTestScheduler is currently frame 0.
        const dueDate = new Date(t)
        const result = e1.pipe(timeout({ first: dueDate }))
        let error: any
        result.subscribe({
          next: () => {
            throw new Error("this should not next")
          },
          error: err => {
            error = err
          },
          complete: () => {
            throw new Error("this should not complete")
          },
        })
        rxTestScheduler.flush()
        expect(error).to.be.an.instanceof(TimeoutError)
        expect(error).to.have.property("name", "TimeoutError")
        expect(error!.info).to.deep.equal({
          seen: 0,
          meta: null,
          lastValue: null,
        })
      })
    })
    it("should not timeout if source completes within absolute timeout period", () => {
      rxTestScheduler.run(
        ({ hot, expectObservable, expectSubscriptions, time }) => {
          const e1 = hot("  --a--b--c--d--e--|")
          const t = time("  --------------------|")
          const e1subs = "  ^----------------!"
          const expected = "--a--b--c--d--e--|"
          expectObservable(e1.pipe(timeout({ first: new Date(t) }))).toBe(
            expected
          )
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should not timeout if source emits within timeout period", () => {
      rxTestScheduler.run(
        ({ hot, expectObservable, expectSubscriptions, time }) => {
          const e1 = hot("  --a--b--c--d--e--|")
          const t = time("  -----|            ")
          const e1subs = "  ^----------------!"
          const expected = "--a--b--c--d--e--|"
          expectObservable(e1.pipe(timeout({ each: t }))).toBe(expected)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should allow unsubscribing explicitly and early", () => {
      rxTestScheduler.run(
        ({ hot, expectObservable, expectSubscriptions, time }) => {
          const e1 = hot("  --a--b--c---d--e--|")
          const t = time("  -----|             ")
          const unsub = "   ----------!        "
          const e1subs = "  ^---------!        "
          const expected = "--a--b--c--        "
          const result = e1.pipe(timeout({ each: t }))
          expectObservable(result, unsub).toBe(expected)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
      rxTestScheduler.run(
        ({ hot, expectObservable, expectSubscriptions, time }) => {
          const e1 = hot("  --a--b--c---d--e--|")
          const t = time("  -----|             ")
          const e1subs = "  ^---------!        "
          const expected = "--a--b--c--        "
          const unsub = "   ----------!        "
          const result = e1.pipe(
            mergeMap(x => of(x)),
            timeout({ each: t }),
            mergeMap(x => of(x))
          )
          expectObservable(result, unsub).toBe(expected)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should timeout after a specified timeout period between emit with default error while source emits", () => {
      rxTestScheduler.run(
        ({ hot, expectObservable, expectSubscriptions, time }) => {
          const e1 = hot("  ---a---b---c------d---e---|")
          const t = time("             -----|")
          const e1subs = "  ^---------------!          "
          const expected = "---a---b---c----#          "
          const result = e1.pipe(timeout({ each: t }))
          expectObservable(result).toBe(
            expected,
            undefined,
            defaultTimeoutError
          )
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should timeout at a specified Date", () => {
      rxTestScheduler.run(
        ({ cold, expectObservable, expectSubscriptions, time }) => {
          const e1 = cold(" -")
          const t = time("  ----------|")
          const e1subs = "  ^---------!"
          const expected = "----------#"
          // Start time is zero
          const result = e1.pipe(timeout({ first: new Date(t) }))
          expectObservable(result).toBe(expected, null, defaultTimeoutError)
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should timeout at a specified time for first value only", () => {
      rxTestScheduler.run(
        ({ cold, expectObservable, expectSubscriptions, time }) => {
          const e1 = cold(" -")
          const t = time("  ----------|")
          const e1subs = "  ^---------!"
          const expected = "----------#"
          // Start time is zero
          const result = e1.pipe(timeout({ first: t }))
          expectObservable(result).toBe(
            expected,
            undefined,
            defaultTimeoutError
          )
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should not timeout for long delays if only first is specified", () => {
      rxTestScheduler.run(
        ({ cold, expectObservable, expectSubscriptions, time }) => {
          const e1 = cold(" ---a-----------------------b---|")
          const t = time("     ----------|")
          const e1subs = "  ^------------------------------!"
          const expected = "---a-----------------------b---|"
          // Start time is zero
          const result = e1.pipe(timeout({ first: t }))
          expectObservable(result).toBe(
            expected,
            undefined,
            defaultTimeoutError
          )
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should not timeout for long delays if only first is specified as Date", () => {
      rxTestScheduler.run(
        ({ cold, expectObservable, expectSubscriptions, time }) => {
          const e1 = cold(" ---a-----------------------b---|")
          const t = time("  ----------|")
          const e1subs = "  ^------------------------------!"
          const expected = "---a-----------------------b---|"
          // Start time is zero
          const result = e1.pipe(timeout({ first: new Date(t) }))
          expectObservable(result).toBe(
            expected,
            undefined,
            defaultTimeoutError
          )
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
    it("should timeout for long delays if first is specified as Date AND each is specified", () => {
      rxTestScheduler.run(
        ({ cold, expectObservable, expectSubscriptions, time }) => {
          const e1 = cold("   ---a-----------------------b---|")
          const first = time("-------------|")
          const each = time("    ------|")
          const e1subs = "    ^--------!"
          const expected = "  ---a-----#"
          // Start time is zero
          const result = e1.pipe(timeout({ first: new Date(first), each }))
          expectObservable(result).toBe(
            expected,
            undefined,
            defaultTimeoutError
          )
          expectSubscriptions(e1.subscriptions).toBe(e1subs)
        }
      )
    })
  })
  describe("using with", () => {
    it("should timeout after a specified period then subscribe to the passed observable", () => {
      rxTestScheduler.run(
        ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
          const source = cold("  -------a--b--|")
          const sourceSubs = "   ^----!        "
          const t = time("       -----|")
          const inner = cold("        x-y-z-|  ")
          const innerSubs = "    -----^-----!  "
          const expected = "     -----x-y-z-|  "
          const result = source.pipe(
            timeout({
              each: t,
              with: () => inner,
            })
          )
          expectObservable(result).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
          expectSubscriptions(inner.subscriptions).toBe(innerSubs)
        }
      )
    })
    it("should timeout at a specified date then subscribe to the passed observable", () => {
      rxTestScheduler.run(
        ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
          const source = cold("  -")
          const sourceSubs = "   ^---------!           "
          const t = time("       ----------|")
          const inner = cold("             --x--y--z--|")
          const innerSubs = "    ----------^----------!"
          const expected = "     ------------x--y--z--|"
          // The the current frame is zero.
          const result = source.pipe(
            timeout({
              first: new Date(t),
              with: () => inner,
            })
          )
          expectObservable(result).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
          expectSubscriptions(inner.subscriptions).toBe(innerSubs)
        }
      )
    })
    it("should timeout after a specified period between emit then subscribe to the passed observable when source emits", () => {
      rxTestScheduler.run(
        ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
          const source = hot("  ---a---b------c---|")
          const t = time("             ----|       ")
          const sourceSubs = "  ^----------!       "
          const inner = cold("             -x-y-|  ")
          const innerSubs = "   -----------^----!  "
          const expected = "    ---a---b----x-y-|  "
          const result = source.pipe(
            timeout({
              each: t,
              with: () => inner,
            })
          )
          expectObservable(result).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
          expectSubscriptions(inner.subscriptions).toBe(innerSubs)
        }
      )
    })
    it("should allow unsubscribing explicitly and early", () => {
      rxTestScheduler.run(
        ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
          const source = hot("  ---a---b-----c----|")
          const t = time("             ----|       ")
          const sourceSubs = "  ^----------!       "
          const inner = cold("             -x---y| ")
          const innerSubs = "   -----------^--!    "
          const expected = "    ---a---b----x--    "
          const unsub = "       --------------!    "
          const result = source.pipe(timeout({ each: t, with: () => inner }))
          expectObservable(result, unsub).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
          expectSubscriptions(inner.subscriptions).toBe(innerSubs)
        }
      )
    })
    it("should not break unsubscription chain when unsubscribed explicitly", () => {
      rxTestScheduler.run(
        ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
          const source = hot("  ---a---b-----c----|")
          const t = time("      ----|              ")
          const sourceSubs = "  ^----------!       "
          const inner = cold("             -x---y| ")
          const innerSubs = "   -----------^--!    "
          const expected = "    ---a---b----x--    "
          const unsub = "       --------------!    "
          const result = source.pipe(
            mergeMap(x => of(x)),
            timeout({ each: t, with: () => inner }),
            mergeMap(x => of(x))
          )
          expectObservable(result, unsub).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
          expectSubscriptions(inner.subscriptions).toBe(innerSubs)
        }
      )
    })
    it("should not subscribe to withObservable after explicit unsubscription", () => {
      rxTestScheduler.run(
        ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
          const source = cold("---a------b------")
          const t = time("     -----|           ")
          const sourceSubs = " ^----!           "
          const inner = cold("      i---j---|   ")
          const expected = "   ---a--           "
          const unsub = "      -----!           "
          const result = source.pipe(
            mergeMap(x => of(x)),
            timeout({ each: t, with: () => inner }),
            mergeMap(x => of(x))
          )
          expectObservable(result, unsub).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
          expectSubscriptions(inner.subscriptions).toBe([])
        }
      )
    })
    it("should timeout after a specified period then subscribe to the passed observable when source is empty", () => {
      rxTestScheduler.run(
        ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
          const source = hot("  -------------|      ")
          const t = time("      ----------|         ")
          const sourceSubs = "  ^---------!         "
          const inner = cold("            ----x----|")
          const innerSubs = "   ----------^--------!"
          const expected = "    --------------x----|"
          const result = source.pipe(timeout({ each: t, with: () => inner }))
          expectObservable(result).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
          expectSubscriptions(inner.subscriptions).toBe(innerSubs)
        }
      )
    })
    it("should timeout after a specified period between emit then never completes if other source does not complete", () => {
      rxTestScheduler.run(
        ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
          const source = hot("  --a--b--------c--d--|")
          const t = time("           ----|           ")
          const sourceSubs = "  ^--------!           "
          const inner = cold("           ------------")
          const innerSubs = "   ---------^-----------"
          const expected = "    --a--b---------------"
          const result = source.pipe(timeout({ each: t, with: () => inner }))
          expectObservable(result).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
          expectSubscriptions(inner.subscriptions).toBe(innerSubs)
        }
      )
    })
    it("should timeout after a specified period then subscribe to the passed observable when source raises error after timeout", () => {
      rxTestScheduler.run(
        ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
          const source = hot("  -------------#      ")
          const t = time("      ----------|         ")
          const sourceSubs = "  ^---------!         "
          const inner = cold("            ----x----|")
          const innerSubs = "   ----------^--------!"
          const expected = "    --------------x----|"
          const result = source.pipe(timeout({ each: t, with: () => inner }))
          expectObservable(result).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
          expectSubscriptions(inner.subscriptions).toBe(innerSubs)
        }
      )
    })
    it("should timeout after a specified period between emit then never completes if other source emits but not complete", () => {
      rxTestScheduler.run(
        ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
          const source = hot("  -------------|      ")
          const t = time("      -----------|        ")
          const sourceSubs = "  ^----------!        "
          const inner = cold("             ----x----")
          const innerSubs = "   -----------^--------"
          const expected = "    ---------------x----"
          const result = source.pipe(timeout({ each: t, with: () => inner }))
          expectObservable(result).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
          expectSubscriptions(inner.subscriptions).toBe(innerSubs)
        }
      )
    })
    it("should not timeout if source completes within timeout period", () => {
      rxTestScheduler.run(
        ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
          const source = hot("  -----|        ")
          const t = time("      ----------|   ")
          const sourceSubs = "  ^----!        "
          const inner = cold("            ----x----")
          const expected = "    -----|        "
          const result = source.pipe(timeout({ each: t, with: () => inner }))
          expectObservable(result).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
          expectSubscriptions(inner.subscriptions).toBe([])
        }
      )
    })
    it("should not timeout if source raises error within timeout period", () => {
      rxTestScheduler.run(
        ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
          const source = hot("-----#              ")
          const t = time("    ----------|         ")
          const sourceSubs = "^----!              "
          const inner = cold("       ----x----|")
          const expected = "  -----#              "
          const result = source.pipe(timeout({ each: t, with: () => inner }))
          expectObservable(result).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
          expectSubscriptions(inner.subscriptions).toBe([])
        }
      )
    })
    it("should not timeout if source emits within timeout period", () => {
      rxTestScheduler.run(
        ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
          const source = hot("   --a--b--c--d--e--|")
          const t = time("       -----|            ")
          const sourceSubs = "   ^----------------!"
          const inner = cold("        ----x----|   ")
          const expected = "     --a--b--c--d--e--|"
          const result = source.pipe(timeout({ each: t, with: () => inner }))
          expectObservable(result).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
          expectSubscriptions(inner.subscriptions).toBe([])
        }
      )
    })
    it("should not timeout if source completes within specified Date", () => {
      rxTestScheduler.run(
        ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
          const source = hot("--a--b--c--d--e--|   ")
          const t = time("    --------------------|")
          const sourceSubs = "^----------------!   "
          const inner = cold("--x--|            ")
          const expected = "  --a--b--c--d--e--|   "
          // Start frame is zero.
          const result = source.pipe(
            timeout({ first: new Date(t), with: () => inner })
          )
          expectObservable(result).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
          expectSubscriptions(inner.subscriptions).toBe([])
        }
      )
    })
    it("should not timeout if source raises error within specified Date", () => {
      rxTestScheduler.run(
        ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
          const source = hot("---a---#           ")
          const t = time("       ----------|     ")
          const sourceSubs = "^------!           "
          const inner = cold("             --x--|")
          const expected = "  ---a---#           "
          // Start frame is zero.
          const result = source.pipe(
            timeout({ first: new Date(t), with: () => inner })
          )
          expectObservable(result).toBe(expected)
          expectSubscriptions(source.subscriptions).toBe(sourceSubs)
          expectSubscriptions(inner.subscriptions).toBe([])
        }
      )
    })
    it("should not timeout if source emits synchronously when subscribed", () => {
      rxTestScheduler.run(({ expectObservable, time }) => {
        const source = of("a").pipe(concatWith(NEVER))
        const t = time("  ---|")
        const expected = "a---"
        expectObservable(source.pipe(timeout({ first: new Date(t) }))).toBe(
          expected
        )
      })
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(timeout(0), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { timeoutWith, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of, Observable, EMPTY } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {timeoutWith} */
describe("timeoutWith operator", () => {
  let rxTestScheduler: TestScheduler
  beforeEach(() => {
    rxTestScheduler = new TestScheduler(observableMatcher)
  })
  it("should timeout after a specified period then subscribe to the passed observable", () => {
    rxTestScheduler.run(
      ({ cold, time, expectObservable, expectSubscriptions }) => {
        const source = cold("  -------a--b--|")
        const sourceSubs = "   ^----!        "
        const t = time("       -----|")
        const switchTo = cold("     x-y-z-|  ")
        const switchToSubs = " -----^-----!  "
        const expected = "     -----x-y-z-|  "
        const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler))
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expectSubscriptions(switchTo.subscriptions).toBe(switchToSubs)
      }
    )
  })
  it("should timeout at a specified date then subscribe to the passed observable", () => {
    rxTestScheduler.run(
      ({ cold, time, expectObservable, expectSubscriptions }) => {
        const source = cold("  -")
        const sourceSubs = "   ^---------!           "
        const t = time("       ----------|")
        const switchTo = cold("          --x--y--z--|")
        const switchToSubs = " ----------^----------!"
        const expected = "     ------------x--y--z--|"
        // The the current frame is zero.
        const result = source.pipe(
          timeoutWith(new Date(t), switchTo, rxTestScheduler)
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expectSubscriptions(switchTo.subscriptions).toBe(switchToSubs)
      }
    )
  })
  it("should timeout after a specified period between emit then subscribe to the passed observable when source emits", () => {
    rxTestScheduler.run(
      ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
        const source = hot("  ---a---b------c---|")
        const t = time("             ----|       ")
        const sourceSubs = "  ^----------!       "
        const switchTo = cold("          -x-y-|  ")
        const switchToSubs = "-----------^----!  "
        const expected = "    ---a---b----x-y-|  "
        const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler))
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expectSubscriptions(switchTo.subscriptions).toBe(switchToSubs)
      }
    )
  })
  it("should allow unsubscribing explicitly and early", () => {
    rxTestScheduler.run(
      ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
        const source = hot("  ---a---b-----c----|")
        const t = time("             ----|       ")
        const sourceSubs = "  ^----------!       "
        const switchTo = cold("          -x---y| ")
        const switchToSubs = "-----------^--!    "
        const expected = "    ---a---b----x--    "
        const unsub = "       --------------!    "
        const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler))
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expectSubscriptions(switchTo.subscriptions).toBe(switchToSubs)
      }
    )
  })
  it("should not break unsubscription chain when unsubscribed explicitly", () => {
    rxTestScheduler.run(
      ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
        const source = hot("  ---a---b-----c----|")
        const t = time("      ----|              ")
        const sourceSubs = "  ^----------!       "
        const switchTo = cold("          -x---y| ")
        const switchToSubs = "-----------^--!    "
        const expected = "    ---a---b----x--    "
        const unsub = "       --------------!    "
        const result = source.pipe(
          mergeMap(x => of(x)),
          timeoutWith(t, switchTo, rxTestScheduler),
          mergeMap(x => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expectSubscriptions(switchTo.subscriptions).toBe(switchToSubs)
      }
    )
  })
  it("should not subscribe to withObservable after explicit unsubscription", () => {
    rxTestScheduler.run(
      ({ cold, time, expectObservable, expectSubscriptions }) => {
        const source = cold("---a------b------")
        const t = time("     -----|           ")
        const sourceSubs = " ^----!           "
        const switchTo = cold("   i---j---|   ")
        const expected = "   ---a--           "
        const unsub = "      -----!           "
        const result = source.pipe(
          mergeMap((x: string) => of(x)),
          timeoutWith(t, switchTo, rxTestScheduler),
          mergeMap((x: string) => of(x))
        )
        expectObservable(result, unsub).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expectSubscriptions(switchTo.subscriptions).toBe([])
      }
    )
  })
  it("should timeout after a specified period then subscribe to the passed observable when source is empty", () => {
    rxTestScheduler.run(
      ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
        const source = hot("  -------------|      ")
        const t = time("      ----------|         ")
        const sourceSubs = "  ^---------!         "
        const switchTo = cold("         ----x----|")
        const switchToSubs = "----------^--------!"
        const expected = "    --------------x----|"
        const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler))
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expectSubscriptions(switchTo.subscriptions).toBe(switchToSubs)
      }
    )
  })
  it("should timeout after a specified period between emit then never completes if other source does not complete", () => {
    rxTestScheduler.run(
      ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
        const source = hot("  --a--b--------c--d--|")
        const t = time("           ----|           ")
        const sourceSubs = "  ^--------!           "
        const switchTo = cold("        ------------")
        const switchToSubs = "---------^-----------"
        const expected = "    --a--b---------------"
        const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler))
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expectSubscriptions(switchTo.subscriptions).toBe(switchToSubs)
      }
    )
  })
  it("should timeout after a specified period then subscribe to the passed observable when source raises error after timeout", () => {
    rxTestScheduler.run(
      ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
        const source = hot("  -------------#      ")
        const t = time("      ----------|         ")
        const sourceSubs = "  ^---------!         "
        const switchTo = cold("         ----x----|")
        const switchToSubs = "----------^--------!"
        const expected = "    --------------x----|"
        const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler))
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expectSubscriptions(switchTo.subscriptions).toBe(switchToSubs)
      }
    )
  })
  it("should timeout after a specified period between emit then never completes if other source emits but not complete", () => {
    rxTestScheduler.run(
      ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
        const source = hot("  -------------|      ")
        const t = time("      -----------|        ")
        const sourceSubs = "  ^----------!        "
        const switchTo = cold("          ----x----")
        const switchToSubs = "-----------^--------"
        const expected = "    ---------------x----"
        const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler))
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expectSubscriptions(switchTo.subscriptions).toBe(switchToSubs)
      }
    )
  })
  it("should not timeout if source completes within timeout period", () => {
    rxTestScheduler.run(
      ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
        const source = hot("  -----|        ")
        const t = time("      ----------|   ")
        const sourceSubs = "  ^----!        "
        const switchTo = cold("    ----x----")
        const expected = "    -----|        "
        const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler))
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expectSubscriptions(switchTo.subscriptions).toBe([])
      }
    )
  })
  it("should not timeout if source raises error within timeout period", () => {
    rxTestScheduler.run(
      ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
        const source = hot("-----#              ")
        const t = time("    ----------|         ")
        const sourceSubs = "^----!              "
        const switchTo = cold("       ----x----|")
        const expected = "  -----#              "
        const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler))
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expectSubscriptions(switchTo.subscriptions).toBe([])
      }
    )
  })
  it("should not timeout if source emits within timeout period", () => {
    rxTestScheduler.run(
      ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
        const source = hot("   --a--b--c--d--e--|")
        const t = time("       -----|            ")
        const sourceSubs = "   ^----------------!"
        const switchTo = cold("----x----|        ")
        const expected = "     --a--b--c--d--e--|"
        const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler))
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expectSubscriptions(switchTo.subscriptions).toBe([])
      }
    )
  })
  it("should not timeout if source completes within specified Date", () => {
    rxTestScheduler.run(
      ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
        const source = hot("--a--b--c--d--e--|   ")
        const t = time("    --------------------|")
        const sourceSubs = "^----------------!   "
        const switchTo = cold("--x--|            ")
        const expected = "  --a--b--c--d--e--|   "
        // Start frame is zero.
        const result = source.pipe(
          timeoutWith(new Date(t), switchTo, rxTestScheduler)
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expectSubscriptions(switchTo.subscriptions).toBe([])
      }
    )
  })
  it("should not timeout if source raises error within specified Date", () => {
    rxTestScheduler.run(
      ({ hot, cold, time, expectObservable, expectSubscriptions }) => {
        const source = hot("---a---#           ")
        const t = time("       ----------|     ")
        const sourceSubs = "^------!           "
        const switchTo = cold("          --x--|")
        const expected = "  ---a---#           "
        // Start frame is zero.
        const result = source.pipe(
          timeoutWith(new Date(t), switchTo, rxTestScheduler)
        )
        expectObservable(result).toBe(expected)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expectSubscriptions(switchTo.subscriptions).toBe([])
      }
    )
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(timeoutWith(0, EMPTY), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { expect } from "chai"
import { timestamp, map, mergeMap, take } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of, Observable } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {timestamp} */
describe("timestamp", () => {
  let rxTestScheduler: TestScheduler
  beforeEach(() => {
    rxTestScheduler = new TestScheduler(observableMatcher)
  })
  it("should record the time stamp per each source elements", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -b-c-----d--e--|")
      const e1subs = "  ^--------------!"
      const expected = "-w-x-----y--z--|"
      const expectedValue = { w: 1, x: 3, y: 9, z: 12 }
      const result = e1.pipe(
        timestamp(rxTestScheduler),
        map(x => x.timestamp)
      )
      expectObservable(result).toBe(expected, expectedValue)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should record stamp if source emit elements", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--a--^b--c----d---e--|")
      const e1subs = "     ^---------------!"
      const expected = "   -w--x----y---z--|"
      const expectedValue = {
        w: { value: "b", timestamp: 1 },
        x: { value: "c", timestamp: 4 },
        y: { value: "d", timestamp: 9 },
        z: { value: "e", timestamp: 13 },
      }
      expectObservable(e1.pipe(timestamp(rxTestScheduler))).toBe(
        expected,
        expectedValue
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should completes without record stamp if source does not emits", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---------|")
      const e1subs = "  ^--------!"
      const expected = "---------|"
      expectObservable(e1.pipe(timestamp(rxTestScheduler))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should complete immediately if source is empty", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "|   "
      expectObservable(e1.pipe(timestamp(rxTestScheduler))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should record stamp then does not completes if source emits but not completes", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -a--b--")
      const e1subs = "  ^------"
      const expected = "-y--z--"
      const expectedValue = {
        y: { value: "a", timestamp: 1 },
        z: { value: "b", timestamp: 4 },
      }
      expectObservable(e1.pipe(timestamp(rxTestScheduler))).toBe(
        expected,
        expectedValue
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -a--b-----c---d---|")
      const unsub = "   -------!           "
      const e1subs = "  ^------!           "
      const expected = "-y--z---           "
      const expectedValue = {
        y: { value: "a", timestamp: 1 },
        z: { value: "b", timestamp: 4 },
      }
      const result = e1.pipe(timestamp(rxTestScheduler))
      expectObservable(result, unsub).toBe(expected, expectedValue)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -a--b-----c---d---|")
      const e1subs = "  ^------!           "
      const expected = "-y--z---           "
      const unsub = "   -------!           "
      const expectedValue = {
        y: { value: "a", timestamp: 1 },
        z: { value: "b", timestamp: 4 },
      }
      const result = e1.pipe(
        mergeMap(x => of(x)),
        timestamp(rxTestScheduler),
        mergeMap(x => of(x))
      )
      expectObservable(result, unsub).toBe(expected, expectedValue)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not completes if source never completes", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(timestamp(rxTestScheduler))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("raise error if source raises error", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---#")
      const e1subs = "  ^--!"
      const expected = "---#"
      expectObservable(e1.pipe(timestamp(rxTestScheduler))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should record stamp then raise error if source raises error after emit", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  -a--b--#")
      const e1subs = "  ^------!"
      const expected = "-y--z--#"
      const expectedValue = {
        y: { value: "a", timestamp: 1 },
        z: { value: "b", timestamp: 4 },
      }
      expectObservable(e1.pipe(timestamp(rxTestScheduler))).toBe(
        expected,
        expectedValue
      )
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should raise error if source immediately throws", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      expectObservable(e1.pipe(timestamp(rxTestScheduler))).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable.pipe(timestamp(), take(3)).subscribe(() => {
      /* noop */
    })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { toArray, mergeMap } from "rxjs/operators"
import { of } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {toArray} */
describe("toArray", () => {
  let rxTestScheduler: TestScheduler
  beforeEach(() => {
    rxTestScheduler = new TestScheduler(observableMatcher)
  })
  it("should reduce the values of an observable into an array", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---a--b--|   ")
      const e1subs = "  ^--------!   "
      const expected = "---------(w|)"
      expectObservable(e1.pipe(toArray())).toBe(expected, { w: ["a", "b"] })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should be never when source is never", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" -")
      const e1subs = "  ^"
      const expected = "-"
      expectObservable(e1.pipe(toArray())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should be empty when source is empty", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" |   ")
      const e1subs = "  (^!)"
      const expected = "(w|)"
      expectObservable(e1.pipe(toArray())).toBe(expected, { w: [] })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should be never when source doesn't complete", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("--x--^--y--")
      const e1subs = "     ^-----"
      const expected = "   ------"
      expectObservable(e1.pipe(toArray())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should reduce observable without values into an array of length zero", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^---|   ")
      const e1subs = "   ^---!   "
      const expected = " ----(w|)"
      expectObservable(e1.pipe(toArray())).toBe(expected, { w: [] })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should reduce the a single value of an observable into an array", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^--y--|  ")
      const e1subs = "   ^-----!  "
      const expected = " ------(w|)"
      expectObservable(e1.pipe(toArray())).toBe(expected, { w: ["y"] })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should allow multiple subscriptions", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^--y--|   ")
      const e1subs = "   ^-----!   "
      const expected = " ------(w|)"
      const result = e1.pipe(toArray())
      expectObservable(result).toBe(expected, { w: ["y"] })
      expectObservable(result).toBe(expected, { w: ["y"] })
      expectSubscriptions(e1.subscriptions).toBe([e1subs, e1subs])
    })
  })
  it("should allow unsubscribing explicitly and early", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b----c-----d----e---|")
      const e1subs = "  ^-------!                 "
      const expected = "---------                 "
      const unsub = "   --------!                 "
      expectObservable(e1.pipe(toArray()), unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  --a--b----c-----d----e---|")
      const e1subs = "  ^-------!                 "
      const expected = "---------                 "
      const unsub = "   --------!                 "
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        toArray(),
        mergeMap((x: Array<string>) => of(x))
      )
      expectObservable(result, unsub).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work with error", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("-x-^--y--z--#", { x: 1, y: 2, z: 3 }, "too bad")
      const e1subs = "   ^--------!"
      const expected = " ---------#"
      expectObservable(e1.pipe(toArray())).toBe(expected, null, "too bad")
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
  it("should work with throw", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e1 = cold(" #   ")
      const e1subs = "  (^!)"
      const expected = "#   "
      expectObservable(e1.pipe(toArray())).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
    })
  })
})
import { expect } from "chai"
import { of, EMPTY, throwError, config } from "rxjs"
/** @test {toPromise} */
describe("Observable.toPromise", () => {
  it("should convert an Observable to a promise of its last value", done => {
    of(1, 2, 3)
      .toPromise(Promise)
      .then(x => {
        expect(x).to.equal(3)
        done()
      })
  })
  it("should convert an empty Observable to a promise of undefined", done => {
    EMPTY.toPromise(Promise).then(x => {
      expect(x).to.be.undefined
      done()
    })
  })
  it("should handle errors properly", done => {
    throwError(() => "bad")
      .toPromise(Promise)
      .then(
        () => {
          done(new Error("should not be called"))
        },
        (err: any) => {
          expect(err).to.equal("bad")
          done()
        }
      )
  })
  it("should allow for global config via config.Promise", async () => {
    try {
      let wasCalled = false
      config.Promise = function MyPromise(callback: Function) {
        wasCalled = true
        return new Promise(callback as any)
      } as any
      const x = await of(42).toPromise()
      expect(wasCalled).to.be.true
      expect(x).to.equal(42)
    } finally {
      config.Promise = undefined
    }
  })
})
import { window, mergeMap } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { EMPTY, of, Observable } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {window} */
describe("window", () => {
  let rxTestScheduler: TestScheduler
  beforeEach(() => {
    rxTestScheduler = new TestScheduler(observableMatcher)
  })
  it("should emit windows that close and reopen", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const source = hot("  ---a---b---c---d---e---f---g---h---i---|    ")
        const sourceSubs = "  ^--------------------------------------!    "
        const closings = hot("-------------w------------w----------------|")
        const closingSubs = " ^--------------------------------------!    "
        const expected = "    x------------y------------z------------|    "
        const x = cold("      ---a---b---c-|                              ")
        const y = cold("                   --d---e---f--|                 ")
        const z = cold("                                -g---h---i---|    ")
        const expectedValues = { x: x, y: y, z: z }
        const result = source.pipe(window(closings))
        expectObservable(result).toBe(expected, expectedValues)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expectSubscriptions(closings.subscriptions).toBe(closingSubs)
      }
    )
  })
  it("should return a single empty window if source is empty and closings are basic", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  |        ")
      const sourceSubs = "   (^!)     "
      const closings = cold("--x--x--|")
      const closingSubs = "  (^!)     "
      const expected = "     (w|)     "
      const w = cold("       |        ")
      const expectedValues = { w: w }
      const result = source.pipe(window(closings))
      expectObservable(result).toBe(expected, expectedValues)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      expectSubscriptions(closings.subscriptions).toBe(closingSubs)
    })
  })
  it("should return a single empty window if source is empty and closing is empty", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  |   ")
      const sourceSubs = "   (^!)"
      const closings = cold("|   ")
      const closingSubs = "  (^!)"
      const expected = "     (w|)"
      const w = cold("       |   ")
      const expectedValues = { w: w }
      const result = source.pipe(window(closings))
      expectObservable(result).toBe(expected, expectedValues)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      expectSubscriptions(closings.subscriptions).toBe(closingSubs)
    })
  })
  it("should return a single empty window if source is sync empty and closing is sync empty", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  (|) ")
      const sourceSubs = "   (^!)"
      const expected = "     (w|)"
      const w = cold("       |   ")
      const expectedValues = { w: w }
      const result = source.pipe(window(EMPTY))
      expectObservable(result).toBe(expected, expectedValues)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      // expectSubscriptions(closings.subscriptions).toBe(closingSubs);
    })
  })
  it("should split a Just source into a single window identical to source, using a Never closing", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  (a|)")
      const sourceSubs = "   (^!)"
      const closings = cold("-   ")
      const closingSubs = "  (^!)"
      const expected = "     (w|)"
      const w = cold("       (a|)")
      const expectedValues = { w: w }
      const result = source.pipe(window(closings))
      expectObservable(result).toBe(expected, expectedValues)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      expectSubscriptions(closings.subscriptions).toBe(closingSubs)
    })
  })
  it("should return a single Never window if source is Never", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  ------")
      const sourceSubs = "   ^-----"
      const closings = cold("------")
      const closingSubs = "  ^-----"
      const expected = "     w-----"
      const w = cold("       ------")
      const expectedValues = { w: w }
      const result = source.pipe(window(closings))
      expectObservable(result).toBe(expected, expectedValues)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      expectSubscriptions(closings.subscriptions).toBe(closingSubs)
    })
  })
  it("should be able to split a never Observable into timely empty windows", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const source = hot("   ^--------")
        const sourceSubs = "   ^--------"
        const closings = cold("--x--x--|")
        const closingSubs = "  ^-------!"
        const expected = "     a-b--c---"
        const a = cold("       --|      ")
        const b = cold("         ---|   ")
        const c = cold("            ----")
        const expectedValues = { a: a, b: b, c: c }
        const result = source.pipe(window(closings))
        expectObservable(result).toBe(expected, expectedValues)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
        expectSubscriptions(closings.subscriptions).toBe(closingSubs)
      }
    )
  })
  it("should emit an error-only window if outer is a simple throw-Observable", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  #        ")
      const sourceSubs = "   (^!)     "
      const closings = cold("--x--x--|")
      const closingSubs = "  (^!)     "
      const expected = "     (w#)     "
      const w = cold("       #        ")
      const expectedValues = { w: w }
      const result = source.pipe(window(closings))
      expectObservable(result).toBe(expected, expectedValues)
      expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      expectSubscriptions(closings.subscriptions).toBe(closingSubs)
    })
  })
  it("should handle basic case with window closings", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const source = hot("-1-2-^3-4-5-6-7-8-9-|         ")
        const subs = "           ^--------------!         "
        const closings = hot("---^---x---x---x---x---x---|")
        const closingSubs = "    ^--------------!         "
        const expected = "       a---b---c---d--|         "
        const a = cold("         -3-4|                    ")
        const b = cold("             -5-6|                ")
        const c = cold("                 -7-8|            ")
        const d = cold("                     -9-|         ")
        const expectedValues = { a: a, b: b, c: c, d: d }
        const result = source.pipe(window(closings))
        expectObservable(result).toBe(expected, expectedValues)
        expectSubscriptions(source.subscriptions).toBe(subs)
        expectSubscriptions(closings.subscriptions).toBe(closingSubs)
      }
    )
  })
  it("should handle basic case with window closings, but outer throws", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const source = hot("-1-2-^3-4-5-6-7-8-9-#         ")
        const subs = "           ^--------------!         "
        const closings = hot("---^---x---x---x---x---x---|")
        const closingSubs = "    ^--------------!         "
        const expected = "       a---b---c---d--#         "
        const a = cold("         -3-4|                    ")
        const b = cold("             -5-6|                ")
        const c = cold("                 -7-8|            ")
        const d = cold("                     -9-#         ")
        const expectedValues = { a: a, b: b, c: c, d: d }
        const result = source.pipe(window(closings))
        expectObservable(result).toBe(expected, expectedValues)
        expectSubscriptions(source.subscriptions).toBe(subs)
        expectSubscriptions(closings.subscriptions).toBe(closingSubs)
      }
    )
  })
  it("should stop emitting windows when outer is unsubscribed early", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const source = hot("-1-2-^3-4-5-6-7-8-9-|         ")
        const subs = "           ^-------!                "
        const closings = hot("---^---x---x---x---x---x---|")
        const closingSubs = "    ^-------!                "
        const expected = "       a---b----                "
        const a = cold("         -3-4|                    ")
        const b = cold("             -5-6                 ")
        const unsub = "          --------!                "
        const expectedValues = { a: a, b: b }
        const result = source.pipe(window(closings))
        expectObservable(result, unsub).toBe(expected, expectedValues)
        expectSubscriptions(source.subscriptions).toBe(subs)
        expectSubscriptions(closings.subscriptions).toBe(closingSubs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const source = hot("-1-2-^3-4-5-6-7-8-9-|         ")
        const subs = "           ^-------!                "
        const closings = hot("---^---x---x---x---x---x---|")
        const closingSubs = "    ^-------!                "
        const expected = "       a---b----                "
        const a = cold("         -3-4|                    ")
        const b = cold("             -5-6-                ")
        const unsub = "          --------!                "
        const expectedValues = { a: a, b: b }
        const result = source.pipe(
          mergeMap((x: string) => of(x)),
          window(closings),
          mergeMap((x: Observable<string>) => of(x))
        )
        expectObservable(result, unsub).toBe(expected, expectedValues)
        expectSubscriptions(source.subscriptions).toBe(subs)
        expectSubscriptions(closings.subscriptions).toBe(closingSubs)
      }
    )
  })
  it("should make outer emit error when closing throws", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const source = hot("-1-2-^3-4-5-6-7-8-9-#")
        const subs = "           ^---!           "
        const closings = hot("---^---#           ")
        const closingSubs = "    ^---!           "
        const expected = "       a---#           "
        const a = cold("         -3-4#           ")
        const expectedValues = { a: a }
        const result = source.pipe(window(closings))
        expectObservable(result).toBe(expected, expectedValues)
        expectSubscriptions(source.subscriptions).toBe(subs)
        expectSubscriptions(closings.subscriptions).toBe(closingSubs)
      }
    )
  })
  it("should complete the resulting Observable when window closings completes", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const source = hot("-1-2-^3-4-5-6-7-8-9-|")
        const subs = "           ^--------------!"
        const closings = hot("---^---x---x---|   ")
        const closingSubs = "    ^-----------!   "
        const expected = "       a---b---c------|"
        const a = cold("         -3-4|           ")
        const b = cold("             -5-6|       ")
        const c = cold("                 -7-8-9-|")
        const expectedValues = { a: a, b: b, c: c }
        const result = source.pipe(window(closings))
        expectObservable(result).toBe(expected, expectedValues)
        expectSubscriptions(source.subscriptions).toBe(subs)
        expectSubscriptions(closings.subscriptions).toBe(closingSubs)
      }
    )
  })
})
import { expect } from "chai"
import { windowCount, mergeMap, mergeAll, take } from "rxjs/operators"
import { of, Observable } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {windowCount} */
describe("windowCount", () => {
  let rxTestScheduler: TestScheduler
  beforeEach(() => {
    rxTestScheduler = new TestScheduler(observableMatcher)
  })
  it("should emit windows with count 3, no skip specified", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const source = hot("---a---b---c---d---e---f---g---h---i---|")
        const sourceSubs = "^--------------------------------------!"
        const expected = "  x----------y-----------z-----------w---|"
        const x = cold("    ---a---b---(c|)                         ")
        const y = cold("               ----d---e---(f|)             ")
        const z = cold("                           ----g---h---(i|) ")
        const w = cold("                                       ----|")
        const expectedValues = { x: x, y: y, z: z, w: w }
        const result = source.pipe(windowCount(3))
        expectObservable(result).toBe(expected, expectedValues)
        expectSubscriptions(source.subscriptions).toBe(sourceSubs)
      }
    )
  })
  it("should emit windows with count 2 and skip 1", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const source = hot("^-a--b--c--d--|")
        const subs = "      ^-------------!"
        const expected = "  u-v--x--y--z--|"
        const u = cold("    --a--(b|)      ")
        const v = cold("      ---b--(c|)   ")
        const x = cold("         ---c--(d|)")
        const y = cold("            ---d--|")
        const z = cold("               ---|")
        const values = { u: u, v: v, x: x, y: y, z: z }
        const result = source.pipe(windowCount(2, 1))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  it("should emit windows with count 2, and skip unspecified", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const source = hot("--a--b--c--d--e--f--|")
        const subs = "      ^-------------------!"
        const expected = "  x----y-----z-----w--|"
        const x = cold("    --a--(b|)            ")
        const y = cold("         ---c--(d|)      ")
        const z = cold("               ---e--(f|)")
        const w = cold("                     ---|")
        const values = { x: x, y: y, z: z, w: w }
        const result = source.pipe(windowCount(2))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  it("should return empty if source is empty", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("|")
      const subs = "       (^!)"
      const expected = "   (w|)"
      const w = cold("     |")
      const values = { w: w }
      const result = source.pipe(windowCount(2, 1))
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should return Never if source if Never", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("-")
      const subs = "       ^"
      const expected = "   w"
      const w = cold("     -")
      const expectedValues = { w: w }
      const result = source.pipe(windowCount(2, 1))
      expectObservable(result).toBe(expected, expectedValues)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should propagate error from a just-throw source", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const source = cold("  #")
      const subs = "         (^!)"
      const expected = "     (w#)"
      const w = cold("       #")
      const expectedValues = { w: w }
      const result = source.pipe(windowCount(2, 1))
      expectObservable(result).toBe(expected, expectedValues)
      expectSubscriptions(source.subscriptions).toBe(subs)
    })
  })
  it("should raise error if source raises error", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const source = hot("--a--b--c--d--e--f--#")
        const subs = "      ^-------------------!"
        const expected = "  u-v--w--x--y--z--q--#"
        const u = cold("    --a--b--(c|)         ")
        const v = cold("      ---b--c--(d|)      ")
        const w = cold("         ---c--d--(e|)   ")
        const x = cold("            ---d--e--(f|)")
        const y = cold("               ---e--f--#")
        const z = cold("                  ---f--#")
        const q = cold("                     ---#")
        const values = { u: u, v: v, w: w, x: x, y: y, z: z, q: q }
        const result = source.pipe(windowCount(3, 1))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  it("should dispose of inner windows once outer is unsubscribed early", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const source = hot("^-a--b--c--d--|")
        const subs = "      ^--------!     "
        const expected = "  w-x--y--z-     "
        const w = cold("    --a--(b|)      ")
        const x = cold("      ---b--(c|)   ")
        const y = cold("         ---c-     ")
        const z = cold("            --     ")
        const unsub = "     ---------!     "
        const values = { w: w, x: x, y: y, z: z }
        const result = source.pipe(windowCount(2, 1))
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const source = hot("^-a--b--c--d--|")
        const subs = "      ^--------!     "
        const expected = "  w-x--y--z-     "
        const w = cold("    --a--(b|)      ")
        const x = cold("      ---b--(c|)   ")
        const y = cold("         ---c-     ")
        const z = cold("            --     ")
        const unsub = "     ---------!     "
        const values = { w: w, x: x, y: y, z: z }
        const result = source.pipe(
          mergeMap((x: string) => of(x)),
          windowCount(2, 1),
          mergeMap((x: Observable<string>) => of(x))
        )
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  it("should stop listening to a synchronous observable when unsubscribed", () => {
    const sideEffects: number[] = []
    const synchronousObservable = new Observable<number>(subscriber => {
      // This will check to see if the subscriber was closed on each loop
      // when the unsubscribe hits (from the `take`), it should be closed
      for (let i = 0; !subscriber.closed && i < 10; i++) {
        sideEffects.push(i)
        subscriber.next(i)
      }
    })
    synchronousObservable
      .pipe(windowCount(3), mergeAll(), take(3))
      .subscribe(() => {
        /* noop */
      })
    expect(sideEffects).to.deep.equal([0, 1, 2])
  })
})
import { windowTime, mergeMap } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { of, Observable } from "rxjs"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {windowTime} */
describe("windowTime", () => {
  let rxTestScheduler: TestScheduler
  beforeEach(() => {
    rxTestScheduler = new TestScheduler(observableMatcher)
  })
  it("should emit windows given windowTimeSpan and windowCreationInterval", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const source = hot("--1--2--^-a--b--c--d--e---f--g--h-|")
        const subs = "              ^-------------------------!"
        //  10 frames               0---------1---------2-----|
        //  5                       -----|
        //  5                                 -----|
        //  5                                           -----|
        const expected = "          x---------y---------z-----|"
        const x = cold("            --a--(b|)                  ")
        const y = cold("                      -d--e|           ")
        const z = cold("                                -g--h| ")
        const values = { x, y, z }
        const result = source.pipe(windowTime(5, 10, rxTestScheduler))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  // NOTE: This test and behavior were broken in 5.x and 6.x, to where
  // Not passing a creationInterval would not cause new windows to open
  // when old ones closed.
  it("should close windows after max count is reached", () => {
    rxTestScheduler.run(
      ({ hot, time, cold, expectObservable, expectSubscriptions }) => {
        const source = hot("--1--2--^--a--b--c--d--e--f--g-----|")
        const subs = "              ^--------------------------!"
        const timeSpan = time("     ----------|                 ")
        //                                 ----------|
        //                                       ----------|
        //                                             ---------
        const expected = "          w-----x-----y-----z--------|"
        const w = cold("            ---a--(b|)                  ")
        const x = cold("                  ---c--(d|)            ")
        const y = cold("                        ---e--(f|)      ")
        const z = cold("                              ---g-----|")
        const values = { w, x, y, z }
        const result = source.pipe(
          windowTime(timeSpan, null, 2, rxTestScheduler)
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  it("should close window after max count is reached with windowCreationInterval", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectSubscriptions, expectObservable }) => {
        const source = hot("--1--2--^-a--b--c--de-f---g--h--i-|")
        const subs = "              ^-------------------------!"
        //  10 frames               0---------1---------2-----|
        //  5                       -----|
        //  5                                 -----|
        //  5                                           -----|
        const expected = "          x---------y---------z-----|"
        const x = cold("            --a--(b|)                  ")
        const y = cold("                      -de-(f|)         ")
        const z = cold("                                -h--i| ")
        const values = { x, y, z }
        const result = source.pipe(windowTime(5, 10, 3, rxTestScheduler))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  it("should emit windows given windowTimeSpan", () => {
    rxTestScheduler.run(
      ({ hot, cold, time, expectSubscriptions, expectObservable }) => {
        const source = hot("--1--2--^--a--b--c--d--e--f--g--h--|")
        const subs = "              ^--------------------------!"
        const timeSpan = time("     ----------|                 ")
        //  10 frames               0---------1---------2------|
        //                                    ----------|
        //                                              ----------|
        const expected = "          x---------y---------z------|"
        const x = cold("            ---a--b--c|                 ")
        const y = cold("                      --d--e--f-|       ")
        const z = cold("                                -g--h--|")
        const values = { x, y, z }
        const result = source.pipe(windowTime(timeSpan, rxTestScheduler))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  it("should emit windows given windowTimeSpan and windowCreationInterval", () => {
    rxTestScheduler.run(
      ({ hot, time, cold, expectSubscriptions, expectObservable }) => {
        const source = hot("--1--2--^--a--b--c--d--e--f--g--h--|")
        const subs = "              ^--------------------------!"
        //  10 frames               0---------1---------2------|
        const interval = time("     ----------|                 ")
        //  10                                ----------|
        //  10                                          ----------|
        const timeSpan = time("     -----|                      ")
        //  5                                 ----|
        //  5                                           ----|
        const expected = "          x---------y---------z------|"
        const x = cold("            ---a-|                      ")
        const y = cold("                      --d--(e|)         ")
        const z = cold("                                -g--h|  ")
        const values = { x, y, z }
        const result = source.pipe(
          windowTime(timeSpan, interval, rxTestScheduler)
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  it("should return a single empty window if source is empty", () => {
    rxTestScheduler.run(
      ({ cold, time, expectSubscriptions, expectObservable }) => {
        const source = cold("|")
        const subs = "       (^!)"
        const expected = "   (w|)"
        const w = cold("     |")
        const expectedValues = { w }
        const timeSpan = time("-----|")
        const interval = time("----------|")
        const result = source.pipe(
          windowTime(timeSpan, interval, rxTestScheduler)
        )
        expectObservable(result).toBe(expected, expectedValues)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  it("should split a Just source into a single window identical to source", () => {
    rxTestScheduler.run(
      ({ cold, time, expectSubscriptions, expectObservable }) => {
        const source = cold("(a|)")
        const subs = "       (^!)"
        const expected = "   (w|)"
        const w = cold("     (a|)")
        const expectedValues = { w }
        const timeSpan = time("-----|")
        const interval = time("----------|")
        const result = source.pipe(
          windowTime(timeSpan, interval, rxTestScheduler)
        )
        expectObservable(result).toBe(expected, expectedValues)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  it("should be able to split a never Observable into timely empty windows", () => {
    rxTestScheduler.run(
      ({ hot, cold, time, expectSubscriptions, expectObservable }) => {
        const source = hot("   ^----------")
        const subs = "         ^---------!"
        const timeSpan = time("---|")
        const interval = time("---|")
        //                        ---|
        //                           ---|
        //                              ---|
        const expected = "     a--b--c--d-"
        const a = cold("       ---|       ")
        const b = cold("          ---|    ")
        const c = cold("             ---| ")
        const d = cold("                --")
        const unsub = "        ----------!"
        const expectedValues = { a, b, c, d }
        const result = source.pipe(
          windowTime(timeSpan, interval, rxTestScheduler)
        )
        expectObservable(result, unsub).toBe(expected, expectedValues)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  it("should emit an error-only window if outer is a simple throw-Observable", () => {
    rxTestScheduler.run(
      ({ cold, time, expectSubscriptions, expectObservable }) => {
        const source = cold("#   ")
        const subs = "       (^!)"
        const expected = "   (w#)"
        const w = cold("     #   ")
        const expectedValues = { w }
        const timeSpan = time("-----|")
        const interval = time("----------|")
        const result = source.pipe(
          windowTime(timeSpan, interval, rxTestScheduler)
        )
        expectObservable(result).toBe(expected, expectedValues)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  it("should handle source Observable which eventually emits an error", () => {
    rxTestScheduler.run(
      ({ hot, cold, time, expectSubscriptions, expectObservable }) => {
        const source = hot("--1--2--^--a--b--c--d--e--f--g--h--#")
        const subs = "              ^--------------------------!"
        const timeSpan = time("     -----|                      ")
        const interval = time("     ----------|                 ")
        //  10 frames               0---------1---------2------|
        //  5                       ----|
        //  5                                 ----|
        //  5                                           ----|
        const expected = "          x---------y---------z------#"
        const x = cold("            ---a-|                      ")
        const y = cold("                      --d--(e|)         ")
        const z = cold("                                -g--h|  ")
        const values = { x, y, z }
        const result = source.pipe(
          windowTime(timeSpan, interval, rxTestScheduler)
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  it("should emit windows given windowTimeSpan and windowCreationInterval, but outer is unsubscribed early", () => {
    rxTestScheduler.run(
      ({ hot, cold, time, expectSubscriptions, expectObservable }) => {
        const source = hot("--1--2--^--a--b--c--d--e--f--g--h--|")
        const subs = "              ^----------!                "
        const timeSpan = time("     -----|                      ")
        const interval = time("     ----------|                 ")
        //  10 frames               0---------1---------2------|
        //  5                       ----|
        //  5                                 ----|
        //  5                                           ----|
        const expected = "          x---------y-                "
        const x = cold("            ---a-|                      ")
        const y = cold("                      --                ")
        const unsub = "             -----------!                "
        const values = { x, y }
        const result = source.pipe(
          windowTime(timeSpan, interval, rxTestScheduler)
        )
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(source.subscriptions).toBe(subs)
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    rxTestScheduler.run(
      ({ hot, cold, time, expectSubscriptions, expectObservable }) => {
        const source = hot("--1--2--^--a--b--c--d--e--f--g--h--|")
        const sourcesubs = "        ^-------------!             "
        const timeSpan = time("     -----|                      ")
        const interval = time("     ----------|                 ")
        //  10 frames               0---------1---------2------|
        //  5                       ----|
        //  5                                 ----|
        //  5                                           ----|
        const expected = "          x---------y----             "
        const x = cold("            ---a-|                      ")
        const y = cold("                      --d--             ")
        const unsub = "             --------------!             "
        const values = { x, y }
        const result = source.pipe(
          mergeMap((x: string) => of(x)),
          windowTime(timeSpan, interval, rxTestScheduler),
          mergeMap((x: Observable<string>) => of(x))
        )
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(source.subscriptions).toBe(sourcesubs)
      }
    )
  })
  it("should not error if maxWindowSize is hit while nexting to other windows.", () => {
    rxTestScheduler.run(({ cold, time, expectObservable }) => {
      const source = cold(
        "                ----a---b---c---d---e---f---g---h---i---j---"
      )
      const windowTimeSpan = time(
        "        ------------|                               "
      )
      const windowCreationInterval = time(
        "--------|                                   "
      )
      const maxWindowSize = 4
      const a = cold(
        "                     ----a---b---|                               "
      )
      //                                   ------------|
      const b = cold("                             b---c---d---(e|)")
      const c = cold("                                     ----e---f---(g|)")
      const d = cold(
        "                                             ----g---h---(i|)    "
      )
      const e = cold(
        "                                                     ----i---j---"
      )
      const f = cold(
        "                                                             ----"
      )
      const expected =
        "                   a-------b-------c-------d-------e-------f---"
      const killSub =
        "                    ------------------------------------------! "
      const values = { a, b, c, d, e, f }
      const result = source.pipe(
        windowTime(
          windowTimeSpan,
          windowCreationInterval,
          maxWindowSize,
          rxTestScheduler
        )
      )
      expectObservable(result, killSub).toBe(expected, values)
    })
  })
})
import { expect } from "chai"
import { Observable, NEVER, of, ObjectUnsubscribedError, EMPTY } from "rxjs"
import { windowToggle, tap, mergeMap } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {windowToggle} */
describe("windowToggle", () => {
  let rxTestScheduler: TestScheduler
  beforeEach(() => {
    rxTestScheduler = new TestScheduler(observableMatcher)
  })
  it("should emit windows governed by openings and closings", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e2 = cold("         ----w--------w--------w--|")
        const e2subs = "          ^------------------------!"
        const e3 = cold("             -----x                ")
        //                                     -----x
        //                                              -----x
        const e3subs = [
          "                       ----^----!                ",
          "                       -------------^----!       ",
          "                       ----------------------^--!",
        ]
        const e1 = hot("  --1--2--^-a--b--c--d--e--f--g--h-|")
        const e1subs = "          ^------------------------!"
        const expected = "        ----x--------y--------z--|"
        const x = cold("              -b--c|                ")
        const y = cold("                       -e--f|       ")
        const z = cold("                                -h-|")
        const values = { x, y, z }
        const result = e1.pipe(windowToggle(e2, () => e3))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
        expectSubscriptions(e3.subscriptions).toBe(e3subs)
      }
    )
  })
  it("should emit windows that are opened by an observable from the first argument and closed by an observable returned by the function in the second argument", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e2 = cold("       --------x-------x-------x--|")
        const e2subs = "        ^--------------------------!"
        const e3 = cold("               ----------(x|)      ")
        //                                      ----------(x|)
        //                                              ----------(x|)
        const e3subs = [
          "                     --------^---------!         ",
          "                     ----------------^---------! ",
          "                     ------------------------^--!",
        ]
        const e1 = hot("--1--2--^--a--b--c--d--e--f--g--h--|")
        const e1subs = "        ^--------------------------!"
        const expected = "      --------x-------y-------z--|"
        const x = cold("                -c--d--e--(f|)      ")
        const y = cold("                        --f--g--h-| ")
        const z = cold("                                ---|")
        const values = { x, y, z }
        const source = e1.pipe(
          windowToggle(e2, (value: string) => {
            expect(value).to.equal("x")
            return e3
          })
        )
        expectObservable(source).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
        expectSubscriptions(e3.subscriptions).toBe(e3subs)
      }
    )
  })
  it("should emit windows using varying cold closings", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e2 = cold("    --x-----------y--------z---|            ")
        const e2subs = "     ^--------------------------!            "
        const close = [
          cold("               ---------------s--|                   "),
          cold("                           ----(s|)                  "),
          cold("                                  ---------------(s|)"),
        ]
        const closeSubs = [
          "                  --^--------------!                      ",
          "                  --------------^---!                     ",
          "                  -----------------------^-----------!    ",
        ]
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|    ")
        const e1subs = "     ^----------------------------------!    "
        const expected = "   --x-----------y--------z-----------|    "
        const x = cold("       --b---c---d---e|                      ")
        const y = cold("                   --e-|                     ")
        const z = cold("                            -g---h------|    ")
        const values = { x, y, z }
        let i = 0
        const result = e1.pipe(windowToggle(e2, () => close[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
        expectSubscriptions(close[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(close[1].subscriptions).toBe(closeSubs[1])
        expectSubscriptions(close[2].subscriptions).toBe(closeSubs[2])
      }
    )
  })
  it("should emit windows using varying hot closings", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e2 = cold("    --x-----------y--------z---|           ")
        const e2subs = "     ^--------------------------!           "
        const closings = [
          hot("          -1--^----------------s-|                   "),
          hot("              -----3----4-------(s|)                 "),
          hot("              -------3----4-------5----------------s|"),
        ]
        const closingSubs = [
          "                  --^--------------!                     ",
          "                  --------------^---!                    ",
          "                  -----------------------^-----------!   ",
        ]
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|   ")
        const e1subs = "     ^----------------------------------!   "
        const expected = "   --x-----------y--------z-----------|   "
        const x = cold("       --b---c---d---e|                     ")
        const y = cold("                   --e-|                    ")
        const z = cold("                            -g---h------|   ")
        const values = { x, y, z }
        let i = 0
        const result = e1.pipe(windowToggle(e2, () => closings[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closingSubs[0])
        expectSubscriptions(closings[1].subscriptions).toBe(closingSubs[1])
        expectSubscriptions(closings[2].subscriptions).toBe(closingSubs[2])
      }
    )
  })
  it("should emit windows using varying empty delayed closings", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e2 = cold("    --x-----------y--------z---|           ")
        const e2subs = "     ^--------------------------!           "
        const close = [
          cold("               ---------------|                     "),
          cold("                           ----|                    "),
          cold("                                    ---------------|"),
        ]
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|   ")
        const e1subs = "     ^----------------------------------!   "
        const expected = "   --x-----------y--------z-----------|   "
        const x = cold("       --b---c---d---e---f---g---h------|   ")
        const y = cold("                   --e---f---g---h------|   ")
        const z = cold("                            -g---h------|   ")
        const values = { x, y, z }
        let i = 0
        const result = e1.pipe(windowToggle(e2, () => close[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should emit windows using varying cold closings, outer unsubscribed early", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e2 = cold("    --x-----------y--------z---|              ")
        const e2subs = "     ^----------------!                        "
        const close = [
          cold("               -------------s---|                      "),
          cold("                           -----(s|)                   "),
          cold("                                    ---------------(s|)"),
        ]
        const closeSubs = [
          "                  --^------------!                          ",
          "                  --------------^--!                        ",
        ]
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|      ")
        const e1subs = "     ^----------------!                        "
        const expected = "   --x-----------y---                        "
        const x = cold("       --b---c---d--|                          ")
        const y = cold("                   --e-                        ")
        const unsub = "      -----------------!                        "
        const values = { x, y }
        let i = 0
        const result = e1.pipe(windowToggle(e2, () => close[i++]))
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
        expectSubscriptions(close[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(close[1].subscriptions).toBe(closeSubs[1])
        expectSubscriptions(close[2].subscriptions).toBe([])
      }
    )
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e2 = cold("    --x-----------y--------z---|              ")
        const e2subs = "     ^--------------!                          "
        const close = [
          cold("               ---------------s--|                     "),
          cold("                           ----(s|)                    "),
          cold("                                    ---------------(s|)"),
        ]
        const closeSubs = [
          "                  --^------------!                          ",
          "                  --------------^!                          ",
        ]
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|      ")
        const e1subs = "     ^--------------!                          "
        const expected = "   --x-----------y-                          "
        const x = cold("       --b---c---d---                          ")
        const y = cold("                   --                          ")
        const unsub = "      ---------------!                          "
        const values = { x, y }
        let i = 0
        const result = e1.pipe(
          mergeMap(x => of(x)),
          windowToggle(e2, () => close[i++]),
          mergeMap(x => of(x))
        )
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
        expectSubscriptions(close[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(close[1].subscriptions).toBe(closeSubs[1])
      }
    )
  })
  it("should dispose window Subjects if the outer is unsubscribed early", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions, time }) => {
        const open = cold(" o-------------------------|")
        const e1 = hot("    --a--b--c--d--e--f--g--h--|")
        const e1subs = "    ^--------!                 "
        const expected = "  x---------                 "
        const x = cold("    --a--b--c-                 ")
        const unsub = "     ---------!                 "
        const late = time(" ---------------|           ")
        const values = { x }
        let window: Observable<string>
        const result = e1.pipe(
          windowToggle(open, () => NEVER),
          tap(w => {
            window = w
          })
        )
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        rxTestScheduler.schedule(() => {
          expect(() => {
            window.subscribe()
          }).to.throw(ObjectUnsubscribedError)
        }, late)
      }
    )
  })
  it("should propagate error thrown from closingSelector", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e2 = cold("    --x-----------y--------z---|              ")
        const e2subs = "     ^-------------!                           "
        const close = [
          cold("               ---------------s--|                     "),
          cold("                           ----(s|)                    "),
          cold("                                    ---------------(s|)"),
        ]
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|      ")
        const e1subs = "     ^-------------!                           "
        const expected = "   --x-----------#----                       "
        const x = cold("       --b---c---d-#                           ")
        const values = { x: x }
        let i = 0
        const result = e1.pipe(
          windowToggle(e2, () => {
            if (i === 1) {
              throw "error"
            }
            return close[i++]
          })
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should propagate error emitted from a closing", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e2 = cold("    --x-----------y--------z---|        ")
        const e2subs = "     ^-------------!                     "
        // prettier-ignore
        const close = [
        cold('               ---------------s--|               '),
        cold('                           #                     ')
      ];
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|")
        const e1subs = "     ^-------------!                     "
        const expected = "   --x-----------(y#)                  "
        const x = cold("       --b---c---d-#                     ")
        const y = cold("                   #                     ")
        const values = { x, y }
        let i = 0
        const result = e1.pipe(windowToggle(e2, () => close[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should propagate error emitted late from a closing", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e2 = cold("    --x-----------y--------z---|        ")
        const e2subs = "     ^------------------!                "
        // prettier-ignore
        const close = [
        cold('               ---------------s--|               '),
        cold('                           -----#                ')
      ];
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|")
        const e1subs = "     ^------------------!                "
        const expected = "   --x-----------y----#                "
        const x = cold("       --b---c---d---e|                  ")
        const y = cold("                   --e--#                ")
        const values = { x, y }
        let i = 0
        const result = e1.pipe(windowToggle(e2, () => close[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should handle errors", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e2 = cold("    --x-----------y--------z---|        ")
        const e2subs = "     ^------------------!                "
        // prettier-ignore
        const close = [
        cold('               ---------------s--|               '),
        cold('                           -------s|             ')
      ];
        const e1 = hot("--a--^---b---c---d---e--#                ")
        const e1subs = "     ^------------------!                "
        const expected = "   --x-----------y----#                "
        const x = cold("       --b---c---d---e|                  ")
        const y = cold("                   --e--#                ")
        const values = { x, y }
        let i = 0
        const result = e1.pipe(windowToggle(e2, () => close[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should handle empty source", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e2 = cold("--o-----|")
      const e2subs = "   (^!)"
      const e3 = cold("  -----c--|")
      const e1 = cold("  |")
      const e1subs = "   (^!)"
      const expected = " |"
      const result = e1.pipe(windowToggle(e2, () => e3))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should handle throw", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e2 = cold(" --o-----|")
      const e2subs = "  (^!)"
      const e3 = cold(" -----c--|")
      const e1 = cold(" #")
      const e1subs = "  (^!)"
      const expected = "#"
      const result = e1.pipe(windowToggle(e2, () => e3))
      expectObservable(result).toBe(expected)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should handle never", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e2 = cold(" --o-----o------o-----o---o-----|             ")
        const e2subs = "  ^------------------------------!             "
        const e3 = cold("   --c-|                                      ")
        const e1 = hot("  -                                            ")
        const e1subs = "  ^-------------------------------------------!"
        const expected = "--u-----v------x-----y---z-------------------"
        const u = cold("    --|                                        ")
        const v = cold("          --|                                  ")
        const x = cold("                 --|                           ")
        const y = cold("                       --|                     ")
        const z = cold("                           --|                 ")
        const unsub = "   --------------------------------------------!"
        const values = { u: u, v: v, x, y, z }
        const result = e1.pipe(windowToggle(e2, () => e3))
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should handle a never opening Observable", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e2 = cold("    -                                   ")
        const e2subs = "     ^----------------------------------!"
        const e3 = cold("    --c-|                               ")
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|")
        const e1subs = "     ^----------------------------------!"
        const expected = "   -----------------------------------|"
        const result = e1.pipe(windowToggle(e2, () => e3))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should handle a never closing Observable", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e2 = cold("    ---o---------------o-----------|    ")
        const e2subs = "     ^------------------------------!    "
        const e3 = cold("       -                                ")
        //                                      -
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|")
        const e1subs = "     ^----------------------------------!"
        const expected = "   ---x---------------y---------------|"
        const x = cold("        -b---c---d---e---f---g---h------|")
        const y = cold("                        -f---g---h------|")
        const values = { x, y }
        const result = e1.pipe(windowToggle(e2, () => e3))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should handle opening Observable that just throws", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e2 = cold("    #                                   ")
        const e2subs = "     (^!)                                "
        const e3 = cold("    --c-|                               ")
        const subs = "       (^!)                                "
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|")
        const e1subs = "     (^!)                                "
        const expected = "   #                                   "
        const result = e1.pipe(windowToggle(e2, () => e3))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should handle empty closing observable", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e2 = cold("    ---o---------------o-----------|    ")
        const e2subs = "     ^------------------------------!    "
        const e3 = EMPTY
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|")
        const e1subs = "     ^----------------------------------!"
        const expected = "   ---x---------------y---------------|"
        const x = cold("        -b---c---d---e---f---g---h------|")
        const y = cold("                        -f---g---h------|")
        const values = { x, y }
        const result = e1.pipe(windowToggle(e2, () => e3))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
})
import { windowWhen, mergeMap } from "rxjs/operators"
import { Observable, of } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {windowWhen} */
describe("windowWhen", () => {
  let rxTestScheduler: TestScheduler
  beforeEach(() => {
    rxTestScheduler = new TestScheduler(observableMatcher)
  })
  it("should emit windows that close and reopen", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e2 = cold("       -----------|                ")
        //                                 -----------|
        //                                            -----------|
        const e2subs = [
          "                     ^----------!                ",
          "                     -----------^----------!     ",
          "                     ----------------------^----!",
        ]
        const e1 = hot("   --a--^--b--c--d--e--f--g--h--i--|")
        const e1subs = "        ^--------------------------!"
        const expected = "      a----------b----------c----|"
        const a = cold("        ---b--c--d-|                ")
        const b = cold("                   -e--f--g--h|     ")
        const c = cold("                              --i--|")
        const values = { a: a, b: b, c: c }
        const source = e1.pipe(windowWhen(() => e2))
        expectObservable(source).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should emit windows using varying cold closings", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const closings = [
          cold("               -----------------s--|                    "),
          cold("                                -----(s|)               "),
          cold("                                     ---------------(s|)"),
        ]
        const closeSubs = [
          "                    ^----------------!                       ",
          "                    -----------------^----!                  ",
          "                    ----------------------^------------!     ",
        ]
        const e1 = hot("  --a--^---b---c---d---e---f---g---h------|     ")
        const e1subs = "       ^----------------------------------!     "
        const expected = "     x----------------y----z------------|     "
        const x = cold("       ----b---c---d---e|                       ")
        const y = cold("                        ---f-|                  ")
        const z = cold("                             --g---h------|     ")
        const values = { x: x, y: y, z: z }
        let i = 0
        const result = e1.pipe(windowWhen(() => closings[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1])
        expectSubscriptions(closings[2].subscriptions).toBe(closeSubs[2])
      }
    )
  })
  it("should emit windows using varying hot closings", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const closings = [
          hot("            -1--^----------------s-|                   "),
          hot("                -----3----4-----------(s|)             "),
          hot("                -------3----4-------5----------------s|"),
        ]
        const closeSubs = [
          "                    ^----------------!                     ",
          "                    -----------------^----!                ",
          "                    ----------------------^------------!   ",
        ]
        const e1 = hot("  --a--^---b---c---d---e---f---g---h------|   ")
        const subs = "         ^----------------------------------!   "
        const expected = "     x----------------y----z------------|   "
        const x = cold("       ----b---c---d---e|                     ")
        const y = cold("                        ---f-|                ")
        const z = cold("                             --g---h------|   ")
        const values = { x: x, y: y, z: z }
        let i = 0
        const result = e1.pipe(windowWhen(() => closings[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1])
        expectSubscriptions(closings[2].subscriptions).toBe(closeSubs[2])
      }
    )
  })
  it("should emit windows using varying empty delayed closings", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const closings = [
          cold("             -----------------|                    "),
          cold("                              -----|               "),
          cold("                                   ---------------|"),
        ]
        const closeSubs = [
          "                  ^----------------!                    ",
          "                  -----------------^----!               ",
          "                  ----------------------^------------!  ",
        ]
        const e1 = hot("--a--^---b---c---d---e---f---g---h------|  ")
        const e1subs = "     ^----------------------------------!  "
        const expected = "   x----------------y----z------------|  "
        const x = cold("     ----b---c---d---e|                    ")
        const y = cold("                      ---f-|               ")
        const z = cold("                           --g---h------|  ")
        const values = { x: x, y: y, z: z }
        let i = 0
        const result = e1.pipe(windowWhen(() => closings[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1])
        expectSubscriptions(closings[2].subscriptions).toBe(closeSubs[2])
      }
    )
  })
  it("should emit windows using varying cold closings, outer unsubscribed early", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const closings = [
          cold("               -----------------s--|               "),
          cold("                                ---------(s|)      "),
        ]
        const closeSubs = [
          "                    ^----------------!                  ",
          "                    -----------------^---!              ",
        ]
        const e1 = hot("  --a--^---b---c---d---e---f---g---h------|")
        const e1subs = "       ^--------------------!              "
        const expected = "     x----------------y----              "
        const unsub = "        ---------------------!              "
        const x = cold("       ----b---c---d---e|                  ")
        const y = cold("                        ---f-              ")
        const values = { x: x, y: y }
        let i = 0
        const result = e1.pipe(windowWhen(() => closings[i++]))
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1])
      }
    )
  })
  it("should not break unsubscription chain when unsubscribed explicitly", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const closings = [
          cold("               -----------------s--|               "),
          cold("                                ---------(s|)      "),
        ]
        const closeSubs = [
          "                    ^----------------!                  ",
          "                    -----------------^---!              ",
        ]
        const e1 = hot("  --a--^---b---c---d---e---f---g---h------|")
        const e1subs = "       ^--------------------!              "
        const expected = "     x----------------y----              "
        const unsub = "        ---------------------!              "
        const x = cold("       ----b---c---d---e|                  ")
        const y = cold("                        ---f-              ")
        const values = { x: x, y: y }
        let i = 0
        const result = e1.pipe(
          mergeMap((x: string) => of(x)),
          windowWhen(() => closings[i++]),
          mergeMap((x: Observable<string>) => of(x))
        )
        expectObservable(result, unsub).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1])
      }
    )
  })
  it("should propagate error thrown from closingSelector", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const closings = [
          cold("                 -----------------s--|                    "),
          cold("                                  -----(s|)               "),
          cold("                                       ---------------(s|)"),
        ]
        const closeSubs = ["     ^----------------!                       "]
        const e1 = hot("    --a--^---b---c---d---e---f---g---h------|     ")
        const e1subs = "         ^----------------!                       "
        const expected = "       x----------------(y#)                    "
        const x = cold("         ----b---c---d---e|                       ")
        const y = cold("                          #                       ")
        const values = { x: x, y: y }
        let i = 0
        const result = e1.pipe(
          windowWhen(() => {
            if (i === 1) {
              throw "error"
            }
            return closings[i++]
          })
        )
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0])
      }
    )
  })
  it("should propagate error emitted from a closing", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const closings = [
          cold("               -----------------s--|               "),
          cold("                                #                  "),
        ]
        const closeSubs = [
          "                    ^----------------!                  ",
          "                    -----------------(^!)               ",
        ]
        const e1 = hot("  --a--^---b---c---d---e---f---g---h------|")
        const e1subs = "       ^----------------!                  "
        const expected = "     x----------------(y#)               "
        const x = cold("       ----b---c---d---e|                  ")
        const y = cold("                        #                  ")
        const values = { x: x, y: y }
        let i = 0
        const result = e1.pipe(windowWhen(() => closings[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1])
      }
    )
  })
  it("should propagate error emitted late from a closing", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const closings = [
          cold("               -----------------s--|               "),
          cold("                                -----#             "),
        ]
        const closeSubs = [
          "                    ^----------------!                  ",
          "                    -----------------^----!             ",
        ]
        const e1 = hot("  --a--^---b---c---d---e---f---g---h------|")
        const e1subs = "       ^---------------------!             "
        const expected = "     x----------------y----#             "
        const x = cold("       ----b---c---d---e|                  ")
        const y = cold("                        ---f-#             ")
        const values = { x: x, y: y }
        let i = 0
        const result = e1.pipe(windowWhen(() => closings[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1])
      }
    )
  })
  it("should propagate errors emitted from the source", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        // prettier-ignore
        const closings = [
        cold('               -----------------s--|       '),
        cold('                                -------(s|)'),
      ];
        // prettier-ignore
        const closeSubs = [
        '                    ^----------------!          ',
        '                    -----------------^----!     ',
      ];
        const e1 = hot("  --a--^---b---c---d---e---f-#     ")
        const e1subs = "       ^---------------------!     "
        const expected = "     x----------------y----#     "
        const x = cold("       ----b---c---d---e|          ")
        const y = cold("                        ---f-#     ")
        const values = { x: x, y: y }
        let i = 0
        const result = e1.pipe(windowWhen(() => closings[i++]))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0])
        expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1])
      }
    )
  })
  it("should handle empty source", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e2 = cold(" -----c--|")
      const e2subs = "  (^!)     "
      const e1 = cold(" |        ")
      const e1subs = "  (^!)     "
      const expected = "(w|)     "
      const win = cold("|        ")
      const values = { w: win }
      const result = e1.pipe(windowWhen(() => e2))
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should handle a never source", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e2 = cold(" -----c--|         ")
      //                     -----c--|
      //                        -----c--|
      //                             -----
      const e2subs = [
        "               ^----!            ",
        "               -----^----!       ",
        "               ----------^----!  ",
        "               ---------------^-!",
      ]
      const e1 = cold(" -                 ")
      const e1subs = "  ^----------------!"
      const expected = "a----b----c----d--"
      const unsub = "   -----------------!"
      const win = cold("-----|")
      //                     -----|
      //                          -----|
      const d = cold("                 ---")
      const values = { a: win, b: win, c: win, d: d }
      const result = e1.pipe(windowWhen(() => e2))
      expectObservable(result, unsub).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should handle throw", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e2 = cold(" -----c--|")
      const e2subs = "  (^!)     "
      const e1 = cold(" #        ")
      const e1subs = "  (^!)     "
      const expected = "(w#)     "
      const win = cold("#        ")
      const values = { w: win }
      const result = e1.pipe(windowWhen(() => e2))
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should handle a never closing Observable", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e2 = cold("      -                                  ")
        const e2subs = "       ^----------------------------------!"
        const e1 = hot("  --a--^---b---c---d---e---f---g---h------|")
        const e1subs = "       ^----------------------------------!"
        const expected = "     x----------------------------------|"
        const x = cold("       ----b---c---d---e---f---g---h------|")
        const values = { x: x }
        const result = e1.pipe(windowWhen(() => e2))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
  it("should handle a throw closing Observable", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e2 = cold("      #                                   ")
        const e2subs = "       (^!)                                "
        const e1 = hot("  --a--^---b---c---d---e---f---g---h------|")
        const e1subs = "       (^!)                                "
        const expected = "     (x#)                                "
        const x = cold("       #                                   ")
        const values = { x: x }
        const result = e1.pipe(windowWhen(() => e2))
        expectObservable(result).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
      }
    )
  })
})
import { expect } from "chai"
import { lowerCaseO } from "../helpers/test-helper"
import { withLatestFrom, mergeMap, delay } from "rxjs/operators"
import { of } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {withLatestFrom} */
describe("withLatestFrom", () => {
  let rxTestScheduler: TestScheduler
  beforeEach(() => {
    rxTestScheduler = new TestScheduler(observableMatcher)
  })
  it("should combine events from cold observables", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const e2 = cold(" --1--2-3-4---|   ")
      const e2subs = "  ^------------!   "
      const e1 = cold(" -a--b-----c-d-e-|")
      const e1subs = "  ^---------------!"
      const expected = "----B-----C-D-E-|"
      const result = e1.pipe(
        withLatestFrom(e2, (a: string, b: string) => String(a) + String(b))
      )
      expectObservable(result).toBe(expected, {
        B: "b1",
        C: "c4",
        D: "d4",
        E: "e4",
      })
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
    })
  })
  it("should merge the value with the latest values from the other observables into arrays", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e2 = hot("  --e--^-f---g---h------|")
      const e2subs = "       ^-------------!   "
      const e3 = hot("  --i--^-j---k---l------|")
      const e3subs = "       ^-------------!   "
      const e1 = hot("  --a--^---b---c---d-|   ")
      const e1subs = "       ^-------------!   "
      const expected = "     ----x---y---z-|   "
      const values = {
        x: ["b", "f", "j"],
        y: ["c", "g", "k"],
        z: ["d", "h", "l"],
      }
      const result = e1.pipe(withLatestFrom(e2, e3))
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
      expectSubscriptions(e3.subscriptions).toBe(e3subs)
    })
  })
  it("should merge the value with the latest values from the other observables into arrays and a project argument", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e2 = hot("  --e--^-f---g---h------|")
      const e2subs = "       ^-------------!   "
      const e3 = hot("  --i--^-j---k---l------|")
      const e3subs = "       ^-------------!   "
      const e1 = hot("  --a--^---b---c---d-|   ")
      const e1subs = "       ^-------------!   "
      const expected = "     ----x---y---z-|   "
      const values = {
        x: "bfj",
        y: "cgk",
        z: "dhl",
      }
      const project = (a: string, b: string, c: string) => a + b + c
      const result = e1.pipe(withLatestFrom(e2, e3, project))
      expectObservable(result).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
      expectSubscriptions(e3.subscriptions).toBe(e3subs)
    })
  })
  it("should allow unsubscribing early and explicitly", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e2 = hot("  --e--^-f---g---h------|")
      const e2subs = "       ^----------!      "
      const e3 = hot("  --i--^-j---k---l------|")
      const e3subs = "       ^----------!      "
      const e1 = hot("  --a--^---b---c---d-|   ")
      const e1subs = "       ^----------!      "
      const expected = "     ----x---y---      "
      const unsub = "        -----------!      "
      const values = {
        x: "bfj",
        y: "cgk",
        z: "dhl",
      }
      const project = (a: string, b: string, c: string) => a + b + c
      const result = e1.pipe(withLatestFrom(e2, e3, project))
      expectObservable(result, unsub).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
      expectSubscriptions(e3.subscriptions).toBe(e3subs)
    })
  })
  it("should not break unsubscription chains when result is unsubscribed explicitly", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e2 = hot("  --e--^-f---g---h------|")
      const e2subs = "       ^----------!      "
      const e3 = hot("  --i--^-j---k---l------|")
      const e3subs = "       ^----------!      "
      const e1 = hot("  --a--^---b---c---d-|   ")
      const e1subs = "       ^----------!      "
      const expected = "     ----x---y---      "
      const unsub = "        -----------!      "
      const values = {
        x: "bfj",
        y: "cgk",
        z: "dhl",
      }
      const project = (a: string, b: string, c: string) => a + b + c
      const result = e1.pipe(
        mergeMap((x: string) => of(x)),
        withLatestFrom(e2, e3, project),
        mergeMap((x: string) => of(x))
      )
      expectObservable(result, unsub).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
      expectSubscriptions(e3.subscriptions).toBe(e3subs)
    })
  })
  it("should handle empty", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const e2 = hot("  --e--^-f---g---h----|")
        const e2subs = "       (^!)            "
        const e3 = hot("  --i--^-j---k---l----|")
        const e3subs = "       (^!)            "
        const e1 = cold("      |               ")
        const e1subs = "       (^!)            "
        const expected = "     |               " // empty
        const result = e1.pipe(withLatestFrom(e2, e3))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
        expectSubscriptions(e3.subscriptions).toBe(e3subs)
      }
    )
  })
  it("should handle never", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e2 = hot("   --e--^-f---g---h----|  ")
        const e2subs = "        ^--------------!  "
        const e3 = hot("   --i--^-j---k---l----|  ")
        const e3subs = "        ^--------------!  "
        const e1 = cold("        -                ")
        const e1subs = "         ^----------------"
        const expected = "    --------------------" // never
        const result = e1.pipe(withLatestFrom(e2, e3))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
        expectSubscriptions(e3.subscriptions).toBe(e3subs)
      }
    )
  })
  it("should handle throw", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e2 = hot("  --e--^-f---g---h----|")
        const e2subs = "       (^!)            "
        const e3 = hot("  --i--^-j---k---l----|")
        const e3subs = "       (^!)            "
        const e1 = cold("      #               ")
        const e1subs = "       (^!)            "
        const expected = "     #               " // throw
        const result = e1.pipe(withLatestFrom(e2, e3))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
        expectSubscriptions(e3.subscriptions).toBe(e3subs)
      }
    )
  })
  it("should handle error", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e2 = hot("  --e--^-f---g---h----|")
      const e2subs = "       ^-------!       "
      const e3 = hot("  --i--^-j---k---l----|")
      const e3subs = "       ^-------!       "
      const e1 = hot("  --a--^---b---#       ", undefined, new Error("boo-hoo"))
      const e1subs = "       ^-------!       "
      const expected = "     ----x---#       " // throw
      const values = {
        x: ["b", "f", "j"],
      }
      const result = e1.pipe(withLatestFrom(e2, e3))
      expectObservable(result).toBe(expected, values, new Error("boo-hoo"))
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
      expectSubscriptions(e3.subscriptions).toBe(e3subs)
    })
  })
  it("should handle error with project argument", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e2 = hot("  --e--^-f---g---h----|")
      const e2subs = "       ^-------!       "
      const e3 = hot("  --i--^-j---k---l----|")
      const e3subs = "       ^-------!       "
      const e1 = hot("  --a--^---b---#       ", undefined, new Error("boo-hoo"))
      const e1subs = "       ^-------!       "
      const expected = "     ----x---#       " // throw
      const values = {
        x: "bfj",
      }
      const project = (a: string, b: string, c: string) => a + b + c
      const result = e1.pipe(withLatestFrom(e2, e3, project))
      expectObservable(result).toBe(expected, values, new Error("boo-hoo"))
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
      expectSubscriptions(e3.subscriptions).toBe(e3subs)
    })
  })
  it("should handle merging with empty", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e2 = cold("      |                 ")
        const e2subs = "       (^!)              "
        const e3 = hot("  --i--^-j---k---l------|")
        const e3subs = "       ^-------------!   "
        const e1 = hot("  --a--^---b---c---d-|   ")
        const e1subs = "       ^-------------!   "
        const expected = "     --------------|   "
        const result = e1.pipe(withLatestFrom(e2, e3))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
        expectSubscriptions(e3.subscriptions).toBe(e3subs)
      }
    )
  })
  it("should handle merging with never", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const e2 = cold("      -                 ")
        const e2subs = "       ^-------------!   "
        const e3 = hot("  --i--^-j---k---l------|")
        const e3subs = "       ^-------------!   "
        const e1 = hot("  --a--^---b---c---d-|   ")
        const e1subs = "       ^-------------!   "
        const expected = "     --------------|   "
        const result = e1.pipe(withLatestFrom(e2, e3))
        expectObservable(result).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
        expectSubscriptions(e2.subscriptions).toBe(e2subs)
        expectSubscriptions(e3.subscriptions).toBe(e3subs)
      }
    )
  })
  it("should handle promises", done => {
    of(1)
      .pipe(delay(1), withLatestFrom(Promise.resolve(2), Promise.resolve(3)))
      .subscribe({
        next(x: any) {
          expect(x).to.deep.equal([1, 2, 3])
        },
        complete: done,
      })
  })
  it("should handle arrays", () => {
    of(1)
      .pipe(delay(1), withLatestFrom([2, 3, 4], [4, 5, 6]))
      .subscribe((x: any) => {
        expect(x).to.deep.equal([1, 4, 6])
      })
  })
  it("should handle lowercase-o observables", () => {
    of(1)
      .pipe(delay(1), withLatestFrom(lowerCaseO(2, 3, 4), lowerCaseO(4, 5, 6)))
      .subscribe((x: any) => {
        expect(x).to.deep.equal([1, 4, 6])
      })
  })
  it("should work with synchronous observables", () => {
    const result: Array<Array<number>> = []
    of(1, 2, 3)
      .pipe(withLatestFrom(of(4, 5)))
      .subscribe(x => {
        result.push(x)
      })
    expect(result.length).to.equal(3)
    expect(result[0]).to.deep.equal([1, 5])
    expect(result[1]).to.deep.equal([2, 5])
    expect(result[2]).to.deep.equal([3, 5])
  })
})
import { expect } from "chai"
import { zip } from "rxjs/operators"
import { from } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/**
 * zip legacy still supports a mapping function, but it's deprecated
 */
describe("zip legacy", () => {
  let rxTestScheduler: TestScheduler
  beforeEach(() => {
    rxTestScheduler = new TestScheduler(observableMatcher)
  })
  it("should zip the provided observables", done => {
    const expected = ["a1", "b2", "c3"]
    let i = 0
    from(["a", "b", "c"])
      .pipe(zip(from([1, 2, 3]), (a, b): string => a + b))
      .subscribe({
        next(x) {
          expect(x).to.equal(expected[i++])
        },
        complete: done,
      })
  })
  it("should work with selector throws", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("---1-^-2---4----|  ")
      const asubs = "     ^-------!     "
      const b = hot("---1-^--3----5----|")
      const bsubs = "     ^-------!     "
      const expected = "  ---x----#     "
      const selector = (x: string, y: string) => {
        if (y === "5") {
          throw new Error("too bad")
        } else {
          return x + y
        }
      }
      const observable = a.pipe(zip(b, selector))
      expectObservable(observable).toBe(
        expected,
        { x: "23" },
        new Error("too bad")
      )
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with some data asymmetric 1", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("---1-^-1-3-5-7-9-x-y-z-w-u-|")
      const asubs = "     ^-----------------!    "
      const b = hot("---1-^--2--4--6--8--0--|    ")
      const bsubs = "     ^-----------------!    "
      const expected = "  ---a--b--c--d--e--|    "
      expectObservable(
        a.pipe(
          zip(b, (r1, r2) => {
            return r1 + r2
          })
        )
      ).toBe(expected, { a: "12", b: "34", c: "56", d: "78", e: "90" })
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with some data asymmetric 2", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("---1-^--2--4--6--8--0--|    ")
      const asubs = "     ^-----------------!    "
      const b = hot("---1-^-1-3-5-7-9-x-y-z-w-u-|")
      const bsubs = "     ^-----------------!    "
      const expected = "  ---a--b--c--d--e--|    "
      expectObservable(
        a.pipe(
          zip(b, (r1, r2) => {
            return r1 + r2
          })
        )
      ).toBe(expected, { a: "21", b: "43", c: "65", d: "87", e: "09" })
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with some data symmetric", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("---1-^-1-3-5-7-9------| ")
      const asubs = "     ^----------------! "
      const b = hot("---1-^--2--4--6--8--0--|")
      const bsubs = "     ^----------------! "
      const expected = "  ---a--b--c--d--e-| "
      expectObservable(
        a.pipe(
          zip(b, (r1, r2) => {
            return r1 + r2
          })
        )
      ).toBe(expected, { a: "12", b: "34", c: "56", d: "78", e: "90" })
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with n-ary symmetric selector", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("---1-^-1----4----|")
      const asubs = "     ^---------!  "
      const b = hot("---1-^--2--5----| ")
      const bsubs = "     ^---------!  "
      const c = hot("---1-^---3---6-|  ")
      const expected = "  ----x---y-|  "
      const observable = a.pipe(
        zip(b, c, (r0, r1, r2) => {
          return [r0, r1, r2]
        })
      )
      expectObservable(observable).toBe(expected, {
        x: ["1", "2", "3"],
        y: ["4", "5", "6"],
      })
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with n-ary symmetric array selector", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("---1-^-1----4----|")
      const asubs = "     ^---------!  "
      const b = hot("---1-^--2--5----| ")
      const bsubs = "     ^---------!  "
      const c = hot("---1-^---3---6-|  ")
      const expected = "  ----x---y-|  "
      const observable = a.pipe(
        zip(b, c, (r0, r1, r2) => {
          return [r0, r1, r2]
        })
      )
      expectObservable(observable).toBe(expected, {
        x: ["1", "2", "3"],
        y: ["4", "5", "6"],
      })
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should combine two observables and selector", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("   ---1---2---3---")
      const asubs = "   ^"
      const b = hot("   --4--5--6--7--8--")
      const bsubs = "   ^"
      const expected = "---x---y---z"
      expectObservable(
        a.pipe(
          zip(b, (e1, e2) => {
            return e1 + e2
          })
        )
      ).toBe(expected, { x: "14", y: "25", z: "36" })
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
})
import { zip } from "rxjs/operators"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {zip} */
describe("zip", () => {
  let rxTestScheduler: TestScheduler
  beforeEach(() => {
    rxTestScheduler = new TestScheduler(observableMatcher)
  })
  it("should work with non-empty observable and non-empty iterable selector that throws", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("---^--1--2--3--|")
      const asubs = "   ^-----!"
      const expected = "---x--#"
      const b = [4, 5, 6]
      const selector = function (x: string, y: number) {
        if (y === 5) {
          throw new Error("too bad")
        } else {
          return x + y
        }
      }
      expectObservable(a.pipe(zip(b, selector))).toBe(
        expected,
        { x: "14" },
        new Error("too bad")
      )
      expectSubscriptions(a.subscriptions).toBe(asubs)
    })
  })
})
import { expect } from "chai"
import { zipAll, mergeMap } from "rxjs/operators"
import { queueScheduler, of, zip, scheduled } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {zipAll} */
describe("zipAll operator", () => {
  let rxTestScheduler: TestScheduler
  beforeEach(() => {
    rxTestScheduler = new TestScheduler(observableMatcher)
  })
  it("should combine paired events from two observables", () => {
    rxTestScheduler.run(({ hot, cold, expectObservable }) => {
      const x = cold("                  -a-----b-|")
      const y = cold("                  --1-2-----")
      const outer = hot("-x----y--------|         ", { x: x, y: y })
      const expected = " -----------------A----B-|"
      const result = outer.pipe(zipAll((a, b) => a + b))
      expectObservable(result).toBe(expected, { A: "a1", B: "b2" })
    })
  })
  it("should combine two observables", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("   ---1---2---3---")
      const asubs = "   ^"
      const b = hot("   --4--5--6--7--8--")
      const bsubs = "   ^"
      const expected = "---x---y---z"
      const values = { x: ["1", "4"], y: ["2", "5"], z: ["3", "6"] }
      expectObservable(of(a, b).pipe(zipAll())).toBe(expected, values)
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should take all observables from the source and zip them", done => {
    const expected = ["a1", "b2", "c3"]
    let i = 0
    of(of("a", "b", "c"), of(1, 2, 3))
      .pipe(zipAll((a: string, b: number) => a + b))
      .subscribe({
        next(x) {
          expect(x).to.equal(expected[i++])
        },
        complete: done,
      })
  })
  it("should end once one observable completes and its buffer is empty", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---a--b--c--|               ")
      const e1subs = "  ^-----------!               "
      const e2 = hot("  ------d----e----f--------|  ")
      const e2subs = "  ^-----------------!         "
      const e3 = hot("  --------h----i----j---------") // doesn't complete
      const e3subs = "  ^-----------------!         "
      const expected = "--------x----y----(z|)      " // e1 complete and buffer empty
      const values = {
        x: ["a", "d", "h"],
        y: ["b", "e", "i"],
        z: ["c", "f", "j"],
      }
      expectObservable(of(e1, e2, e3).pipe(zipAll())).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
      expectSubscriptions(e3.subscriptions).toBe(e3subs)
    })
  })
  it("should end once one observable nexts and zips value from completed other observable whose buffer is empty", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---a--b--c--|             ")
      const e1subs = "  ^-----------!             "
      const e2 = hot("  ------d----e----f|        ")
      const e2subs = "  ^----------------!        "
      const e3 = hot("  --------h----i----j-------") // doesn't complete
      const e3subs = "  ^-----------------!       "
      const expected = "--------x----y----(z|)    " // e2 buffer empty and signaled complete
      const values = {
        x: ["a", "d", "h"],
        y: ["b", "e", "i"],
        z: ["c", "f", "j"],
      }
      expectObservable(of(e1, e2, e3).pipe(zipAll())).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
      expectSubscriptions(e3.subscriptions).toBe(e3subs)
    })
  })
  describe("with iterables", () => {
    it("should zip them with values", () => {
      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
        const myIterator = (function* () {
          for (let i = 0; i < 4; i++) {
            yield i
          }
        })()
        const e1 = hot("  ---a---b---c---d---|")
        const e1subs = "  ^--------------!"
        const expected = "---w---x---y---(z|)"
        const values = {
          w: ["a", 0],
          x: ["b", 1],
          y: ["c", 2],
          z: ["d", 3],
        }
        expectObservable(
          of(e1, myIterator).pipe(zipAll<string | number>())
        ).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      })
    })
    it("should complete instantly with never observable and empty iterable", () => {
      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
        const a = cold("  -")
        const asubs = "   (^!)"
        const b: string[] = []
        const expected = "|"
        expectObservable(of(a, b).pipe(zipAll())).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
      })
    })
    it("should work with empty observable and empty iterable", () => {
      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
        const a = cold("  |")
        const asubs = "   (^!)"
        const b: string[] = []
        const expected = "|"
        expectObservable(of(a, b).pipe(zipAll())).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
      })
    })
    it("should work with empty observable and non-empty iterable", () => {
      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
        const a = cold("  |")
        const asubs = "   (^!)"
        const b = [1]
        const expected = "|"
        expectObservable(of(a, b).pipe(zipAll<string | number>())).toBe(
          expected
        )
        expectSubscriptions(a.subscriptions).toBe(asubs)
      })
    })
    it("should work with non-empty observable and empty iterable", () => {
      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
        const a = hot("---^----a--|")
        const asubs = "   (^!)"
        const b: string[] = []
        const expected = "|"
        expectObservable(of(a, b).pipe(zipAll())).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
      })
    })
    it("should work with never observable and non-empty iterable", () => {
      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
        const a = cold("  -")
        const asubs = "   ^"
        const b = [1]
        const expected = "-"
        expectObservable(of(a, b).pipe(zipAll<string | number>())).toBe(
          expected
        )
        expectSubscriptions(a.subscriptions).toBe(asubs)
      })
    })
    it("should work with non-empty observable and non-empty iterable", () => {
      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
        const a = hot("---^----1--|")
        const asubs = "   ^----!   "
        const b = [2]
        const expected = "-----(x|)"
        expectObservable(of(a, b).pipe(zipAll<string | number>())).toBe(
          expected,
          { x: ["1", 2] }
        )
        expectSubscriptions(a.subscriptions).toBe(asubs)
      })
    })
    it("should work with observable which raises error and non-empty iterable", () => {
      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
        const a = hot("---^----#")
        const asubs = "   ^----!"
        const b = [1]
        const expected = "-----#"
        expectObservable(of(a, b).pipe(zipAll<string | number>())).toBe(
          expected
        )
        expectSubscriptions(a.subscriptions).toBe(asubs)
      })
    })
    it("should work with non-empty many observable and non-empty many iterable", () => {
      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
        const a = hot("---^--1--2--3--|")
        const asubs = "   ^--------!   "
        const b = [4, 5, 6]
        const expected = "---x--y--(z|)"
        expectObservable(of(a, b).pipe(zipAll<string | number>())).toBe(
          expected,
          { x: ["1", 4], y: ["2", 5], z: ["3", 6] }
        )
        expectSubscriptions(a.subscriptions).toBe(asubs)
      })
    })
    it("should work with non-empty observable and non-empty iterable selector that throws", () => {
      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
        const a = hot("---^--1--2--3--|")
        const asubs = "   ^-----!"
        const b = [4, 5, 6]
        const expected = "---x--#"
        const selector = function (x: string, y: number) {
          if (y === 5) {
            throw new Error("too bad")
          } else {
            return x + y
          }
        }
        expectObservable(of(a, b).pipe(zipAll(selector))).toBe(
          expected,
          { x: "14" },
          new Error("too bad")
        )
        expectSubscriptions(a.subscriptions).toBe(asubs)
      })
    })
  })
  it("should combine two observables and selector", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("   ---1---2---3---")
      const asubs = "   ^"
      const b = hot("   --4--5--6--7--8--")
      const bsubs = "   ^"
      const expected = "---x---y---z"
      expectObservable(of(a, b).pipe(zipAll((e1, e2) => e1 + e2))).toBe(
        expected,
        { x: "14", y: "25", z: "36" }
      )
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with n-ary symmetric", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("   ---1-^-1----4----|")
      const asubs = "        ^---------!  "
      const b = hot("   ---1-^--2--5----| ")
      const bsubs = "        ^---------!  "
      const c = hot("   ---1-^---3---6-|  ")
      const expected = "     ----x---y-|  "
      expectObservable(of(a, b, c).pipe(zipAll())).toBe(expected, {
        x: ["1", "2", "3"],
        y: ["4", "5", "6"],
      })
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with n-ary symmetric selector", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("---1-^-1----4----|")
      const asubs = "     ^---------!  "
      const b = hot("---1-^--2--5----| ")
      const bsubs = "     ^---------!  "
      const c = hot("---1-^---3---6-|  ")
      const expected = "  ----x---y-|  "
      const observable = of(a, b, c).pipe(zipAll((r0, r1, r2) => [r0, r1, r2]))
      expectObservable(observable).toBe(expected, {
        x: ["1", "2", "3"],
        y: ["4", "5", "6"],
      })
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with n-ary symmetric array selector", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("   ---1-^-1----4----|")
      const asubs = "        ^---------!  "
      const b = hot("   ---1-^--2--5----| ")
      const bsubs = "        ^---------!  "
      const c = hot("   ---1-^---3---6-|  ")
      const expected = "     ----x---y-|  "
      const observable = of(a, b, c).pipe(zipAll((r0, r1, r2) => [r0, r1, r2]))
      expectObservable(observable).toBe(expected, {
        x: ["1", "2", "3"],
        y: ["4", "5", "6"],
      })
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with some data asymmetric 1", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("---1-^-1-3-5-7-9-x-y-z-w-u-|")
      const asubs = "     ^-----------------!    "
      const b = hot("---1-^--2--4--6--8--0--|    ")
      const bsubs = "     ^-----------------!    "
      const expected = "  ---a--b--c--d--e--|    "
      expectObservable(of(a, b).pipe(zipAll((r1, r2) => r1 + r2))).toBe(
        expected,
        { a: "12", b: "34", c: "56", d: "78", e: "90" }
      )
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with some data asymmetric 2", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("---1-^--2--4--6--8--0--|    ")
      const asubs = "     ^-----------------!    "
      const b = hot("---1-^-1-3-5-7-9-x-y-z-w-u-|")
      const bsubs = "     ^-----------------!    "
      const expected = "  ---a--b--c--d--e--|    "
      expectObservable(of(a, b).pipe(zipAll((r1, r2) => r1 + r2))).toBe(
        expected,
        { a: "21", b: "43", c: "65", d: "87", e: "09" }
      )
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with some data symmetric", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("---1-^-1-3-5-7-9------| ")
      const asubs = "     ^----------------! "
      const b = hot("---1-^--2--4--6--8--0--|")
      const bsubs = "     ^----------------! "
      const expected = "  ---a--b--c--d--e-| "
      expectObservable(of(a, b).pipe(zipAll((r1, r2) => r1 + r2))).toBe(
        expected,
        { a: "12", b: "34", c: "56", d: "78", e: "90" }
      )
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with selector throws", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("---1-^-2---4----|  ")
      const asubs = "     ^-------!     "
      const b = hot("---1-^--3----5----|")
      const bsubs = "     ^-------!     "
      const expected = "  ---x----#     "
      const selector = function (x: string, y: string) {
        if (y === "5") {
          throw new Error("too bad")
        } else {
          return x + y
        }
      }
      const observable = of(a, b).pipe(zipAll(selector))
      expectObservable(observable).toBe(
        expected,
        { x: "23" },
        new Error("too bad")
      )
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  // TODO: This does not seem to belong in this battery of tests.
  it("should work with right completes first", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("---1-^-2-----|")
      const asubs = "     ^-----!"
      const b = hot("---1-^--3--|")
      const bsubs = "     ^-----!"
      const expected = "  ---x--|"
      expectObservable(zip(a, b)).toBe(expected, { x: ["2", "3"] })
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should zip until one child terminates", done => {
    const expected = ["a1", "b2"]
    let i = 0
    of(of("a", "b", "c"), of(1, 2))
      .pipe(zipAll((a: string, b: number) => a + b))
      .subscribe({
        next: x => {
          expect(x).to.equal(expected[i++])
        },
        complete: done,
      })
  })
  it("should handle a hot observable of observables", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("          a---b---c---|      ")
        const xsubs = "   --------^-----------!"
        const y = cold("          d---e---f---|   ")
        const ysubs = "   --------^-----------!"
        const e1 = hot("  --x--y--|            ", { x: x, y: y })
        const e1subs = "  ^-------!            "
        const expected = "--------u---v---w---|"
        const values = {
          u: ["a", "d"],
          v: ["b", "e"],
          w: ["c", "f"],
        }
        expectObservable(e1.pipe(zipAll())).toBe(expected, values)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should handle merging a hot observable of non-overlapped observables", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("                             a-b---------|")
        const xsubs = "   ---------------------------^-----------!"
        const y = cold("                             c-d-e-f-|")
        const ysubs = "   ---------------------------^-------!"
        const z = cold("                             g-h-i-j-k-|")
        const zsubs = "   ---------------------------^---------!"
        const e1 = hot("  --x------y--------z--------|            ", {
          x: x,
          y: y,
          z: z,
        })
        const e1subs = "  ^--------------------------!            "
        const expected = "---------------------------u-v---------|"
        const values = {
          u: ["a", "c", "g"],
          v: ["b", "d", "h"],
        }
        expectObservable(e1.pipe(zipAll())).toBe(expected, values)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(z.subscriptions).toBe(zsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should raise error if inner observable raises error", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const x = cold("                                a-b---------|")
        const xsubs = "   ------------------------------^-------!"
        const y = cold("                                c-d-e-f-#")
        const ysubs = "   ------------------------------^-------!"
        const z = cold("                                g-h-i-j-k-|")
        const zsubs = "   ------------------------------^-------!"
        const e1 = hot("  --x---------y--------z--------|        ", {
          x: x,
          y: y,
          z: z,
        })
        const e1subs = "  ^-----------------------------!        "
        const expected = "------------------------------u-v-----#"
        const expectedValues = {
          u: ["a", "c", "g"],
          v: ["b", "d", "h"],
        }
        expectObservable(e1.pipe(zipAll())).toBe(expected, expectedValues)
        expectSubscriptions(x.subscriptions).toBe(xsubs)
        expectSubscriptions(y.subscriptions).toBe(ysubs)
        expectSubscriptions(z.subscriptions).toBe(zsubs)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should raise error if outer observable raises error", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const y = cold("  a-b---------|")
        const z = cold("  c-d-e-f-|")
        const e1 = hot("  --y---------z---#", { y: y, z: z })
        const e1subs = "  ^---------------!"
        const expected = "----------------#"
        expectObservable(e1.pipe(zipAll())).toBe(expected)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      }
    )
  })
  it("should work with two nevers", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const a = cold("  -")
      const asubs = "   ^"
      const b = cold("  -")
      const bsubs = "   ^"
      const expected = "-"
      expectObservable(of(a, b).pipe(zipAll())).toBe(expected)
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with never and empty", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const a = cold("  -")
      const asubs = "   (^!)"
      const b = cold("  |")
      const bsubs = "   (^!)"
      const expected = "|"
      expectObservable(of(a, b).pipe(zipAll())).toBe(expected)
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with empty and never", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const a = cold("  |")
      const asubs = "   (^!)"
      const b = cold("  -")
      const bsubs = "   (^!)"
      const expected = "|"
      expectObservable(of(a, b).pipe(zipAll())).toBe(expected)
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with empty and empty", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const a = cold("  |")
      const asubs = "   (^!)"
      const b = cold("  |")
      const bsubs = "   (^!)"
      const expected = "|"
      expectObservable(of(a, b).pipe(zipAll())).toBe(expected)
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with empty and non-empty", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const a = cold("  |")
        const asubs = "   (^!)"
        const b = hot("   ---1--|")
        const bsubs = "   (^!)"
        const expected = "|"
        expectObservable(of(a, b).pipe(zipAll())).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
      }
    )
  })
  it("should work with non-empty and empty", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const a = hot("   ---1--|")
        const asubs = "   (^!)"
        const b = cold("  |")
        const bsubs = "   (^!)"
        const expected = "|"
        expectObservable(of(a, b).pipe(zipAll())).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
      }
    )
  })
  it("should work with never and non-empty", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const a = cold("  -")
        const asubs = "   ^"
        const b = hot("   ---1--|")
        const bsubs = "   ^-----!"
        const expected = "-"
        expectObservable(of(a, b).pipe(zipAll())).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
      }
    )
  })
  it("should work with non-empty and never", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const a = hot("   ---1--|")
        const asubs = "   ^-----!"
        const b = cold("  -")
        const bsubs = "   ^"
        const expected = "-"
        expectObservable(of(a, b).pipe(zipAll())).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
      }
    )
  })
  it("should combine a source with a second", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("   ---1---2---3---")
      const asubs = "   ^"
      const b = hot("   --4--5--6--7--8--")
      const bsubs = "   ^"
      const expected = "---x---y---z"
      expectObservable(of(a, b).pipe(zipAll())).toBe(expected, {
        x: ["1", "4"],
        y: ["2", "5"],
        z: ["3", "6"],
      })
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with empty and error", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const a = cold("  |")
        const asubs = "   (^!)"
        const b = hot("   ------#", undefined, "too bad")
        const bsubs = "   (^!)"
        const expected = "|"
        expectObservable(of(a, b).pipe(zipAll())).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
      }
    )
  })
  it("should work with error and empty", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const a = hot("   ------#", undefined, "too bad")
        const asubs = "   (^!)"
        const b = cold("  |")
        const bsubs = "   (^!)"
        const expected = "|"
        expectObservable(of(a, b).pipe(zipAll())).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
      }
    )
  })
  it("should work with error", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("   ----------|")
      const asubs = "   ^-----!    "
      const b = hot("   ------#    ")
      const bsubs = "   ^-----!    "
      const expected = "------#    "
      expectObservable(of(a, b).pipe(zipAll())).toBe(expected)
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with never and error", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const a = cold("  -")
        const asubs = "   ^-----!"
        const b = hot("   ------#")
        const bsubs = "   ^-----!"
        const expected = "------#"
        expectObservable(of(a, b).pipe(zipAll())).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
      }
    )
  })
  it("should work with error and never", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const a = hot("   ------#")
        const asubs = "   ^-----!"
        const b = cold("  -")
        const bsubs = "   ^-----!"
        const expected = "------#"
        expectObservable(of(a, b).pipe(zipAll())).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
      }
    )
  })
  it("should work with error and error", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("   ------#", undefined, "too bad")
      const asubs = "   ^-----!"
      const b = hot("   ----------#", undefined, "too bad 2")
      const bsubs = "   ^-----!"
      const expected = "------#"
      expectObservable(of(a, b).pipe(zipAll())).toBe(expected, null, "too bad")
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with two sources that eventually raise errors", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("   --w-----#----", { w: 1 }, "too bad")
      const asubs = "   ^-------!"
      const b = hot("   -----z-----#-", { z: 2 }, "too bad 2")
      const bsubs = "   ^-------!"
      const expected = "-----x--#"
      expectObservable(of(a, b).pipe(zipAll())).toBe(
        expected,
        { x: [1, 2] },
        "too bad"
      )
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with two sources that eventually raise errors (swapped)", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("   -----z-----#-", { z: 2 }, "too bad 2")
      const asubs = "   ^-------!"
      const b = hot("   --w-----#", { w: 1 }, "too bad")
      const bsubs = "   ^-------!"
      const expected = "-----x--#"
      expectObservable(of(a, b).pipe(zipAll())).toBe(
        expected,
        { x: [2, 1] },
        "too bad"
      )
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with error and some", () => {
    rxTestScheduler.run(
      ({ hot, cold, expectObservable, expectSubscriptions }) => {
        const a = cold("  #")
        const asubs = "   (^!)"
        const b = hot("   --1--2--3--")
        const bsubs = "   (^!)"
        const expected = "#"
        expectObservable(of(a, b).pipe(zipAll())).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
      }
    )
  })
  it("should combine two immediately-scheduled observables", done => {
    rxTestScheduler.run(() => {
      const a = scheduled([1, 2, 3], queueScheduler)
      const b = scheduled([4, 5, 6, 7, 8], queueScheduler)
      const r = [
        [1, 4],
        [2, 5],
        [3, 6],
      ]
      let i = 0
      const result = scheduled([a, b], queueScheduler).pipe(zipAll())
      result.subscribe({
        next(vals) {
          expect(vals).to.deep.equal(r[i++])
        },
        complete: done,
      })
    })
  })
  it("should combine a source with an immediately-scheduled source", done => {
    const a = scheduled([1, 2, 3], queueScheduler)
    const b = of(4, 5, 6, 7, 8)
    const r = [
      [1, 4],
      [2, 5],
      [3, 6],
    ]
    let i = 0
    const result = scheduled([a, b], queueScheduler).pipe(zipAll())
    result.subscribe({
      next(vals) {
        expect(vals).to.deep.equal(r[i++])
      },
      complete: done,
    })
  })
  it("should not break unsubscription chain when unsubscribed explicitly", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("   ---1---2---3---|")
      const unsub = "   ---------!"
      const asubs = "   ^--------!"
      const b = hot("   --4--5--6--7--8--|")
      const bsubs = "   ^--------!"
      const expected = "---x---y--"
      const values = { x: ["1", "4"], y: ["2", "5"] }
      const r = of(a, b).pipe(
        mergeMap(x => of(x)),
        zipAll(),
        mergeMap(x => of(x))
      )
      expectObservable(r, unsub).toBe(expected, values)
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should complete when empty source", () => {
    rxTestScheduler.run(({ hot, expectObservable }) => {
      const source = hot("|")
      const expected = "  |"
      expectObservable(source.pipe(zipAll())).toBe(expected)
    })
  })
})
import { expect } from "chai"
import { zipWith, mergeMap } from "rxjs/operators"
import { queueScheduler, of, scheduled } from "rxjs"
import { TestScheduler } from "rxjs/testing"
import { observableMatcher } from "../helpers/observableMatcher"
/** @test {zipWith} */
describe("zipWith", () => {
  let rxTestScheduler: TestScheduler
  beforeEach(() => {
    rxTestScheduler = new TestScheduler(observableMatcher)
  })
  it("should combine a source with a second", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("   ---1---2---3-----")
      const asubs = "   ^"
      const b = hot("   --4--5--6--7--8--")
      const bsubs = "   ^"
      const expected = "---x---y---z-----"
      expectObservable(a.pipe(zipWith(b))).toBe(expected, {
        x: ["1", "4"],
        y: ["2", "5"],
        z: ["3", "6"],
      })
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should end once one observable completes and its buffer is empty", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---a--b--c--|               ")
      const e1subs = "  ^-----------!               "
      const e2 = hot("  ------d----e----f--------|  ")
      const e2subs = "  ^-----------------!         "
      const e3 = hot("  --------h----i----j---------") // doesn't complete
      const e3subs = "  ^-----------------!         "
      const expected = "--------x----y----(z|)      " // e1 complete and buffer empty
      const values = {
        x: ["a", "d", "h"],
        y: ["b", "e", "i"],
        z: ["c", "f", "j"],
      }
      expectObservable(e1.pipe(zipWith(e2, e3))).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
      expectSubscriptions(e3.subscriptions).toBe(e3subs)
    })
  })
  it("should end once one observable nexts and zips value from completed other observable whose buffer is empty", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const e1 = hot("  ---a--b--c--|             ")
      const e1subs = "  ^-----------!             "
      const e2 = hot("  ------d----e----f|        ")
      const e2subs = "  ^----------------!        "
      const e3 = hot("  --------h----i----j-------") // doesn't complete
      const e3subs = "  ^-----------------!       "
      const expected = "--------x----y----(z|)    " // e2 buffer empty and signaled complete
      const values = {
        x: ["a", "d", "h"],
        y: ["b", "e", "i"],
        z: ["c", "f", "j"],
      }
      expectObservable(e1.pipe(zipWith(e2, e3))).toBe(expected, values)
      expectSubscriptions(e1.subscriptions).toBe(e1subs)
      expectSubscriptions(e2.subscriptions).toBe(e2subs)
      expectSubscriptions(e3.subscriptions).toBe(e3subs)
    })
  })
  describe("with iterables", () => {
    it("should zip them with values", () => {
      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
        const myIterator = (function* () {
          for (let i = 0; i < 4; i++) {
            yield i
          }
        })()
        const e1 = hot("  ---a---b---c---d---|")
        const e1subs = "  ^--------------!"
        const expected = "---w---x---y---(z|)"
        const values = {
          w: ["a", 0],
          x: ["b", 1],
          y: ["c", 2],
          z: ["d", 3],
        }
        expectObservable(e1.pipe(zipWith(myIterator))).toBe(expected, values)
        expectSubscriptions(e1.subscriptions).toBe(e1subs)
      })
    })
    it("should complete instantly for an empty iterable", () => {
      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
        const a = cold("  -")
        const asubs = "   (^!)"
        const expected = "|"
        const b: string[] = []
        expectObservable(a.pipe(zipWith(b))).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
      })
    })
    it("should work with empty observable and empty iterable", () => {
      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
        const a = cold("  |")
        const asubs = "   (^!)"
        const expected = "|"
        const b: string[] = []
        expectObservable(a.pipe(zipWith(b))).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
      })
    })
    it("should work with empty observable and non-empty iterable", () => {
      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
        const a = cold("  |")
        const asubs = "   (^!)"
        const expected = "|"
        const b = [1]
        expectObservable(a.pipe(zipWith(b))).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
      })
    })
    it("should complete instantly with non-empty observable and empty iterable", () => {
      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
        const a = hot("   ---^----a--|")
        const asubs = "      (^!)"
        const b: string[] = []
        const expected = "   |"
        expectObservable(a.pipe(zipWith(b))).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
      })
    })
    it("should work with never observable and non-empty iterable", () => {
      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
        const a = cold("  -")
        const asubs = "   ^"
        const expected = "-"
        const b = [1]
        expectObservable(a.pipe(zipWith(b))).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
      })
    })
    it("should work with non-empty observable and non-empty iterable", () => {
      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
        const a = hot("---^----1--|")
        const asubs = "   ^----!   "
        const expected = "-----(x|)"
        const b = [2]
        expectObservable(a.pipe(zipWith(b))).toBe(expected, { x: ["1", 2] })
        expectSubscriptions(a.subscriptions).toBe(asubs)
      })
    })
    it("should work with observable which raises error and non-empty iterable", () => {
      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
        const a = hot("---^----#")
        const asubs = "   ^----!"
        const expected = "-----#"
        const b = [1]
        expectObservable(a.pipe(zipWith(b))).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
      })
    })
    it("should work with non-empty many observable and non-empty many iterable", () => {
      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
        const a = hot("---^--1--2--3--|")
        const asubs = "   ^--------!   "
        const expected = "---x--y--(z|)"
        const b = [4, 5, 6]
        expectObservable(a.pipe(zipWith(b))).toBe(expected, {
          x: ["1", 4],
          y: ["2", 5],
          z: ["3", 6],
        })
        expectSubscriptions(a.subscriptions).toBe(asubs)
      })
    })
  })
  it("should work with n-ary symmetric", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("---1-^-1----4----|")
      const asubs = "     ^---------!  "
      const b = hot("---1-^--2--5----| ")
      const bsubs = "     ^---------!  "
      const c = hot("---1-^---3---6-|  ")
      const expected = "  ----x---y-|  "
      expectObservable(a.pipe(zipWith(b, c))).toBe(expected, {
        x: ["1", "2", "3"],
        y: ["4", "5", "6"],
      })
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with right completes first", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("---1-^-2-----|")
      const asubs = "     ^-----!"
      const b = hot("---1-^--3--|")
      const bsubs = "     ^-----!"
      const expected = "  ---x--|"
      expectObservable(a.pipe(zipWith(b))).toBe(expected, { x: ["2", "3"] })
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with two nevers", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const a = cold("  -")
      const asubs = "   ^"
      const b = cold("  -")
      const bsubs = "   ^"
      const expected = "-"
      expectObservable(a.pipe(zipWith(b))).toBe(expected)
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with never and empty", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const a = cold("  -")
      const asubs = "   (^!)"
      const b = cold("  |")
      const bsubs = "   (^!)"
      const expected = "|"
      expectObservable(a.pipe(zipWith(b))).toBe(expected)
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with empty and never", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const a = cold("  |")
      const asubs = "   (^!)"
      const b = cold("  -")
      const bsubs = "   (^!)"
      const expected = "|"
      expectObservable(a.pipe(zipWith(b))).toBe(expected)
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with empty and empty", () => {
    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {
      const a = cold("  |")
      const asubs = "   (^!)"
      const b = cold("  |")
      const bsubs = "   (^!)"
      const expected = "|"
      expectObservable(a.pipe(zipWith(b))).toBe(expected)
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with empty and non-empty", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const a = cold("  |")
        const asubs = "   (^!)"
        const b = hot("   ---1--|")
        const bsubs = "   (^!)"
        const expected = "|"
        expectObservable(a.pipe(zipWith(b))).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
      }
    )
  })
  it("should work with non-empty and empty", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const a = hot("   ---1--|")
        const asubs = "   (^!)"
        const b = cold("  |")
        const bsubs = "   (^!)"
        const expected = "|"
        expectObservable(a.pipe(zipWith(b))).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
      }
    )
  })
  it("should work with never and non-empty", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const a = cold("  -")
        const asubs = "   ^"
        const b = hot("   ---1--|")
        const bsubs = "   ^-----!"
        const expected = "-"
        expectObservable(a.pipe(zipWith(b))).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
      }
    )
  })
  it("should work with non-empty and never", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const a = hot("   ---1--|")
        const asubs = "   ^-----!"
        const b = cold("  -")
        const bsubs = "   ^"
        const expected = "-"
        expectObservable(a.pipe(zipWith(b))).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
      }
    )
  })
  it("should work with empty and error", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const a = cold("  |")
        const asubs = "   (^!)"
        const b = hot("   ------#", undefined, "too bad")
        const bsubs = "   (^!)"
        const expected = "|"
        expectObservable(a.pipe(zipWith(b))).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
      }
    )
  })
  it("should work with error and empty", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const a = hot("   ------#", undefined, "too bad")
        const asubs = "   (^!)"
        const b = cold("  |")
        const bsubs = "   (^!)"
        const expected = "|"
        expectObservable(a.pipe(zipWith(b))).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
      }
    )
  })
  it("should work with error", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("   ----------|")
      const asubs = "   ^-----!    "
      const b = hot("   ------#    ")
      const bsubs = "   ^-----!    "
      const expected = "------#    "
      expectObservable(a.pipe(zipWith(b))).toBe(expected)
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with never and error", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const a = cold("  -------")
        const asubs = "   ^-----!"
        const b = hot("   ------#")
        const bsubs = "   ^-----!"
        const expected = "------#"
        expectObservable(a.pipe(zipWith(b))).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
      }
    )
  })
  it("should work with error and never", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const a = hot("   ------#")
        const asubs = "   ^-----!"
        const b = cold("  -------")
        const bsubs = "   ^-----!"
        const expected = "------#"
        expectObservable(a.pipe(zipWith(b))).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
      }
    )
  })
  it("should work with error and error", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("   ------#", undefined, "too bad")
      const asubs = "   ^-----!"
      const b = hot("   ----------#", undefined, "too bad 2")
      const bsubs = "   ^-----!"
      const expected = "------#"
      expectObservable(a.pipe(zipWith(b))).toBe(expected, null, "too bad")
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with two sources that eventually raise errors", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("   --w-----#----", { w: 1 }, "too bad")
      const asubs = "   ^-------!"
      const b = hot("   -----z-----#-", { z: 2 }, "too bad 2")
      const bsubs = "   ^-------!"
      const expected = "-----x--#"
      expectObservable(a.pipe(zipWith(b))).toBe(
        expected,
        { x: [1, 2] },
        "too bad"
      )
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with two sources that eventually raise errors (swapped)", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("   -----z-----#-", { z: 2 }, "too bad 2")
      const asubs = "   ^-------!"
      const b = hot("   --w-----#----", { w: 1 }, "too bad")
      const bsubs = "   ^-------!"
      const expected = "-----x--#"
      expectObservable(a.pipe(zipWith(b))).toBe(
        expected,
        { x: [2, 1] },
        "too bad"
      )
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
  it("should work with error and some", () => {
    rxTestScheduler.run(
      ({ cold, hot, expectObservable, expectSubscriptions }) => {
        const a = cold("  #")
        const asubs = "   (^!)"
        const b = hot("   --1--2--3--")
        const bsubs = "   (^!)"
        const expected = "#"
        expectObservable(a.pipe(zipWith(b))).toBe(expected)
        expectSubscriptions(a.subscriptions).toBe(asubs)
        expectSubscriptions(b.subscriptions).toBe(bsubs)
      }
    )
  })
  it("should combine an immediately-scheduled source with an immediately-scheduled second", done => {
    const a = scheduled([1, 2, 3], queueScheduler)
    const b = scheduled([4, 5, 6, 7, 8], queueScheduler)
    const r = [
      [1, 4],
      [2, 5],
      [3, 6],
    ]
    let i = 0
    a.pipe(zipWith(b)).subscribe({
      next(vals) {
        expect(vals).to.deep.equal(r[i++])
      },
      complete: done,
    })
  })
  it("should not break unsubscription chain when unsubscribed explicitly", () => {
    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {
      const a = hot("   ---1---2---3---|")
      const unsub = "   ---------!"
      const asubs = "   ^--------!"
      const b = hot("   --4--5--6--7--8--|")
      const bsubs = "   ^--------!"
      const expected = "---x---y--"
      const r = a.pipe(
        mergeMap(x => of(x)),
        zipWith(b),
        mergeMap(x => of(x))
      )
      expectObservable(r, unsub).toBe(expected, {
        x: ["1", "4"],
        y: ["2", "5"],
      })
      expectSubscriptions(a.subscriptions).toBe(asubs)
      expectSubscriptions(b.subscriptions).toBe(bsubs)
    })
  })
})
